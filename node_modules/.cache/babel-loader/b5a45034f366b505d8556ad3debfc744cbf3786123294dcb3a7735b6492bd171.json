{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _filter = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\nvar _keys2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/keys\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\nfunction quote(s) {\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\nfunction _getClassNameFromQueries(queries) {\n  let className = null;\n  (0, _forEach.default)(queries).call(queries, q => {\n    if (!className) {\n      className = q.className;\n    }\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\nfunction handleSelectResult(data, select) {\n  const serverDataMask = {};\n  (0, _forEach.default)(select).call(select, field => {\n    const hasSubObjectSelect = (0, _indexOf.default)(field).call(field, '.') !== -1;\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      const pathComponents = field.split('.');\n      let obj = data;\n      let serverMask = serverDataMask;\n      (0, _forEach.default)(pathComponents).call(pathComponents, (component, index, arr) => {\n        // add keys if the expected data is missing\n        if (obj && !obj.hasOwnProperty(component)) {\n          obj[component] = undefined;\n        }\n        if (obj && typeof obj === 'object') {\n          obj = obj[component];\n        }\n\n        //add this path component to the server mask so we can fill it in later if needed\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n  if ((0, _keys.default)(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n\n    const serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n  }\n  for (const key in mask) {\n    if (dest[key] !== undefined && dest[key] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[key], dest[key], mask[key], true);\n    }\n  }\n}\nfunction handleOfflineSort(a, b, sorts) {\n  let order = sorts[0];\n  const operator = (0, _slice.default)(order).call(order, 0, 1);\n  const isDescending = operator === '-';\n  if (isDescending) {\n    order = order.substring(1);\n  }\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${order}`);\n  }\n  const field1 = a.get(order);\n  const field2 = b.get(order);\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n  if (sorts.length > 1) {\n    const remainingSorts = (0, _slice.default)(sorts).call(sorts, 1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\nclass ParseQuery {\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  constructor(objectClass) {\n    /**\n     * @property {string} className\n     */\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_where\", void 0);\n    (0, _defineProperty2.default)(this, \"_watch\", void 0);\n    (0, _defineProperty2.default)(this, \"_include\", void 0);\n    (0, _defineProperty2.default)(this, \"_exclude\", void 0);\n    (0, _defineProperty2.default)(this, \"_select\", void 0);\n    (0, _defineProperty2.default)(this, \"_limit\", void 0);\n    (0, _defineProperty2.default)(this, \"_skip\", void 0);\n    (0, _defineProperty2.default)(this, \"_count\", void 0);\n    (0, _defineProperty2.default)(this, \"_order\", void 0);\n    (0, _defineProperty2.default)(this, \"_readPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_includeReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_subqueryReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_queriesLocalDatastore\", void 0);\n    (0, _defineProperty2.default)(this, \"_localDatastorePinName\", void 0);\n    (0, _defineProperty2.default)(this, \"_extraOptions\", void 0);\n    (0, _defineProperty2.default)(this, \"_hint\", void 0);\n    (0, _defineProperty2.default)(this, \"_explain\", void 0);\n    (0, _defineProperty2.default)(this, \"_xhrRequest\", void 0);\n    (0, _defineProperty2.default)(this, \"_comment\", void 0);\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      const objClass = objectClass;\n      if (typeof objClass.className === 'string') {\n        this.className = objClass.className;\n      } else {\n        const obj = new objClass();\n        this.className = obj.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n    this._where = {};\n    this._watch = [];\n    this._include = [];\n    this._exclude = [];\n    this._count = false;\n    this._limit = -1; // negative limit is not sent in the server request\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: () => {}\n    };\n    this._comment = null;\n  }\n\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _orQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$or = queryJSON;\n    return this;\n  }\n\n  /**\n   * Adds constraint that all of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _andQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$and = queryJSON;\n    return this;\n  }\n\n  /**\n   * Adds constraint that none of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _norQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$nor = queryJSON;\n    return this;\n  }\n\n  /**\n   * Helper for condition queries\n   *\n   * @param key\n   * @param condition\n   * @param value\n   * @returns {Parse.Query}\n   */\n  _addCondition(key, condition, value) {\n    if (!this._where[key] || typeof this._where[key] === 'string') {\n      this._where[key] = {};\n    }\n    this._where[key][condition] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n\n  /**\n   * Converts string for regular expression at the beginning\n   *\n   * @param string\n   * @returns {string}\n   */\n  _regexStartWith(string) {\n    return '^' + quote(string);\n  }\n  async _handleOfflineQuery(params) {\n    var _context;\n    _OfflineQuery.default.validateQuery(this);\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const objects = await localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n    let results = (0, _filter.default)(_context = (0, _map.default)(objects).call(objects, (json, index, arr) => {\n      const object = _ParseObject.default.fromJSON(json, false);\n      if (json._localId && !json.objectId) {\n        object._localId = json._localId;\n      }\n      if (!_OfflineQuery.default.matchesQuery(this.className, object, arr, this)) {\n        return null;\n      }\n      return object;\n    })).call(_context, object => object !== null);\n    if ((0, _keys2.default)(params)) {\n      let keys = (0, _keys2.default)(params).split(',');\n      keys = (0, _concat.default)(keys).call(keys, ['className', 'objectId', 'createdAt', 'updatedAt', 'ACL']);\n      results = (0, _map.default)(results).call(results, object => {\n        var _context2;\n        const json = object._toFullJSON();\n        (0, _forEach.default)(_context2 = (0, _keys.default)(json)).call(_context2, key => {\n          if (!(0, _includes.default)(keys).call(keys, key)) {\n            delete json[key];\n          }\n        });\n        return _ParseObject.default.fromJSON(json, false);\n      });\n    }\n    if (params.order) {\n      const sorts = params.order.split(',');\n      (0, _sort.default)(results).call(results, (a, b) => {\n        return handleOfflineSort(a, b, sorts);\n      });\n    }\n    let count; // count total before applying limit/skip\n    if (params.count) {\n      count = results.length; // total count from response\n    }\n    if (params.skip) {\n      if (params.skip >= results.length) {\n        results = [];\n      } else {\n        results = (0, _splice.default)(results).call(results, params.skip, results.length);\n      }\n    }\n    let limit = results.length;\n    if (params.limit !== 0 && params.limit < results.length) {\n      limit = params.limit;\n    }\n    results = (0, _splice.default)(results).call(results, 0, limit);\n    if (typeof count === 'number') {\n      return {\n        results,\n        count\n      };\n    }\n    return results;\n  }\n\n  /**\n   * Returns a JSON representation of this query.\n   *\n   * @returns {object} The JSON representation of the query.\n   */\n  toJSON() {\n    const params = {\n      where: this._where\n    };\n    if (this._watch.length) {\n      params.watch = this._watch.join(',');\n    }\n    if (this._include.length) {\n      params.include = this._include.join(',');\n    }\n    if (this._exclude.length) {\n      params.excludeKeys = this._exclude.join(',');\n    }\n    if (this._select) {\n      params.keys = this._select.join(',');\n    }\n    if (this._count) {\n      params.count = 1;\n    }\n    if (this._limit >= 0) {\n      params.limit = this._limit;\n    }\n    if (this._skip > 0) {\n      params.skip = this._skip;\n    }\n    if (this._order) {\n      params.order = this._order.join(',');\n    }\n    if (this._readPreference) {\n      params.readPreference = this._readPreference;\n    }\n    if (this._includeReadPreference) {\n      params.includeReadPreference = this._includeReadPreference;\n    }\n    if (this._subqueryReadPreference) {\n      params.subqueryReadPreference = this._subqueryReadPreference;\n    }\n    if (this._hint) {\n      params.hint = this._hint;\n    }\n    if (this._explain) {\n      params.explain = true;\n    }\n    if (this._comment) {\n      params.comment = this._comment;\n    }\n    for (const key in this._extraOptions) {\n      params[key] = this._extraOptions[key];\n    }\n    return params;\n  }\n\n  /**\n   * Return a query with conditions from json, can be useful to send query from server side to client\n   * Not static, all query conditions was set before calling this method will be deleted.\n   * For example on the server side we have\n   * var query = new Parse.Query(\"className\");\n   * query.equalTo(key: value);\n   * query.limit(100);\n   * ... (others queries)\n   * Create JSON representation of Query Object\n   * var jsonFromServer = query.fromJSON();\n   *\n   * On client side getting query:\n   * var query = new Parse.Query(\"className\");\n   * query.fromJSON(jsonFromServer);\n   *\n   * and continue to query...\n   * query.skip(100).find().then(...);\n   *\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withJSON(json) {\n    if (json.where) {\n      this._where = json.where;\n    }\n    if (json.watch) {\n      this._watch = json.watch.split(',');\n    }\n    if (json.include) {\n      this._include = json.include.split(',');\n    }\n    if ((0, _keys2.default)(json)) {\n      this._select = (0, _keys2.default)(json).split(',');\n    }\n    if (json.excludeKeys) {\n      this._exclude = json.excludeKeys.split(',');\n    }\n    if (json.count) {\n      this._count = json.count === 1;\n    }\n    if (json.limit) {\n      this._limit = json.limit;\n    }\n    if (json.skip) {\n      this._skip = json.skip;\n    }\n    if (json.order) {\n      this._order = json.order.split(',');\n    }\n    if (json.readPreference) {\n      this._readPreference = json.readPreference;\n    }\n    if (json.includeReadPreference) {\n      this._includeReadPreference = json.includeReadPreference;\n    }\n    if (json.subqueryReadPreference) {\n      this._subqueryReadPreference = json.subqueryReadPreference;\n    }\n    if (json.hint) {\n      this._hint = json.hint;\n    }\n    if (json.explain) {\n      this._explain = !!json.explain;\n    }\n    if (json.comment) {\n      this._comment = json.comment;\n    }\n    for (const key in json) {\n      if (json.hasOwnProperty(key)) {\n        var _context3;\n        if ((0, _indexOf.default)(_context3 = ['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain', 'comment']).call(_context3, key) === -1) {\n          this._extraOptions[key] = json[key];\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Static method to restore Parse.Query by json representation\n   * Internally calling Parse.Query.withJSON\n   *\n   * @param {string} className\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} new created query\n   */\n  static fromJSON(className, json) {\n    const query = new ParseQuery(className);\n    return query.withJSON(json);\n  }\n\n  /**\n   * Constructs a Parse.Object whose id is already known by fetching data from\n   * the server. Unlike the <code>first</code> method, it never returns undefined.\n   *\n   * @param {string} objectId The id of the object to be fetched.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  get(objectId, options) {\n    this.equalTo('objectId', objectId);\n    const firstOptions = {};\n    if (options && options.hasOwnProperty('useMasterKey')) {\n      firstOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options && options.hasOwnProperty('sessionToken')) {\n      firstOptions.sessionToken = options.sessionToken;\n    }\n    if (options && options.hasOwnProperty('context') && typeof options.context === 'object') {\n      firstOptions.context = options.context;\n    }\n    if (options && options.hasOwnProperty('json')) {\n      firstOptions.json = options.json;\n    }\n    return this.first(firstOptions).then(response => {\n      if (response) {\n        return response;\n      }\n      const errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n      return _promise.default.reject(errorObject);\n    });\n  }\n\n  /**\n   * Retrieves a list of ParseObjects that satisfy this query.\n   *\n   * @param {object} options Valid options\n   * are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n  find(options) {\n    options = options || {};\n    const findOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const select = this._select;\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(this.toJSON());\n    }\n    return (0, _find.default)(controller).call(controller, this.className, this.toJSON(), findOptions).then(response => {\n      // Return generic object when explain is used\n      if (this._explain) {\n        return response.results;\n      }\n      const results = response.results?.map(data => {\n        // In cases of relations, the server may send back a className\n        // on the top level of the payload\n        const override = response.className || this.className;\n        if (!data.className) {\n          data.className = override;\n        }\n\n        // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n        if (select) {\n          handleSelectResult(data, select);\n        }\n        if (options.json) {\n          return data;\n        } else {\n          return _ParseObject.default.fromJSON(data, !select);\n        }\n      });\n      const count = response.count;\n      if (typeof count === 'number') {\n        return {\n          results,\n          count\n        };\n      } else {\n        return results;\n      }\n    });\n  }\n\n  /**\n   * Retrieves a complete list of ParseObjects that satisfy this query.\n   * Using `eachBatch` under the hood to fetch all the valid objects.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n  async findAll(options) {\n    let result = [];\n    await this.eachBatch(objects => {\n      result = [...result, ...objects];\n    }, options);\n    return result;\n  }\n\n  /**\n   * Counts the number of objects that match this query.\n   *\n   * @param {object} options\n   * @param {boolean} [options.useMasterKey]\n   * @param {string} [options.sessionToken]\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the count when\n   * the query completes.\n   */\n  count(options) {\n    options = options || {};\n    const findOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = this.toJSON();\n    params.limit = 0;\n    params.count = 1;\n    return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(result => {\n      return result.count;\n    });\n  }\n\n  /**\n   * Executes a distinct query and returns unique values\n   *\n   * @param {string} key A field to find distinct values\n   * @param {object} options\n   * @param {string} [options.sessionToken] A valid session token, used for making a request on behalf of a specific user.\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n  distinct(key, options) {\n    options = options || {};\n    const distinctOptions = {\n      useMasterKey: true\n    };\n    if (options.hasOwnProperty('sessionToken')) {\n      distinctOptions.sessionToken = options.sessionToken;\n    }\n    this._setRequestTask(distinctOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = {\n      distinct: key,\n      where: this._where,\n      hint: this._hint\n    };\n    return controller.aggregate(this.className, params, distinctOptions).then(results => {\n      return results.results;\n    });\n  }\n\n  /**\n   * Executes an aggregate query and returns aggregate results\n   *\n   * @param {(Array|object)} pipeline Array or Object of stages to process query\n   * @param {object} options\n   * @param {string} [options.sessionToken] A valid session token, used for making a request on behalf of a specific user.\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n  aggregate(pipeline, options) {\n    options = options || {};\n    const aggregateOptions = {\n      useMasterKey: true\n    };\n    if (options.hasOwnProperty('sessionToken')) {\n      aggregateOptions.sessionToken = options.sessionToken;\n    }\n    this._setRequestTask(aggregateOptions);\n    const controller = _CoreManager.default.getQueryController();\n    if (!(0, _isArray.default)(pipeline) && typeof pipeline !== 'object') {\n      throw new Error('Invalid pipeline must be Array or Object');\n    }\n    if ((0, _keys.default)(this._where || {}).length) {\n      if (!(0, _isArray.default)(pipeline)) {\n        pipeline = [pipeline];\n      }\n      pipeline.unshift({\n        $match: this._where\n      });\n    }\n    const params = {\n      pipeline,\n      hint: this._hint,\n      explain: this._explain,\n      readPreference: this._readPreference\n    };\n    return controller.aggregate(this.className, params, aggregateOptions).then(results => {\n      return results.results;\n    });\n  }\n\n  /**\n   * Retrieves at most one Parse.Object that satisfies this query.\n   *\n   * Returns the object if there is one, otherwise undefined.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the object when\n   * the query completes.\n   */\n  first() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const findOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = this.toJSON();\n    params.limit = 1;\n    const select = this._select;\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(params).then(objects => {\n        if (!objects[0]) {\n          return undefined;\n        }\n        return objects[0];\n      });\n    }\n    return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(response => {\n      const objects = response.results;\n      if (!objects[0]) {\n        return undefined;\n      }\n      if (!objects[0].className) {\n        objects[0].className = this.className;\n      }\n\n      // Make sure the data object contains keys for all objects that\n      // have been requested with a select, so that our cached state\n      // updates correctly.\n      if (select) {\n        handleSelectResult(objects[0], select);\n      }\n      if (options.json) {\n        return objects[0];\n      } else {\n        return _ParseObject.default.fromJSON(objects[0], !select);\n      }\n    });\n  }\n\n  /**\n   * Iterates over objects matching a query, calling a callback for each batch.\n   * If the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are processed\n   * in an unspecified order. The query may not have any sort order, and may\n   * not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  eachBatch(callback, options) {\n    options = options || {};\n    if (this._order || this._skip || this._limit >= 0) {\n      return _promise.default.reject('Cannot iterate on a query with sort, skip, or limit.');\n    }\n    const query = new ParseQuery(this.className);\n    query._limit = options.batchSize || 100;\n    query._include = [...this._include];\n    query._exclude = [...this._exclude];\n    if (this._select) {\n      query._select = [...this._select];\n    }\n    query._hint = this._hint;\n    query._where = {};\n    for (const attr in this._where) {\n      const val = this._where[attr];\n      if ((0, _isArray.default)(val)) {\n        query._where[attr] = (0, _map.default)(val).call(val, v => {\n          return v;\n        });\n      } else if (val && typeof val === 'object') {\n        const conditionMap = {};\n        query._where[attr] = conditionMap;\n        for (const cond in val) {\n          conditionMap[cond] = val[cond];\n        }\n      } else {\n        query._where[attr] = val;\n      }\n    }\n    query.ascending('objectId');\n    const findOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n    if (options.hasOwnProperty('json')) {\n      findOptions.json = options.json;\n    }\n    let finished = false;\n    let previousResults = [];\n    return (0, _promiseUtils.continueWhile)(() => {\n      return !finished;\n    }, async () => {\n      const [results] = await _promise.default.all([(0, _find.default)(query).call(query, findOptions), _promise.default.resolve(previousResults.length > 0 && callback(previousResults))]);\n      if (results.length >= query._limit) {\n        query.greaterThan('objectId', results[results.length - 1].id);\n        previousResults = results;\n      } else if (results.length > 0) {\n        await _promise.default.resolve(callback(results));\n        finished = true;\n      } else {\n        finished = true;\n      }\n    });\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  each(callback, options) {\n    return this.eachBatch(results => {\n      let callbacksDone = _promise.default.resolve();\n      (0, _forEach.default)(results).call(results, result => {\n        callbacksDone = callbacksDone.then(() => {\n          return callback(result);\n        });\n      });\n      return callbacksDone;\n    }, options);\n  }\n\n  /**\n   * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n   *\n   * @param {(string|object)} value String or Object of index that should be used when executing query\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  hint(value) {\n    if (typeof value === 'undefined') {\n      delete this._hint;\n    }\n    this._hint = value;\n    return this;\n  }\n\n  /**\n   * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n   *\n   * @param {boolean} explain Used to toggle the information on the query plan.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  explain() {\n    let explain = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof explain !== 'boolean') {\n      throw new Error('You can only set explain to a boolean value');\n    }\n    this._explain = explain;\n    return this;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query map was called upon.</li>\n   * </ul>\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async map(callback, options) {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return _promise.default.resolve(callback(object, index, this)).then(result => {\n        array.push(result);\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   * </ul>\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async reduce(callback, initialValue, options) {\n    let accumulator = initialValue;\n    let index = 0;\n    await this.each(object => {\n      // If no initial value was given, we take the first object from the query\n      // as the initial value and don't call the callback with it.\n      if (index === 0 && initialValue === undefined) {\n        accumulator = object;\n        index += 1;\n        return;\n      }\n      return _promise.default.resolve(callback(accumulator, object, index)).then(result => {\n        accumulator = result;\n        index += 1;\n      });\n    }, options);\n    if (index === 0 && initialValue === undefined) {\n      // Match Array.reduce behavior: \"Calling reduce() on an empty array\n      // without an initialValue will throw a TypeError\".\n      throw new TypeError('Reducing empty query result set with no initial value');\n    }\n    return accumulator;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query filter was called upon.</li>\n   * </ul>\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async filter(callback, options) {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return _promise.default.resolve(callback(object, index, this)).then(flag => {\n        if (flag) {\n          array.push(object);\n        }\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n\n  /* Query Conditions */\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that the Parse.Object must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  equalTo(key, value) {\n    if (key && typeof key === 'object') {\n      var _context4;\n      (0, _forEach.default)(_context4 = (0, _entries.default)(key)).call(_context4, _ref => {\n        let [k, val] = _ref;\n        return this.equalTo(k, val);\n      });\n      return this;\n    }\n    if (typeof value === 'undefined') {\n      return this.doesNotExist(key);\n    }\n    this._where[key] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be not equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that must not be equalled.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  notEqualTo(key, value) {\n    if (key && typeof key === 'object') {\n      var _context5;\n      (0, _forEach.default)(_context5 = (0, _entries.default)(key)).call(_context5, _ref2 => {\n        let [k, val] = _ref2;\n        return this.notEqualTo(k, val);\n      });\n      return this;\n    }\n    return this._addCondition(key, '$ne', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  lessThan(key, value) {\n    return this._addCondition(key, '$lt', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  greaterThan(key, value) {\n    return this._addCondition(key, '$gt', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  lessThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$lte', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  greaterThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$gte', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {Array<*>} value The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containedIn(key, value) {\n    return this._addCondition(key, '$in', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * not be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {Array<*>} value The values that will not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  notContainedIn(key, value) {\n    return this._addCondition(key, '$nin', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained by the provided list of values. Get objects where all array elements match.\n   *\n   * @param {string} key The key to check.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containedBy(key, values) {\n    return this._addCondition(key, '$containedBy', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containsAll(key, values) {\n    return this._addCondition(key, '$all', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values starting with given strings.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array<string>} values The string values that will match as starting string.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containsAllStartingWith(key, values) {\n    if (!(0, _isArray.default)(values)) {\n      values = [values];\n    }\n    const regexObject = (0, _map.default)(values).call(values, value => {\n      return {\n        $regex: this._regexStartWith(value)\n      };\n    });\n    return this.containsAll(key, regexObject);\n  }\n\n  /**\n   * Adds a constraint for finding objects that contain the given key.\n   *\n   * @param {string} key The key that should exist.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  exists(key) {\n    return this._addCondition(key, '$exists', true);\n  }\n\n  /**\n   * Adds a constraint for finding objects that do not contain a given key.\n   *\n   * @param {string} key The key that should not exist\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotExist(key) {\n    return this._addCondition(key, '$exists', false);\n  }\n\n  /**\n   * Adds a regular expression constraint for finding string values that match\n   * the provided regular expression.\n   * This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {RegExp | string} regex The regular expression pattern to match.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matches(key, regex, modifiers) {\n    this._addCondition(key, '$regex', regex);\n    if (!modifiers) {\n      modifiers = '';\n    }\n    if (typeof regex !== 'string') {\n      if (regex.ignoreCase) {\n        modifiers += 'i';\n      }\n      if (regex.multiline) {\n        modifiers += 'm';\n      }\n    }\n    if (modifiers.length) {\n      this._addCondition(key, '$options', modifiers);\n    }\n    return this;\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value matches a Parse.Query\n   * constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matchesQuery(key, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$inQuery', queryJSON);\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value not matches a\n   * Parse.Query constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotMatchQuery(key, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$notInQuery', queryJSON);\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value matches a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     matched.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matchesKeyInQuery(key, queryKey, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$select', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value not match a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     excluded.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotMatchKeyInQuery(key, queryKey, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$dontSelect', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string.  This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} substring The substring that the value must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  contains(key, substring) {\n    if (typeof substring !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this._addCondition(key, '$regex', quote(substring));\n  }\n\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n   *\n   * In order to sort you must use select and ascending ($score is required)\n   *  <pre>\n   *   query.fullText('field', 'term');\n   *   query.ascending('$score');\n   *   query.select('$score');\n   *  </pre>\n   *\n   * To retrieve the weight / rank\n   *  <pre>\n   *   object->get('score');\n   *  </pre>\n   *\n   * You can define optionals by providing an object as a third parameter\n   *  <pre>\n   *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n   *  </pre>\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} value The string to search\n   * @param {object} options (Optional)\n   * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n   * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n   * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fullText(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    options = options || {};\n    if (!key) {\n      throw new Error('A key is required.');\n    }\n    if (!value) {\n      throw new Error('A search term is required');\n    }\n    if (typeof value !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    const fullOptions = {};\n    fullOptions.$term = value;\n    for (const option in options) {\n      switch (option) {\n        case 'language':\n          fullOptions.$language = options[option];\n          break;\n        case 'caseSensitive':\n          fullOptions.$caseSensitive = options[option];\n          break;\n        case 'diacriticSensitive':\n          fullOptions.$diacriticSensitive = options[option];\n          break;\n        default:\n          throw new Error(`Unknown option: ${option}`);\n      }\n    }\n    return this._addCondition(key, '$text', {\n      $search: fullOptions\n    });\n  }\n\n  /**\n   * Method to sort the full text search by text score\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  sortByTextScore() {\n    this.ascending('$score');\n    this.select(['$score']);\n    return this;\n  }\n\n  /**\n   * Adds a constraint for finding string values that start with a provided\n   * string.  This query will use the backend index, so it will be fast even\n   * for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} prefix The substring that the value must start with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  startsWith(key, prefix, modifiers) {\n    if (typeof prefix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this.matches(key, this._regexStartWith(prefix), modifiers);\n  }\n\n  /**\n   * Adds a constraint for finding string values that end with a provided\n   * string.  This will be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} suffix The substring that the value must end with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  endsWith(key, suffix, modifiers) {\n    if (typeof suffix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this.matches(key, quote(suffix) + '$', modifiers);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  near(key, point) {\n    if (!(point instanceof _ParseGeoPoint.default)) {\n      // Try to cast it as a GeoPoint\n      point = new _ParseGeoPoint.default(point);\n    }\n    return this._addCondition(key, '$nearSphere', point);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in radians) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinRadians(key, point, maxDistance, sorted) {\n    if (sorted || sorted === undefined) {\n      this.near(key, point);\n      return this._addCondition(key, '$maxDistance', maxDistance);\n    } else {\n      return this._addCondition(key, '$geoWithin', {\n        $centerSphere: [[point.longitude, point.latitude], maxDistance]\n      });\n    }\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 3958.8 miles.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in miles) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinMiles(key, point, maxDistance, sorted) {\n    return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 6371.0 kilometers.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinKilometers(key, point, maxDistance, sorted) {\n    return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within a given rectangular geographic bounding\n   * box.\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} southwest\n   *     The lower-left inclusive corner of the box.\n   * @param {Parse.GeoPoint} northeast\n   *     The upper-right inclusive corner of the box.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinGeoBox(key, southwest, northeast) {\n    if (!(southwest instanceof _ParseGeoPoint.default)) {\n      southwest = new _ParseGeoPoint.default(southwest);\n    }\n    if (!(northeast instanceof _ParseGeoPoint.default)) {\n      northeast = new _ParseGeoPoint.default(northeast);\n    }\n    this._addCondition(key, '$within', {\n      $box: [southwest, northeast]\n    });\n    return this;\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within and on the bounds of a given polygon.\n   * Supports closed and open (last point is connected to first) paths\n   *\n   * Polygon must have at least 3 points\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Array} points Array of Coordinates / GeoPoints\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinPolygon(key, points) {\n    return this._addCondition(key, '$geoWithin', {\n      $polygon: points\n    });\n  }\n\n  /**\n   * Add a constraint to the query that requires a particular key's\n   * coordinates that contains a ParseGeoPoint\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} point\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  polygonContains(key, point) {\n    return this._addCondition(key, '$geoIntersects', {\n      $point: point\n    });\n  }\n\n  /* Query Orderings */\n\n  /**\n   * Sorts the results in ascending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  ascending() {\n    this._order = [];\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    return this.addAscending.apply(this, keys);\n  }\n\n  /**\n   * Sorts the results in ascending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  addAscending() {\n    if (!this._order) {\n      this._order = [];\n    }\n    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      keys[_key2] = arguments[_key2];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      var _context6;\n      if ((0, _isArray.default)(key)) {\n        key = key.join();\n      }\n      this._order = (0, _concat.default)(_context6 = this._order).call(_context6, key.replace(/\\s/g, '').split(','));\n    });\n    return this;\n  }\n\n  /**\n   * Sorts the results in descending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  descending() {\n    this._order = [];\n    for (var _len3 = arguments.length, keys = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      keys[_key3] = arguments[_key3];\n    }\n    return this.addDescending.apply(this, keys);\n  }\n\n  /**\n   * Sorts the results in descending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  addDescending() {\n    if (!this._order) {\n      this._order = [];\n    }\n    for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      keys[_key4] = arguments[_key4];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      var _context7, _context8;\n      if ((0, _isArray.default)(key)) {\n        key = key.join();\n      }\n      this._order = (0, _concat.default)(_context7 = this._order).call(_context7, (0, _map.default)(_context8 = key.replace(/\\s/g, '').split(',')).call(_context8, k => {\n        return '-' + k;\n      }));\n    });\n    return this;\n  }\n\n  /* Query Options */\n\n  /**\n   * Sets the number of results to skip before returning any results.\n   * This is useful for pagination.\n   * Default is to skip zero results.\n   *\n   * @param {number} n the number of results to skip.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  skip(n) {\n    if (typeof n !== 'number' || n < 0) {\n      throw new Error('You can only skip by a positive number');\n    }\n    this._skip = n;\n    return this;\n  }\n\n  /**\n   * Sets the limit of the number of results to return. The default limit is 100.\n   *\n   * @param {number} n the number of results to limit to.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  limit(n) {\n    if (typeof n !== 'number') {\n      throw new Error('You can only set the limit to a numeric value');\n    }\n    this._limit = n;\n    return this;\n  }\n\n  /**\n   * Sets the flag to include with response the total number of objects satisfying this query,\n   * despite limits/skip. Might be useful for pagination.\n   * Note that result of this query will be wrapped as an object with\n   * `results`: holding {ParseObject} array and `count`: integer holding total number\n   *\n   * @param {boolean} includeCount false - disable, true - enable.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withCount() {\n    let includeCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof includeCount !== 'boolean') {\n      throw new Error('You can only set withCount to a boolean value');\n    }\n    this._count = includeCount;\n    return this;\n  }\n  /**\n   * Includes nested Parse.Objects for the provided key.  You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * You can include all nested Parse.Objects by passing in '*'.\n   * Requires Parse Server 3.0.0+\n   * <pre>query.include('*');</pre>\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  include() {\n    for (var _len5 = arguments.length, keys = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      keys[_key5] = arguments[_key5];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context9;\n        this._include = (0, _concat.default)(_context9 = this._include).call(_context9, key);\n      } else {\n        this._include.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Includes all nested Parse.Objects one level deep.\n   *\n   * Requires Parse Server 3.0.0+\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  includeAll() {\n    return this.include('*');\n  }\n\n  /**\n   * Restricts the fields of the returned Parse.Objects to include only the\n   * provided keys.  If this is called multiple times, then all of the keys\n   * specified in each of the calls will be included.\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  select() {\n    if (!this._select) {\n      this._select = [];\n    }\n    for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      keys[_key6] = arguments[_key6];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context10;\n        this._select = (0, _concat.default)(_context10 = this._select).call(_context10, key);\n      } else {\n        this._select.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Restricts the fields of the returned Parse.Objects to all keys except the\n   * provided keys. Exclude takes precedence over select and include.\n   *\n   * Requires Parse Server 3.6.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  exclude() {\n    for (var _len7 = arguments.length, keys = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      keys[_key7] = arguments[_key7];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context11;\n        this._exclude = (0, _concat.default)(_context11 = this._exclude).call(_context11, key);\n      } else {\n        this._exclude.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Restricts live query to trigger only for watched fields.\n   *\n   * Requires Parse Server 6.0.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to watch.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  watch() {\n    for (var _len8 = arguments.length, keys = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      keys[_key8] = arguments[_key8];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context12;\n        this._watch = (0, _concat.default)(_context12 = this._watch).call(_context12, key);\n      } else {\n        this._watch.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Changes the read preference that the backend will use when performing the query to the database.\n   *\n   * @param {string} readPreference The read preference for the main query.\n   * @param {string} includeReadPreference The read preference for the queries to include pointers.\n   * @param {string} subqueryReadPreference The read preference for the sub queries.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  readPreference(readPreference, includeReadPreference, subqueryReadPreference) {\n    this._readPreference = readPreference;\n    this._includeReadPreference = includeReadPreference || null;\n    this._subqueryReadPreference = subqueryReadPreference || null;\n    return this;\n  }\n\n  /**\n   * Subscribe this query to get liveQuery updates\n   *\n   * @param {string} sessionToken (optional) Defaults to the currentUser\n   * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n   * which can be used to get liveQuery updates.\n   */\n  async subscribe(sessionToken) {\n    const currentUser = await _CoreManager.default.getUserController().currentUserAsync();\n    if (!sessionToken) {\n      sessionToken = currentUser ? currentUser.getSessionToken() || undefined : undefined;\n    }\n    const liveQueryClient = await _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n    if (liveQueryClient.shouldOpen()) {\n      liveQueryClient.open();\n    }\n    const subscription = liveQueryClient.subscribe(this, sessionToken);\n    return subscription.subscribePromise.then(() => {\n      return subscription;\n    });\n  }\n\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to OR.\n   * @static\n   * @returns {Parse.Query} The query that is the OR of the passed in queries.\n   */\n  static or() {\n    for (var _len9 = arguments.length, queries = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      queries[_key9] = arguments[_key9];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._orQuery(queries);\n    return query;\n  }\n\n  /**\n   * Constructs a Parse.Query that is the AND of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an and of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to AND.\n   * @static\n   * @returns {Parse.Query} The query that is the AND of the passed in queries.\n   */\n  static and() {\n    for (var _len10 = arguments.length, queries = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      queries[_key10] = arguments[_key10];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._andQuery(queries);\n    return query;\n  }\n\n  /**\n   * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n   * example:\n   * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is a nor of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to NOR.\n   * @static\n   * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n   */\n  static nor() {\n    for (var _len11 = arguments.length, queries = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      queries[_key11] = arguments[_key11];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._norQuery(queries);\n    return query;\n  }\n\n  /**\n   * Change the source of this query to the server.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromNetwork() {\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    return this;\n  }\n\n  /**\n   * Changes the source of this query to all pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromLocalDatastore() {\n    return this.fromPinWithName(null);\n  }\n\n  /**\n   * Changes the source of this query to the default group of pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromPin() {\n    return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n\n  /**\n   * Changes the source of this query to a specific group of pinned objects.\n   *\n   * @param {string} name The name of query source.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromPinWithName(name) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (localDatastore.checkIfEnabled()) {\n      this._queriesLocalDatastore = true;\n      this._localDatastorePinName = name;\n    }\n    return this;\n  }\n\n  /**\n   * Cancels the current network request (if any is running).\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  cancel() {\n    if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n      this._xhrRequest.task._aborted = true;\n      this._xhrRequest.task.abort();\n      this._xhrRequest.task = null;\n      this._xhrRequest.onchange = () => {};\n      return this;\n    }\n    this._xhrRequest.onchange = () => this.cancel();\n    return this;\n  }\n  _setRequestTask(options) {\n    options.requestTask = task => {\n      this._xhrRequest.task = task;\n      this._xhrRequest.onchange();\n    };\n  }\n\n  /**\n   * Sets a comment to the query so that the query\n   * can be identified when using a the profiler for MongoDB.\n   *\n   * @param {string} value a comment can make your profile data easier to interpret and trace.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  comment(value) {\n    if (value == null) {\n      delete this._comment;\n      return this;\n    }\n    if (typeof value !== 'string') {\n      throw new Error('The value of a comment to be sent with this query must be a string.');\n    }\n    this._comment = value;\n    return this;\n  }\n}\nconst DefaultController = {\n  find(className, params, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n  aggregate(className, params, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n};\n_CoreManager.default.setParseQuery(ParseQuery);\n_CoreManager.default.setQueryController(DefaultController);\nvar _default = exports.default = ParseQuery;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_defineProperty2","_forEach","_indexOf","_keys","_slice","_map","_filter","_keys2","_concat","_includes","_sort","_splice","_promise","_find","_isArray","_entries","_CoreManager","_encode","_promiseUtils","_ParseError","_ParseGeoPoint","_ParseObject","_OfflineQuery","_LocalDatastoreUtils","quote","s","replace","_getClassNameFromQueries","queries","className","call","q","Error","handleSelectResult","data","select","serverDataMask","field","hasSubObjectSelect","hasOwnProperty","undefined","pathComponents","split","obj","serverMask","component","index","arr","length","serverData","getObjectStateController","getServerData","id","objectId","copyMissingDataWithMask","src","dest","mask","copyThisLevel","key","handleOfflineSort","a","b","sorts","order","operator","isDescending","substring","test","INVALID_KEY_NAME","field1","get","field2","remainingSorts","ParseQuery","constructor","objectClass","objClass","TypeError","_where","_watch","_include","_exclude","_count","_limit","_skip","_readPreference","_includeReadPreference","_subqueryReadPreference","_queriesLocalDatastore","_localDatastorePinName","_extraOptions","_xhrRequest","task","onchange","_comment","_orQuery","queryJSON","toJSON","where","$or","_andQuery","$and","_norQuery","$nor","_addCondition","condition","_regexStartWith","string","_handleOfflineQuery","params","_context","validateQuery","localDatastore","getLocalDatastore","objects","_serializeObjectsFromPinName","results","json","object","fromJSON","_localId","matchesQuery","keys","_context2","_toFullJSON","count","skip","limit","watch","join","include","excludeKeys","_select","_order","readPreference","includeReadPreference","subqueryReadPreference","_hint","hint","_explain","explain","comment","withJSON","_context3","query","options","equalTo","firstOptions","useMasterKey","sessionToken","context","first","then","response","errorObject","OBJECT_NOT_FOUND","reject","find","findOptions","_setRequestTask","controller","getQueryController","map","override","findAll","result","eachBatch","distinct","distinctOptions","aggregate","pipeline","aggregateOptions","unshift","$match","arguments","callback","batchSize","attr","val","v","conditionMap","cond","ascending","finished","previousResults","continueWhile","all","resolve","greaterThan","each","callbacksDone","array","push","reduce","initialValue","accumulator","filter","flag","_context4","_ref","k","doesNotExist","notEqualTo","_context5","_ref2","lessThan","lessThanOrEqualTo","greaterThanOrEqualTo","containedIn","notContainedIn","containedBy","values","containsAll","containsAllStartingWith","regexObject","$regex","exists","matches","regex","modifiers","ignoreCase","multiline","doesNotMatchQuery","matchesKeyInQuery","queryKey","doesNotMatchKeyInQuery","contains","fullText","fullOptions","$term","option","$language","$caseSensitive","$diacriticSensitive","$search","sortByTextScore","startsWith","prefix","endsWith","suffix","near","point","withinRadians","maxDistance","sorted","$centerSphere","longitude","latitude","withinMiles","withinKilometers","withinGeoBox","southwest","northeast","$box","withinPolygon","points","$polygon","polygonContains","$point","_len","Array","_key","addAscending","apply","_len2","_key2","_context6","descending","_len3","_key3","addDescending","_len4","_key4","_context7","_context8","n","withCount","includeCount","_len5","_key5","_context9","includeAll","_len6","_key6","_context10","exclude","_len7","_key7","_context11","_len8","_key8","_context12","subscribe","currentUser","getUserController","currentUserAsync","getSessionToken","liveQueryClient","getLiveQueryController","getDefaultLiveQueryClient","shouldOpen","open","subscription","subscribePromise","or","_len9","_key9","and","_len10","_key10","nor","_len11","_key11","fromNetwork","fromLocalDatastore","fromPinWithName","fromPin","DEFAULT_PIN","name","checkIfEnabled","cancel","abort","_aborted","requestTask","DefaultController","RESTController","getRESTController","request","setParseQuery","setQueryController","_default"],"sources":["/home/mavrik/Documents/github/pokemon/node_modules/parse/lib/browser/ParseQuery.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _filter = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\nvar _keys2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/keys\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\nfunction quote(s) {\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\nfunction _getClassNameFromQueries(queries) {\n  let className = null;\n  (0, _forEach.default)(queries).call(queries, q => {\n    if (!className) {\n      className = q.className;\n    }\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\nfunction handleSelectResult(data, select) {\n  const serverDataMask = {};\n  (0, _forEach.default)(select).call(select, field => {\n    const hasSubObjectSelect = (0, _indexOf.default)(field).call(field, '.') !== -1;\n    if (!hasSubObjectSelect && !data.hasOwnProperty(field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      const pathComponents = field.split('.');\n      let obj = data;\n      let serverMask = serverDataMask;\n      (0, _forEach.default)(pathComponents).call(pathComponents, (component, index, arr) => {\n        // add keys if the expected data is missing\n        if (obj && !obj.hasOwnProperty(component)) {\n          obj[component] = undefined;\n        }\n        if (obj && typeof obj === 'object') {\n          obj = obj[component];\n        }\n\n        //add this path component to the server mask so we can fill it in later if needed\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n  if ((0, _keys.default)(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n\n    const serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key) && !dest.hasOwnProperty(key)) {\n        dest[key] = src[key];\n      }\n    }\n  }\n  for (const key in mask) {\n    if (dest[key] !== undefined && dest[key] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[key], dest[key], mask[key], true);\n    }\n  }\n}\nfunction handleOfflineSort(a, b, sorts) {\n  let order = sorts[0];\n  const operator = (0, _slice.default)(order).call(order, 0, 1);\n  const isDescending = operator === '-';\n  if (isDescending) {\n    order = order.substring(1);\n  }\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${order}`);\n  }\n  const field1 = a.get(order);\n  const field2 = b.get(order);\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n  if (sorts.length > 1) {\n    const remainingSorts = (0, _slice.default)(sorts).call(sorts, 1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\nclass ParseQuery {\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  constructor(objectClass) {\n    /**\n     * @property {string} className\n     */\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_where\", void 0);\n    (0, _defineProperty2.default)(this, \"_watch\", void 0);\n    (0, _defineProperty2.default)(this, \"_include\", void 0);\n    (0, _defineProperty2.default)(this, \"_exclude\", void 0);\n    (0, _defineProperty2.default)(this, \"_select\", void 0);\n    (0, _defineProperty2.default)(this, \"_limit\", void 0);\n    (0, _defineProperty2.default)(this, \"_skip\", void 0);\n    (0, _defineProperty2.default)(this, \"_count\", void 0);\n    (0, _defineProperty2.default)(this, \"_order\", void 0);\n    (0, _defineProperty2.default)(this, \"_readPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_includeReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_subqueryReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_queriesLocalDatastore\", void 0);\n    (0, _defineProperty2.default)(this, \"_localDatastorePinName\", void 0);\n    (0, _defineProperty2.default)(this, \"_extraOptions\", void 0);\n    (0, _defineProperty2.default)(this, \"_hint\", void 0);\n    (0, _defineProperty2.default)(this, \"_explain\", void 0);\n    (0, _defineProperty2.default)(this, \"_xhrRequest\", void 0);\n    (0, _defineProperty2.default)(this, \"_comment\", void 0);\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      const objClass = objectClass;\n      if (typeof objClass.className === 'string') {\n        this.className = objClass.className;\n      } else {\n        const obj = new objClass();\n        this.className = obj.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n    this._where = {};\n    this._watch = [];\n    this._include = [];\n    this._exclude = [];\n    this._count = false;\n    this._limit = -1; // negative limit is not sent in the server request\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: () => {}\n    };\n    this._comment = null;\n  }\n\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _orQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$or = queryJSON;\n    return this;\n  }\n\n  /**\n   * Adds constraint that all of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _andQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$and = queryJSON;\n    return this;\n  }\n\n  /**\n   * Adds constraint that none of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _norQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$nor = queryJSON;\n    return this;\n  }\n\n  /**\n   * Helper for condition queries\n   *\n   * @param key\n   * @param condition\n   * @param value\n   * @returns {Parse.Query}\n   */\n  _addCondition(key, condition, value) {\n    if (!this._where[key] || typeof this._where[key] === 'string') {\n      this._where[key] = {};\n    }\n    this._where[key][condition] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n\n  /**\n   * Converts string for regular expression at the beginning\n   *\n   * @param string\n   * @returns {string}\n   */\n  _regexStartWith(string) {\n    return '^' + quote(string);\n  }\n  async _handleOfflineQuery(params) {\n    var _context;\n    _OfflineQuery.default.validateQuery(this);\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const objects = await localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n    let results = (0, _filter.default)(_context = (0, _map.default)(objects).call(objects, (json, index, arr) => {\n      const object = _ParseObject.default.fromJSON(json, false);\n      if (json._localId && !json.objectId) {\n        object._localId = json._localId;\n      }\n      if (!_OfflineQuery.default.matchesQuery(this.className, object, arr, this)) {\n        return null;\n      }\n      return object;\n    })).call(_context, object => object !== null);\n    if ((0, _keys2.default)(params)) {\n      let keys = (0, _keys2.default)(params).split(',');\n      keys = (0, _concat.default)(keys).call(keys, ['className', 'objectId', 'createdAt', 'updatedAt', 'ACL']);\n      results = (0, _map.default)(results).call(results, object => {\n        var _context2;\n        const json = object._toFullJSON();\n        (0, _forEach.default)(_context2 = (0, _keys.default)(json)).call(_context2, key => {\n          if (!(0, _includes.default)(keys).call(keys, key)) {\n            delete json[key];\n          }\n        });\n        return _ParseObject.default.fromJSON(json, false);\n      });\n    }\n    if (params.order) {\n      const sorts = params.order.split(',');\n      (0, _sort.default)(results).call(results, (a, b) => {\n        return handleOfflineSort(a, b, sorts);\n      });\n    }\n    let count; // count total before applying limit/skip\n    if (params.count) {\n      count = results.length; // total count from response\n    }\n    if (params.skip) {\n      if (params.skip >= results.length) {\n        results = [];\n      } else {\n        results = (0, _splice.default)(results).call(results, params.skip, results.length);\n      }\n    }\n    let limit = results.length;\n    if (params.limit !== 0 && params.limit < results.length) {\n      limit = params.limit;\n    }\n    results = (0, _splice.default)(results).call(results, 0, limit);\n    if (typeof count === 'number') {\n      return {\n        results,\n        count\n      };\n    }\n    return results;\n  }\n\n  /**\n   * Returns a JSON representation of this query.\n   *\n   * @returns {object} The JSON representation of the query.\n   */\n  toJSON() {\n    const params = {\n      where: this._where\n    };\n    if (this._watch.length) {\n      params.watch = this._watch.join(',');\n    }\n    if (this._include.length) {\n      params.include = this._include.join(',');\n    }\n    if (this._exclude.length) {\n      params.excludeKeys = this._exclude.join(',');\n    }\n    if (this._select) {\n      params.keys = this._select.join(',');\n    }\n    if (this._count) {\n      params.count = 1;\n    }\n    if (this._limit >= 0) {\n      params.limit = this._limit;\n    }\n    if (this._skip > 0) {\n      params.skip = this._skip;\n    }\n    if (this._order) {\n      params.order = this._order.join(',');\n    }\n    if (this._readPreference) {\n      params.readPreference = this._readPreference;\n    }\n    if (this._includeReadPreference) {\n      params.includeReadPreference = this._includeReadPreference;\n    }\n    if (this._subqueryReadPreference) {\n      params.subqueryReadPreference = this._subqueryReadPreference;\n    }\n    if (this._hint) {\n      params.hint = this._hint;\n    }\n    if (this._explain) {\n      params.explain = true;\n    }\n    if (this._comment) {\n      params.comment = this._comment;\n    }\n    for (const key in this._extraOptions) {\n      params[key] = this._extraOptions[key];\n    }\n    return params;\n  }\n\n  /**\n   * Return a query with conditions from json, can be useful to send query from server side to client\n   * Not static, all query conditions was set before calling this method will be deleted.\n   * For example on the server side we have\n   * var query = new Parse.Query(\"className\");\n   * query.equalTo(key: value);\n   * query.limit(100);\n   * ... (others queries)\n   * Create JSON representation of Query Object\n   * var jsonFromServer = query.fromJSON();\n   *\n   * On client side getting query:\n   * var query = new Parse.Query(\"className\");\n   * query.fromJSON(jsonFromServer);\n   *\n   * and continue to query...\n   * query.skip(100).find().then(...);\n   *\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withJSON(json) {\n    if (json.where) {\n      this._where = json.where;\n    }\n    if (json.watch) {\n      this._watch = json.watch.split(',');\n    }\n    if (json.include) {\n      this._include = json.include.split(',');\n    }\n    if ((0, _keys2.default)(json)) {\n      this._select = (0, _keys2.default)(json).split(',');\n    }\n    if (json.excludeKeys) {\n      this._exclude = json.excludeKeys.split(',');\n    }\n    if (json.count) {\n      this._count = json.count === 1;\n    }\n    if (json.limit) {\n      this._limit = json.limit;\n    }\n    if (json.skip) {\n      this._skip = json.skip;\n    }\n    if (json.order) {\n      this._order = json.order.split(',');\n    }\n    if (json.readPreference) {\n      this._readPreference = json.readPreference;\n    }\n    if (json.includeReadPreference) {\n      this._includeReadPreference = json.includeReadPreference;\n    }\n    if (json.subqueryReadPreference) {\n      this._subqueryReadPreference = json.subqueryReadPreference;\n    }\n    if (json.hint) {\n      this._hint = json.hint;\n    }\n    if (json.explain) {\n      this._explain = !!json.explain;\n    }\n    if (json.comment) {\n      this._comment = json.comment;\n    }\n    for (const key in json) {\n      if (json.hasOwnProperty(key)) {\n        var _context3;\n        if ((0, _indexOf.default)(_context3 = ['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain', 'comment']).call(_context3, key) === -1) {\n          this._extraOptions[key] = json[key];\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Static method to restore Parse.Query by json representation\n   * Internally calling Parse.Query.withJSON\n   *\n   * @param {string} className\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} new created query\n   */\n  static fromJSON(className, json) {\n    const query = new ParseQuery(className);\n    return query.withJSON(json);\n  }\n\n  /**\n   * Constructs a Parse.Object whose id is already known by fetching data from\n   * the server. Unlike the <code>first</code> method, it never returns undefined.\n   *\n   * @param {string} objectId The id of the object to be fetched.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  get(objectId, options) {\n    this.equalTo('objectId', objectId);\n    const firstOptions = {};\n    if (options && options.hasOwnProperty('useMasterKey')) {\n      firstOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options && options.hasOwnProperty('sessionToken')) {\n      firstOptions.sessionToken = options.sessionToken;\n    }\n    if (options && options.hasOwnProperty('context') && typeof options.context === 'object') {\n      firstOptions.context = options.context;\n    }\n    if (options && options.hasOwnProperty('json')) {\n      firstOptions.json = options.json;\n    }\n    return this.first(firstOptions).then(response => {\n      if (response) {\n        return response;\n      }\n      const errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n      return _promise.default.reject(errorObject);\n    });\n  }\n\n  /**\n   * Retrieves a list of ParseObjects that satisfy this query.\n   *\n   * @param {object} options Valid options\n   * are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n  find(options) {\n    options = options || {};\n    const findOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const select = this._select;\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(this.toJSON());\n    }\n    return (0, _find.default)(controller).call(controller, this.className, this.toJSON(), findOptions).then(response => {\n      // Return generic object when explain is used\n      if (this._explain) {\n        return response.results;\n      }\n      const results = response.results?.map(data => {\n        // In cases of relations, the server may send back a className\n        // on the top level of the payload\n        const override = response.className || this.className;\n        if (!data.className) {\n          data.className = override;\n        }\n\n        // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n        if (select) {\n          handleSelectResult(data, select);\n        }\n        if (options.json) {\n          return data;\n        } else {\n          return _ParseObject.default.fromJSON(data, !select);\n        }\n      });\n      const count = response.count;\n      if (typeof count === 'number') {\n        return {\n          results,\n          count\n        };\n      } else {\n        return results;\n      }\n    });\n  }\n\n  /**\n   * Retrieves a complete list of ParseObjects that satisfy this query.\n   * Using `eachBatch` under the hood to fetch all the valid objects.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n  async findAll(options) {\n    let result = [];\n    await this.eachBatch(objects => {\n      result = [...result, ...objects];\n    }, options);\n    return result;\n  }\n\n  /**\n   * Counts the number of objects that match this query.\n   *\n   * @param {object} options\n   * @param {boolean} [options.useMasterKey]\n   * @param {string} [options.sessionToken]\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the count when\n   * the query completes.\n   */\n  count(options) {\n    options = options || {};\n    const findOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = this.toJSON();\n    params.limit = 0;\n    params.count = 1;\n    return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(result => {\n      return result.count;\n    });\n  }\n\n  /**\n   * Executes a distinct query and returns unique values\n   *\n   * @param {string} key A field to find distinct values\n   * @param {object} options\n   * @param {string} [options.sessionToken] A valid session token, used for making a request on behalf of a specific user.\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n  distinct(key, options) {\n    options = options || {};\n    const distinctOptions = {\n      useMasterKey: true\n    };\n    if (options.hasOwnProperty('sessionToken')) {\n      distinctOptions.sessionToken = options.sessionToken;\n    }\n    this._setRequestTask(distinctOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = {\n      distinct: key,\n      where: this._where,\n      hint: this._hint\n    };\n    return controller.aggregate(this.className, params, distinctOptions).then(results => {\n      return results.results;\n    });\n  }\n\n  /**\n   * Executes an aggregate query and returns aggregate results\n   *\n   * @param {(Array|object)} pipeline Array or Object of stages to process query\n   * @param {object} options\n   * @param {string} [options.sessionToken] A valid session token, used for making a request on behalf of a specific user.\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n  aggregate(pipeline, options) {\n    options = options || {};\n    const aggregateOptions = {\n      useMasterKey: true\n    };\n    if (options.hasOwnProperty('sessionToken')) {\n      aggregateOptions.sessionToken = options.sessionToken;\n    }\n    this._setRequestTask(aggregateOptions);\n    const controller = _CoreManager.default.getQueryController();\n    if (!(0, _isArray.default)(pipeline) && typeof pipeline !== 'object') {\n      throw new Error('Invalid pipeline must be Array or Object');\n    }\n    if ((0, _keys.default)(this._where || {}).length) {\n      if (!(0, _isArray.default)(pipeline)) {\n        pipeline = [pipeline];\n      }\n      pipeline.unshift({\n        $match: this._where\n      });\n    }\n    const params = {\n      pipeline,\n      hint: this._hint,\n      explain: this._explain,\n      readPreference: this._readPreference\n    };\n    return controller.aggregate(this.className, params, aggregateOptions).then(results => {\n      return results.results;\n    });\n  }\n\n  /**\n   * Retrieves at most one Parse.Object that satisfies this query.\n   *\n   * Returns the object if there is one, otherwise undefined.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the object when\n   * the query completes.\n   */\n  first() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const findOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = this.toJSON();\n    params.limit = 1;\n    const select = this._select;\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(params).then(objects => {\n        if (!objects[0]) {\n          return undefined;\n        }\n        return objects[0];\n      });\n    }\n    return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(response => {\n      const objects = response.results;\n      if (!objects[0]) {\n        return undefined;\n      }\n      if (!objects[0].className) {\n        objects[0].className = this.className;\n      }\n\n      // Make sure the data object contains keys for all objects that\n      // have been requested with a select, so that our cached state\n      // updates correctly.\n      if (select) {\n        handleSelectResult(objects[0], select);\n      }\n      if (options.json) {\n        return objects[0];\n      } else {\n        return _ParseObject.default.fromJSON(objects[0], !select);\n      }\n    });\n  }\n\n  /**\n   * Iterates over objects matching a query, calling a callback for each batch.\n   * If the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are processed\n   * in an unspecified order. The query may not have any sort order, and may\n   * not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  eachBatch(callback, options) {\n    options = options || {};\n    if (this._order || this._skip || this._limit >= 0) {\n      return _promise.default.reject('Cannot iterate on a query with sort, skip, or limit.');\n    }\n    const query = new ParseQuery(this.className);\n    query._limit = options.batchSize || 100;\n    query._include = [...this._include];\n    query._exclude = [...this._exclude];\n    if (this._select) {\n      query._select = [...this._select];\n    }\n    query._hint = this._hint;\n    query._where = {};\n    for (const attr in this._where) {\n      const val = this._where[attr];\n      if ((0, _isArray.default)(val)) {\n        query._where[attr] = (0, _map.default)(val).call(val, v => {\n          return v;\n        });\n      } else if (val && typeof val === 'object') {\n        const conditionMap = {};\n        query._where[attr] = conditionMap;\n        for (const cond in val) {\n          conditionMap[cond] = val[cond];\n        }\n      } else {\n        query._where[attr] = val;\n      }\n    }\n    query.ascending('objectId');\n    const findOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      findOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      findOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      findOptions.context = options.context;\n    }\n    if (options.hasOwnProperty('json')) {\n      findOptions.json = options.json;\n    }\n    let finished = false;\n    let previousResults = [];\n    return (0, _promiseUtils.continueWhile)(() => {\n      return !finished;\n    }, async () => {\n      const [results] = await _promise.default.all([(0, _find.default)(query).call(query, findOptions), _promise.default.resolve(previousResults.length > 0 && callback(previousResults))]);\n      if (results.length >= query._limit) {\n        query.greaterThan('objectId', results[results.length - 1].id);\n        previousResults = results;\n      } else if (results.length > 0) {\n        await _promise.default.resolve(callback(results));\n        finished = true;\n      } else {\n        finished = true;\n      }\n    });\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  each(callback, options) {\n    return this.eachBatch(results => {\n      let callbacksDone = _promise.default.resolve();\n      (0, _forEach.default)(results).call(results, result => {\n        callbacksDone = callbacksDone.then(() => {\n          return callback(result);\n        });\n      });\n      return callbacksDone;\n    }, options);\n  }\n\n  /**\n   * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n   *\n   * @param {(string|object)} value String or Object of index that should be used when executing query\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  hint(value) {\n    if (typeof value === 'undefined') {\n      delete this._hint;\n    }\n    this._hint = value;\n    return this;\n  }\n\n  /**\n   * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n   *\n   * @param {boolean} explain Used to toggle the information on the query plan.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  explain() {\n    let explain = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof explain !== 'boolean') {\n      throw new Error('You can only set explain to a boolean value');\n    }\n    this._explain = explain;\n    return this;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query map was called upon.</li>\n   * </ul>\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async map(callback, options) {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return _promise.default.resolve(callback(object, index, this)).then(result => {\n        array.push(result);\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   * </ul>\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async reduce(callback, initialValue, options) {\n    let accumulator = initialValue;\n    let index = 0;\n    await this.each(object => {\n      // If no initial value was given, we take the first object from the query\n      // as the initial value and don't call the callback with it.\n      if (index === 0 && initialValue === undefined) {\n        accumulator = object;\n        index += 1;\n        return;\n      }\n      return _promise.default.resolve(callback(accumulator, object, index)).then(result => {\n        accumulator = result;\n        index += 1;\n      });\n    }, options);\n    if (index === 0 && initialValue === undefined) {\n      // Match Array.reduce behavior: \"Calling reduce() on an empty array\n      // without an initialValue will throw a TypeError\".\n      throw new TypeError('Reducing empty query result set with no initial value');\n    }\n    return accumulator;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query filter was called upon.</li>\n   * </ul>\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async filter(callback, options) {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return _promise.default.resolve(callback(object, index, this)).then(flag => {\n        if (flag) {\n          array.push(object);\n        }\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n\n  /* Query Conditions */\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that the Parse.Object must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  equalTo(key, value) {\n    if (key && typeof key === 'object') {\n      var _context4;\n      (0, _forEach.default)(_context4 = (0, _entries.default)(key)).call(_context4, _ref => {\n        let [k, val] = _ref;\n        return this.equalTo(k, val);\n      });\n      return this;\n    }\n    if (typeof value === 'undefined') {\n      return this.doesNotExist(key);\n    }\n    this._where[key] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be not equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that must not be equalled.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  notEqualTo(key, value) {\n    if (key && typeof key === 'object') {\n      var _context5;\n      (0, _forEach.default)(_context5 = (0, _entries.default)(key)).call(_context5, _ref2 => {\n        let [k, val] = _ref2;\n        return this.notEqualTo(k, val);\n      });\n      return this;\n    }\n    return this._addCondition(key, '$ne', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  lessThan(key, value) {\n    return this._addCondition(key, '$lt', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  greaterThan(key, value) {\n    return this._addCondition(key, '$gt', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  lessThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$lte', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  greaterThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$gte', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {Array<*>} value The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containedIn(key, value) {\n    return this._addCondition(key, '$in', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * not be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {Array<*>} value The values that will not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  notContainedIn(key, value) {\n    return this._addCondition(key, '$nin', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained by the provided list of values. Get objects where all array elements match.\n   *\n   * @param {string} key The key to check.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containedBy(key, values) {\n    return this._addCondition(key, '$containedBy', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containsAll(key, values) {\n    return this._addCondition(key, '$all', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values starting with given strings.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array<string>} values The string values that will match as starting string.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containsAllStartingWith(key, values) {\n    if (!(0, _isArray.default)(values)) {\n      values = [values];\n    }\n    const regexObject = (0, _map.default)(values).call(values, value => {\n      return {\n        $regex: this._regexStartWith(value)\n      };\n    });\n    return this.containsAll(key, regexObject);\n  }\n\n  /**\n   * Adds a constraint for finding objects that contain the given key.\n   *\n   * @param {string} key The key that should exist.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  exists(key) {\n    return this._addCondition(key, '$exists', true);\n  }\n\n  /**\n   * Adds a constraint for finding objects that do not contain a given key.\n   *\n   * @param {string} key The key that should not exist\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotExist(key) {\n    return this._addCondition(key, '$exists', false);\n  }\n\n  /**\n   * Adds a regular expression constraint for finding string values that match\n   * the provided regular expression.\n   * This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {RegExp | string} regex The regular expression pattern to match.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matches(key, regex, modifiers) {\n    this._addCondition(key, '$regex', regex);\n    if (!modifiers) {\n      modifiers = '';\n    }\n    if (typeof regex !== 'string') {\n      if (regex.ignoreCase) {\n        modifiers += 'i';\n      }\n      if (regex.multiline) {\n        modifiers += 'm';\n      }\n    }\n    if (modifiers.length) {\n      this._addCondition(key, '$options', modifiers);\n    }\n    return this;\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value matches a Parse.Query\n   * constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matchesQuery(key, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$inQuery', queryJSON);\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value not matches a\n   * Parse.Query constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotMatchQuery(key, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$notInQuery', queryJSON);\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value matches a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     matched.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matchesKeyInQuery(key, queryKey, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$select', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value not match a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     excluded.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotMatchKeyInQuery(key, queryKey, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$dontSelect', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string.  This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} substring The substring that the value must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  contains(key, substring) {\n    if (typeof substring !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this._addCondition(key, '$regex', quote(substring));\n  }\n\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n   *\n   * In order to sort you must use select and ascending ($score is required)\n   *  <pre>\n   *   query.fullText('field', 'term');\n   *   query.ascending('$score');\n   *   query.select('$score');\n   *  </pre>\n   *\n   * To retrieve the weight / rank\n   *  <pre>\n   *   object->get('score');\n   *  </pre>\n   *\n   * You can define optionals by providing an object as a third parameter\n   *  <pre>\n   *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n   *  </pre>\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} value The string to search\n   * @param {object} options (Optional)\n   * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n   * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n   * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fullText(key, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    options = options || {};\n    if (!key) {\n      throw new Error('A key is required.');\n    }\n    if (!value) {\n      throw new Error('A search term is required');\n    }\n    if (typeof value !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    const fullOptions = {};\n    fullOptions.$term = value;\n    for (const option in options) {\n      switch (option) {\n        case 'language':\n          fullOptions.$language = options[option];\n          break;\n        case 'caseSensitive':\n          fullOptions.$caseSensitive = options[option];\n          break;\n        case 'diacriticSensitive':\n          fullOptions.$diacriticSensitive = options[option];\n          break;\n        default:\n          throw new Error(`Unknown option: ${option}`);\n      }\n    }\n    return this._addCondition(key, '$text', {\n      $search: fullOptions\n    });\n  }\n\n  /**\n   * Method to sort the full text search by text score\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  sortByTextScore() {\n    this.ascending('$score');\n    this.select(['$score']);\n    return this;\n  }\n\n  /**\n   * Adds a constraint for finding string values that start with a provided\n   * string.  This query will use the backend index, so it will be fast even\n   * for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} prefix The substring that the value must start with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  startsWith(key, prefix, modifiers) {\n    if (typeof prefix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this.matches(key, this._regexStartWith(prefix), modifiers);\n  }\n\n  /**\n   * Adds a constraint for finding string values that end with a provided\n   * string.  This will be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} suffix The substring that the value must end with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  endsWith(key, suffix, modifiers) {\n    if (typeof suffix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this.matches(key, quote(suffix) + '$', modifiers);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  near(key, point) {\n    if (!(point instanceof _ParseGeoPoint.default)) {\n      // Try to cast it as a GeoPoint\n      point = new _ParseGeoPoint.default(point);\n    }\n    return this._addCondition(key, '$nearSphere', point);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in radians) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinRadians(key, point, maxDistance, sorted) {\n    if (sorted || sorted === undefined) {\n      this.near(key, point);\n      return this._addCondition(key, '$maxDistance', maxDistance);\n    } else {\n      return this._addCondition(key, '$geoWithin', {\n        $centerSphere: [[point.longitude, point.latitude], maxDistance]\n      });\n    }\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 3958.8 miles.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in miles) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinMiles(key, point, maxDistance, sorted) {\n    return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 6371.0 kilometers.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinKilometers(key, point, maxDistance, sorted) {\n    return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within a given rectangular geographic bounding\n   * box.\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} southwest\n   *     The lower-left inclusive corner of the box.\n   * @param {Parse.GeoPoint} northeast\n   *     The upper-right inclusive corner of the box.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinGeoBox(key, southwest, northeast) {\n    if (!(southwest instanceof _ParseGeoPoint.default)) {\n      southwest = new _ParseGeoPoint.default(southwest);\n    }\n    if (!(northeast instanceof _ParseGeoPoint.default)) {\n      northeast = new _ParseGeoPoint.default(northeast);\n    }\n    this._addCondition(key, '$within', {\n      $box: [southwest, northeast]\n    });\n    return this;\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within and on the bounds of a given polygon.\n   * Supports closed and open (last point is connected to first) paths\n   *\n   * Polygon must have at least 3 points\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Array} points Array of Coordinates / GeoPoints\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinPolygon(key, points) {\n    return this._addCondition(key, '$geoWithin', {\n      $polygon: points\n    });\n  }\n\n  /**\n   * Add a constraint to the query that requires a particular key's\n   * coordinates that contains a ParseGeoPoint\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} point\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  polygonContains(key, point) {\n    return this._addCondition(key, '$geoIntersects', {\n      $point: point\n    });\n  }\n\n  /* Query Orderings */\n\n  /**\n   * Sorts the results in ascending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  ascending() {\n    this._order = [];\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    return this.addAscending.apply(this, keys);\n  }\n\n  /**\n   * Sorts the results in ascending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  addAscending() {\n    if (!this._order) {\n      this._order = [];\n    }\n    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      keys[_key2] = arguments[_key2];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      var _context6;\n      if ((0, _isArray.default)(key)) {\n        key = key.join();\n      }\n      this._order = (0, _concat.default)(_context6 = this._order).call(_context6, key.replace(/\\s/g, '').split(','));\n    });\n    return this;\n  }\n\n  /**\n   * Sorts the results in descending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  descending() {\n    this._order = [];\n    for (var _len3 = arguments.length, keys = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      keys[_key3] = arguments[_key3];\n    }\n    return this.addDescending.apply(this, keys);\n  }\n\n  /**\n   * Sorts the results in descending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  addDescending() {\n    if (!this._order) {\n      this._order = [];\n    }\n    for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      keys[_key4] = arguments[_key4];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      var _context7, _context8;\n      if ((0, _isArray.default)(key)) {\n        key = key.join();\n      }\n      this._order = (0, _concat.default)(_context7 = this._order).call(_context7, (0, _map.default)(_context8 = key.replace(/\\s/g, '').split(',')).call(_context8, k => {\n        return '-' + k;\n      }));\n    });\n    return this;\n  }\n\n  /* Query Options */\n\n  /**\n   * Sets the number of results to skip before returning any results.\n   * This is useful for pagination.\n   * Default is to skip zero results.\n   *\n   * @param {number} n the number of results to skip.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  skip(n) {\n    if (typeof n !== 'number' || n < 0) {\n      throw new Error('You can only skip by a positive number');\n    }\n    this._skip = n;\n    return this;\n  }\n\n  /**\n   * Sets the limit of the number of results to return. The default limit is 100.\n   *\n   * @param {number} n the number of results to limit to.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  limit(n) {\n    if (typeof n !== 'number') {\n      throw new Error('You can only set the limit to a numeric value');\n    }\n    this._limit = n;\n    return this;\n  }\n\n  /**\n   * Sets the flag to include with response the total number of objects satisfying this query,\n   * despite limits/skip. Might be useful for pagination.\n   * Note that result of this query will be wrapped as an object with\n   * `results`: holding {ParseObject} array and `count`: integer holding total number\n   *\n   * @param {boolean} includeCount false - disable, true - enable.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withCount() {\n    let includeCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof includeCount !== 'boolean') {\n      throw new Error('You can only set withCount to a boolean value');\n    }\n    this._count = includeCount;\n    return this;\n  }\n  /**\n   * Includes nested Parse.Objects for the provided key.  You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * You can include all nested Parse.Objects by passing in '*'.\n   * Requires Parse Server 3.0.0+\n   * <pre>query.include('*');</pre>\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  include() {\n    for (var _len5 = arguments.length, keys = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      keys[_key5] = arguments[_key5];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context9;\n        this._include = (0, _concat.default)(_context9 = this._include).call(_context9, key);\n      } else {\n        this._include.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Includes all nested Parse.Objects one level deep.\n   *\n   * Requires Parse Server 3.0.0+\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  includeAll() {\n    return this.include('*');\n  }\n\n  /**\n   * Restricts the fields of the returned Parse.Objects to include only the\n   * provided keys.  If this is called multiple times, then all of the keys\n   * specified in each of the calls will be included.\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  select() {\n    if (!this._select) {\n      this._select = [];\n    }\n    for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      keys[_key6] = arguments[_key6];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context10;\n        this._select = (0, _concat.default)(_context10 = this._select).call(_context10, key);\n      } else {\n        this._select.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Restricts the fields of the returned Parse.Objects to all keys except the\n   * provided keys. Exclude takes precedence over select and include.\n   *\n   * Requires Parse Server 3.6.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  exclude() {\n    for (var _len7 = arguments.length, keys = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      keys[_key7] = arguments[_key7];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context11;\n        this._exclude = (0, _concat.default)(_context11 = this._exclude).call(_context11, key);\n      } else {\n        this._exclude.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Restricts live query to trigger only for watched fields.\n   *\n   * Requires Parse Server 6.0.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to watch.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  watch() {\n    for (var _len8 = arguments.length, keys = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      keys[_key8] = arguments[_key8];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context12;\n        this._watch = (0, _concat.default)(_context12 = this._watch).call(_context12, key);\n      } else {\n        this._watch.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Changes the read preference that the backend will use when performing the query to the database.\n   *\n   * @param {string} readPreference The read preference for the main query.\n   * @param {string} includeReadPreference The read preference for the queries to include pointers.\n   * @param {string} subqueryReadPreference The read preference for the sub queries.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  readPreference(readPreference, includeReadPreference, subqueryReadPreference) {\n    this._readPreference = readPreference;\n    this._includeReadPreference = includeReadPreference || null;\n    this._subqueryReadPreference = subqueryReadPreference || null;\n    return this;\n  }\n\n  /**\n   * Subscribe this query to get liveQuery updates\n   *\n   * @param {string} sessionToken (optional) Defaults to the currentUser\n   * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n   * which can be used to get liveQuery updates.\n   */\n  async subscribe(sessionToken) {\n    const currentUser = await _CoreManager.default.getUserController().currentUserAsync();\n    if (!sessionToken) {\n      sessionToken = currentUser ? currentUser.getSessionToken() || undefined : undefined;\n    }\n    const liveQueryClient = await _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n    if (liveQueryClient.shouldOpen()) {\n      liveQueryClient.open();\n    }\n    const subscription = liveQueryClient.subscribe(this, sessionToken);\n    return subscription.subscribePromise.then(() => {\n      return subscription;\n    });\n  }\n\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to OR.\n   * @static\n   * @returns {Parse.Query} The query that is the OR of the passed in queries.\n   */\n  static or() {\n    for (var _len9 = arguments.length, queries = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      queries[_key9] = arguments[_key9];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._orQuery(queries);\n    return query;\n  }\n\n  /**\n   * Constructs a Parse.Query that is the AND of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an and of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to AND.\n   * @static\n   * @returns {Parse.Query} The query that is the AND of the passed in queries.\n   */\n  static and() {\n    for (var _len10 = arguments.length, queries = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      queries[_key10] = arguments[_key10];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._andQuery(queries);\n    return query;\n  }\n\n  /**\n   * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n   * example:\n   * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is a nor of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to NOR.\n   * @static\n   * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n   */\n  static nor() {\n    for (var _len11 = arguments.length, queries = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      queries[_key11] = arguments[_key11];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._norQuery(queries);\n    return query;\n  }\n\n  /**\n   * Change the source of this query to the server.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromNetwork() {\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    return this;\n  }\n\n  /**\n   * Changes the source of this query to all pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromLocalDatastore() {\n    return this.fromPinWithName(null);\n  }\n\n  /**\n   * Changes the source of this query to the default group of pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromPin() {\n    return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n\n  /**\n   * Changes the source of this query to a specific group of pinned objects.\n   *\n   * @param {string} name The name of query source.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromPinWithName(name) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (localDatastore.checkIfEnabled()) {\n      this._queriesLocalDatastore = true;\n      this._localDatastorePinName = name;\n    }\n    return this;\n  }\n\n  /**\n   * Cancels the current network request (if any is running).\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  cancel() {\n    if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n      this._xhrRequest.task._aborted = true;\n      this._xhrRequest.task.abort();\n      this._xhrRequest.task = null;\n      this._xhrRequest.onchange = () => {};\n      return this;\n    }\n    this._xhrRequest.onchange = () => this.cancel();\n    return this;\n  }\n  _setRequestTask(options) {\n    options.requestTask = task => {\n      this._xhrRequest.task = task;\n      this._xhrRequest.onchange();\n    };\n  }\n\n  /**\n   * Sets a comment to the query so that the query\n   * can be identified when using a the profiler for MongoDB.\n   *\n   * @param {string} value a comment can make your profile data easier to interpret and trace.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  comment(value) {\n    if (value == null) {\n      delete this._comment;\n      return this;\n    }\n    if (typeof value !== 'string') {\n      throw new Error('The value of a comment to be sent with this query must be a string.');\n    }\n    this._comment = value;\n    return this;\n  }\n}\nconst DefaultController = {\n  find(className, params, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n  aggregate(className, params, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n};\n_CoreManager.default.setParseQuery(ParseQuery);\n_CoreManager.default.setQueryController(DefaultController);\nvar _default = exports.default = ParseQuery;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}