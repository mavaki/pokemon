{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _defineProperty = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\nconst CURRENT_USER_KEY = 'currentUser';\nlet canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nlet currentUserCacheMatchesDisk = false;\nlet currentUserCache = null;\nconst authProviders = {};\n\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n *\n * @alias Parse.User\n * @augments Parse.Object\n */\nclass ParseUser extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the user.\n   */\n  constructor(attributes) {\n    super('_User');\n    if (attributes && typeof attributes === 'object') {\n      if (!this.set(attributes || {})) {\n        throw new Error(\"Can't create an invalid Parse User\");\n      }\n    }\n  }\n\n  /**\n   * Request a revocable session token to replace the older style of token.\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n  _upgradeToRevocableSession(options) {\n    options = options || {};\n    const upgradeOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      upgradeOptions.useMasterKey = options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.upgradeToRevocableSession(this, upgradeOptions);\n  }\n\n  /**\n   * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling\n   * your users to sign up or log into your application using their existing identities.\n   * Since 2.9.0\n   *\n   * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options\n   * @param {object} [options.authData] AuthData to link with\n   * <ul>\n   *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}\n   *   <li>If provider is AuthProvider, options is saveOpts\n   * </ul>\n   * @param {object} saveOpts useMasterKey / sessionToken\n   * @returns {Promise} A promise that is fulfilled with the user is linked\n   */\n  linkWith(provider, options) {\n    let saveOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || '';\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n      if (authProviders[provider]) {\n        provider = authProviders[provider];\n      } else {\n        const authProvider = {\n          restoreAuthentication() {\n            return true;\n          },\n          getAuthType() {\n            return authType;\n          }\n        };\n        authProviders[authProvider.getAuthType()] = authProvider;\n        provider = authProvider;\n      }\n    } else {\n      authType = provider.getAuthType();\n    }\n    if (options && options.hasOwnProperty('authData')) {\n      const authData = this.get('authData') || {};\n      if (typeof authData !== 'object') {\n        throw new Error('Invalid type: authData field should be an object');\n      }\n      authData[authType] = options.authData;\n      const oldAnonymousData = authData.anonymous;\n      this.stripAnonymity();\n      const controller = _CoreManager.default.getUserController();\n      return controller.linkWith(this, authData, saveOpts).catch(e => {\n        delete authData[authType];\n        this.restoreAnonimity(oldAnonymousData);\n        throw e;\n      });\n    } else {\n      return new _promise.default((resolve, reject) => {\n        provider.authenticate({\n          success: (provider, result) => {\n            const opts = {};\n            opts.authData = result;\n            this.linkWith(provider, opts, saveOpts).then(() => {\n              resolve(this);\n            }, error => {\n              reject(error);\n            });\n          },\n          error: (provider, error) => {\n            reject(error);\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   * @returns {Promise}\n   */\n  _linkWith(provider, options) {\n    let saveOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.linkWith(provider, options, saveOpts);\n  }\n\n  /**\n   * Synchronizes auth data for a provider (e.g. puts the access token in the\n   * right place to be used by the Facebook SDK).\n   *\n   * @param provider\n   */\n  _synchronizeAuthData(provider) {\n    if (!this.isCurrent() || !provider) {\n      return;\n    }\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n      provider = authProviders[authType];\n    } else {\n      authType = provider.getAuthType();\n    }\n    const authData = this.get('authData');\n    if (!provider || !authData || typeof authData !== 'object') {\n      return;\n    }\n    const success = provider.restoreAuthentication(authData[authType]);\n    if (!success) {\n      this._unlinkFrom(provider);\n    }\n  }\n\n  /**\n   * Synchronizes authData for all providers.\n   */\n  _synchronizeAllAuthData() {\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      this._synchronizeAuthData(key);\n    }\n  }\n\n  /**\n   * Removes null values from authData (which exist temporarily for unlinking)\n   */\n  _cleanupAuthData() {\n    if (!this.isCurrent()) {\n      return;\n    }\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      if (!authData[key]) {\n        delete authData[key];\n      }\n    }\n  }\n\n  /**\n   * Unlinks a user from a service.\n   *\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options MasterKey / SessionToken\n   * @returns {Promise} A promise that is fulfilled when the unlinking\n   *     finishes.\n   */\n  _unlinkFrom(provider, options) {\n    return this.linkWith(provider, {\n      authData: null\n    }, options).then(() => {\n      this._synchronizeAuthData(provider);\n      return _promise.default.resolve(this);\n    });\n  }\n\n  /**\n   * Checks whether a user is linked to a service.\n   *\n   * @param {object} provider service to link to\n   * @returns {boolean} true if link was successful\n   */\n  _isLinked(provider) {\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n    } else {\n      authType = provider.getAuthType();\n    }\n    const authData = this.get('authData') || {};\n    if (typeof authData !== 'object') {\n      return false;\n    }\n    return !!authData[authType];\n  }\n\n  /**\n   * Deauthenticates all providers.\n   */\n  _logOutWithAll() {\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      this._logOutWith(key);\n    }\n  }\n\n  /**\n   * Deauthenticates a single provider (e.g. removing access tokens from the\n   * Facebook SDK).\n   *\n   * @param {object} provider service to logout of\n   */\n  _logOutWith(provider) {\n    if (!this.isCurrent()) {\n      return;\n    }\n    if (typeof provider === 'string') {\n      provider = authProviders[provider];\n    }\n    if (provider && provider.deauthenticate) {\n      provider.deauthenticate();\n    }\n  }\n\n  /**\n   * Class instance method used to maintain specific keys when a fetch occurs.\n   * Used to ensure that the session token is not lost.\n   *\n   * @returns {object} sessionToken\n   */\n  _preserveFieldsOnFetch() {\n    return {\n      sessionToken: this.get('sessionToken')\n    };\n  }\n\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {boolean} true if user is cached on disk\n   */\n  isCurrent() {\n    const current = ParseUser.current();\n    return !!current && current.id === this.id;\n  }\n\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {Promise<boolean>} true if user is cached on disk\n   */\n  async isCurrentAsync() {\n    const current = await ParseUser.currentAsync();\n    return !!current && current.id === this.id;\n  }\n  stripAnonymity() {\n    const authData = this.get('authData');\n    if (authData && typeof authData === 'object' && authData.hasOwnProperty('anonymous')) {\n      // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n      authData.anonymous = null;\n    }\n  }\n  restoreAnonimity(anonymousData) {\n    if (anonymousData) {\n      const authData = this.get('authData');\n      authData.anonymous = anonymousData;\n    }\n  }\n\n  /**\n   * Returns get(\"username\").\n   *\n   * @returns {string}\n   */\n  getUsername() {\n    const username = this.get('username');\n    if (username == null || typeof username === 'string') {\n      return username;\n    }\n    return '';\n  }\n\n  /**\n   * Calls set(\"username\", username, options) and returns the result.\n   *\n   * @param {string} username\n   */\n  setUsername(username) {\n    this.stripAnonymity();\n    this.set('username', username);\n  }\n\n  /**\n   * Calls set(\"password\", password, options) and returns the result.\n   *\n   * @param {string} password User's Password\n   */\n  setPassword(password) {\n    this.set('password', password);\n  }\n\n  /**\n   * Returns get(\"email\").\n   *\n   * @returns {string} User's Email\n   */\n  getEmail() {\n    const email = this.get('email');\n    if (email == null || typeof email === 'string') {\n      return email;\n    }\n    return '';\n  }\n\n  /**\n   * Calls set(\"email\", email) and returns the result.\n   *\n   * @param {string} email\n   * @returns {boolean}\n   */\n  setEmail(email) {\n    return this.set('email', email);\n  }\n\n  /**\n   * Returns the session token for this user, if the user has been logged in,\n   * or if it is the result of a query with the master key. Otherwise, returns\n   * undefined.\n   *\n   * @returns {string} the session token, or undefined\n   */\n  getSessionToken() {\n    const token = this.get('sessionToken');\n    if (token == null || typeof token === 'string') {\n      return token;\n    }\n    return '';\n  }\n\n  /**\n   * Checks whether this user is the current user and has been authenticated.\n   *\n   * @returns {boolean} whether this user is the current user and is logged in.\n   */\n  authenticated() {\n    const current = ParseUser.current();\n    return !!this.get('sessionToken') && !!current && current.id === this.id;\n  }\n\n  /**\n   * Signs up a new user. You should call this instead of save for\n   * new Parse.Users. This will create a new Parse.User on the server, and\n   * also persist the session on disk so that you can access the user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling signUp.</p>\n   *\n   * @param {object} attrs Extra fields to set on the new user, or null.\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled when the signup\n   *     finishes.\n   */\n  signUp(attrs, options) {\n    options = options || {};\n    const signupOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      signupOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('installationId')) {\n      signupOptions.installationId = options.installationId;\n    }\n    if (options.hasOwnProperty('context') && Object.prototype.toString.call(options.context) === '[object Object]') {\n      signupOptions.context = options.context;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.signUp(this, attrs, signupOptions);\n  }\n\n  /**\n   * Logs in a Parse.User. On success, this saves the session to disk,\n   * so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling logIn.</p>\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login is complete.\n   */\n  logIn() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options = options || {};\n    const loginOptions = {\n      usePost: true\n    };\n    if (options.hasOwnProperty('useMasterKey')) {\n      loginOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('installationId')) {\n      loginOptions.installationId = options.installationId;\n    }\n    if (options.hasOwnProperty('usePost')) {\n      loginOptions.usePost = options.usePost;\n    }\n    if (options.hasOwnProperty('context') && Object.prototype.toString.call(options.context) === '[object Object]') {\n      loginOptions.context = options.context;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.logIn(this, loginOptions);\n  }\n\n  /**\n   * Wrap the default save behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n  async save() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    await super.save.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default destroy behavior with functionality that logs out\n   * the current user when it is destroyed\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async destroy() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    await super.destroy.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().removeUserFromDisk();\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default fetch behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async fetch() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    await super.fetch.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default fetchWithInclude behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async fetchWithInclude() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    await super.fetchWithInclude.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} password The password to be verified.\n   * @param {object} options The options.\n   * @param {boolean} [options.ignoreEmailVerification] Set to `true` to bypass email verification and verify\n   * the password regardless of whether the email has been verified. This requires the master key.\n   * @returns {Promise} A promise that is fulfilled with a user when the password is correct.\n   */\n  verifyPassword(password, options) {\n    const username = this.getUsername() || '';\n    return ParseUser.verifyPassword(username, password, options);\n  }\n  static readOnlyAttributes() {\n    return ['sessionToken'];\n  }\n\n  /**\n   * Adds functionality to the existing Parse.User class.\n   *\n   * @param {object} protoProps A set of properties to add to the prototype\n   * @param {object} classProps A set of static properties to add to the class\n   * @static\n   * @returns {Parse.User} The newly extended Parse.User class\n   */\n  static extend(protoProps, classProps) {\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty.default)(ParseUser.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty.default)(ParseUser, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    return ParseUser;\n  }\n\n  /**\n   * Retrieves the currently logged in ParseUser with a valid session,\n   * either from memory or localStorage, if necessary.\n   *\n   * @static\n   * @returns {Parse.Object} The currently logged in Parse.User.\n   */\n  static current() {\n    if (!canUseCurrentUser) {\n      return null;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.currentUser();\n  }\n\n  /**\n   * Retrieves the currently logged in ParseUser from asynchronous Storage.\n   *\n   * @static\n   * @returns {Promise} A Promise that is resolved with the currently\n   *   logged in Parse User\n   */\n  static currentAsync() {\n    if (!canUseCurrentUser) {\n      return _promise.default.resolve(null);\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.currentUserAsync();\n  }\n\n  /**\n   * Signs up a new user with a username (or email) and password.\n   * This will create a new Parse.User on the server, and also persist the\n   * session in localStorage so that you can access the user using\n   * {@link #current}.\n   *\n   * @param {string} username The username (or email) to sign up with.\n   * @param {string} password The password to sign up with.\n   * @param {object} attrs Extra fields to set on the new user.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the signup completes.\n   */\n  static signUp(username, password, attrs, options) {\n    attrs = attrs || {};\n    attrs.username = username;\n    attrs.password = password;\n    const user = new this(attrs);\n    return user.signUp({}, options);\n  }\n\n  /**\n   * Logs in a user with a username (or email) and password. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static logIn(username, password, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    } else if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    const user = new this();\n    user._finishFetch({\n      username: username,\n      password: password\n    });\n    return user.logIn(options);\n  }\n\n  /**\n   * Logs in a user with a username (or email) and password, and authData. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} authData The authData to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static logInWithAdditionalAuth(username, password, authData, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n    if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    if (Object.prototype.toString.call(authData) !== '[object Object]') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Auth must be an object.'));\n    }\n    const user = new this();\n    user._finishFetch({\n      username: username,\n      password: password,\n      authData\n    });\n    return user.logIn(options);\n  }\n\n  /**\n   * Logs in a user with an objectId. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} userId The objectId for the user.\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static loginAs(userId) {\n    if (!userId) {\n      throw new _ParseError.default(_ParseError.default.USERNAME_MISSING, 'Cannot log in as user with an empty user id');\n    }\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.loginAs(user, userId);\n  }\n\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} sessionToken The sessionToken to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static become(sessionToken, options) {\n    if (!canUseCurrentUser) {\n      throw new Error('It is not memory-safe to become a user in a server environment');\n    }\n    options = options || {};\n    const becomeOptions = {\n      sessionToken: sessionToken\n    };\n    if (options.hasOwnProperty('useMasterKey')) {\n      becomeOptions.useMasterKey = options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.become(user, becomeOptions);\n  }\n\n  /**\n   * Retrieves a user with a session token.\n   *\n   * @param {string} sessionToken The sessionToken to get user with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user is fetched.\n   */\n  static me(sessionToken) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const controller = _CoreManager.default.getUserController();\n    const meOptions = {\n      sessionToken: sessionToken\n    };\n    if (options.useMasterKey) {\n      meOptions.useMasterKey = options.useMasterKey;\n    }\n    const user = new this();\n    return controller.me(user, meOptions);\n  }\n\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>. If there is no session token the user will not logged in.\n   *\n   * @param {object} userJSON The JSON map of the User's data\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static hydrate(userJSON) {\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.hydrate(user, userJSON);\n  }\n\n  /**\n   * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   *\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @static\n   * @returns {Promise}\n   */\n  static logInWith(provider, options, saveOpts) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n\n  /**\n   * Logs out the currently logged in user session. This will remove the\n   * session from disk, log out of linked services, and future calls to\n   * <code>current</code> will return <code>null</code>.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the session is\n   *   destroyed on the server.\n   */\n  static logOut() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const controller = _CoreManager.default.getUserController();\n    return controller.logOut(options);\n  }\n\n  /**\n   * Requests a password reset email to be sent to the specified email address\n   * associated with the user account. This email allows the user to securely\n   * reset their password on the Parse site.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n  static requestPasswordReset(email, options) {\n    options = options || {};\n    const requestOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.requestPasswordReset(email, requestOptions);\n  }\n\n  /**\n   * Request an email verification.\n   *\n   * @param {string} email The email address associated with the user that\n   *     needs to verify their email.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n  static requestEmailVerification(email, options) {\n    options = options || {};\n    const requestOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.requestEmailVerification(email, requestOptions);\n  }\n\n  /**\n   * Verify whether a given password is the password of the current user.\n   * @static\n   *\n   * @param {string} username  The username of the user whose password should be verified.\n   * @param {string} password The password to be verified.\n   * @param {object} options The options.\n   * @param {boolean} [options.ignoreEmailVerification] Set to `true` to bypass email verification and verify\n   * the password regardless of whether the email has been verified. This requires the master key.\n   * @returns {Promise} A promise that is fulfilled with a user when the password is correct.\n   */\n  static verifyPassword(username, password, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n    if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.verifyPassword(username, password, options || {});\n  }\n\n  /**\n   * Allow someone to define a custom User class without className\n   * being rewritten to _User. The default behavior is to rewrite\n   * User to _User for legacy reasons. This allows developers to\n   * override that behavior.\n   *\n   * @param {boolean} isAllowed Whether or not to allow custom User class\n   * @static\n   */\n  static allowCustomUserClass(isAllowed) {\n    _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n  }\n\n  /**\n   * Allows a legacy application to start using revocable sessions. If the\n   * current session token is not revocable, a request will be made for a new,\n   * revocable session.\n   * It is not necessary to call this method from cloud code unless you are\n   * handling user signup or login from the server side. In a cloud code call,\n   * this function will not attempt to upgrade the current token.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the process has\n   *   completed. If a replacement session token is requested, the promise\n   *   will be resolved after a new token has been fetched.\n   */\n  static enableRevocableSession(options) {\n    options = options || {};\n    _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n    if (canUseCurrentUser) {\n      const current = ParseUser.current();\n      if (current) {\n        return current._upgradeToRevocableSession(options);\n      }\n    }\n    return _promise.default.resolve();\n  }\n\n  /**\n   * Enables the use of become or the current user in a server\n   * environment. These features are disabled by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n  static enableUnsafeCurrentUser() {\n    canUseCurrentUser = true;\n  }\n\n  /**\n   * Disables the use of become or the current user in any environment.\n   * These features are disabled on servers by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n  static disableUnsafeCurrentUser() {\n    canUseCurrentUser = false;\n  }\n\n  /**\n   * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider\n   * is automatically created for you.\n   *\n   * For advanced authentication, you can register an Auth provider to\n   * implement custom authentication, deauthentication.\n   *\n   * @param provider\n   * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}\n   * @static\n   */\n  static _registerAuthenticationProvider(provider) {\n    authProviders[provider.getAuthType()] = provider;\n    // Synchronize the current user with the auth provider.\n    ParseUser.currentAsync().then(current => {\n      if (current) {\n        current._synchronizeAuthData(provider.getAuthType());\n      }\n    });\n  }\n\n  /**\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}\n   * @static\n   * @returns {Promise}\n   */\n  static _logInWith(provider, options, saveOpts) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n  static _clearCache() {\n    currentUserCache = null;\n    currentUserCacheMatchesDisk = false;\n  }\n  static _setCurrentUserCache(user) {\n    currentUserCache = user;\n  }\n}\n_ParseObject.default.registerSubclass('_User', ParseUser);\nconst DefaultController = {\n  updateUserOnDisk(user) {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    const json = user.toJSON();\n    delete json.password;\n    json.className = '_User';\n    let userData = (0, _stringify.default)(json);\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n      userData = crypto.encrypt(json, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n    return _Storage.default.setItemAsync(path, userData).then(() => {\n      return user;\n    });\n  },\n  removeUserFromDisk() {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n  setCurrentUser(user) {\n    currentUserCache = user;\n    user._cleanupAuthData();\n    user._synchronizeAllAuthData();\n    return DefaultController.updateUserOnDisk(user);\n  },\n  currentUser() {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    let userData = _Storage.default.getItem(path);\n    currentUserCacheMatchesDisk = true;\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n      userData = crypto.decrypt(userData, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n    userData = JSON.parse(userData);\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n      delete userData._id;\n    }\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n    const current = _ParseObject.default.fromJSON(userData);\n    currentUserCache = current;\n    current._synchronizeAllAuthData();\n    return current;\n  },\n  currentUserAsync() {\n    if (currentUserCache) {\n      return _promise.default.resolve(currentUserCache);\n    }\n    if (currentUserCacheMatchesDisk) {\n      return _promise.default.resolve(null);\n    }\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    return _Storage.default.getItemAsync(path).then(userData => {\n      currentUserCacheMatchesDisk = true;\n      if (!userData) {\n        currentUserCache = null;\n        return _promise.default.resolve(null);\n      }\n      if (_CoreManager.default.get('ENCRYPTED_USER')) {\n        const crypto = _CoreManager.default.getCryptoController();\n        userData = crypto.decrypt(userData.toString(), _CoreManager.default.get('ENCRYPTED_KEY'));\n      }\n      userData = JSON.parse(userData);\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n        delete userData._id;\n      }\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n      const current = _ParseObject.default.fromJSON(userData);\n      currentUserCache = current;\n      current._synchronizeAllAuthData();\n      return _promise.default.resolve(current);\n    });\n  },\n  signUp(user, attrs, options) {\n    const username = attrs && attrs.username || user.get('username');\n    const password = attrs && attrs.password || user.get('password');\n    if (!username || !username.length) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty username.'));\n    }\n    if (!password || !password.length) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n    return user.save(attrs, options).then(() => {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n      return user;\n    });\n  },\n  logIn(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    const stateController = _CoreManager.default.getObjectStateController();\n    const auth = {\n      username: user.get('username'),\n      password: user.get('password'),\n      authData: user.get('authData')\n    };\n    return RESTController.request(options.usePost ? 'POST' : 'GET', 'login', auth, options).then(response => {\n      user._migrateId(response.objectId);\n      user._setExisted(true);\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n      user._finishFetch(response);\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return _promise.default.resolve(user);\n      }\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  loginAs(user, userId) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'loginAs', {\n      userId\n    }, {\n      useMasterKey: true\n    }).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      if (!canUseCurrentUser) {\n        return _promise.default.resolve(user);\n      }\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  become(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  hydrate(user, userJSON) {\n    user._finishFetch(userJSON);\n    user._setExisted(true);\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    } else {\n      return _promise.default.resolve(user);\n    }\n  },\n  me(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      return user;\n    });\n  },\n  logOut(options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    if (options.sessionToken) {\n      return RESTController.request('POST', 'logout', {}, options);\n    }\n    return DefaultController.currentUserAsync().then(currentUser => {\n      const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n      let promise = _Storage.default.removeItemAsync(path);\n      if (currentUser !== null) {\n        const currentSession = currentUser.getSessionToken();\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(() => {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n        currentUser._logOutWithAll();\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n      }\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n  requestPasswordReset(email, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email: email\n    }, options);\n  },\n  async upgradeToRevocableSession(user, options) {\n    const token = user.getSessionToken();\n    if (!token) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n    options.sessionToken = token;\n    const RESTController = _CoreManager.default.getRESTController();\n    const result = await RESTController.request('POST', 'upgradeToRevocableSession', {}, options);\n    user._finishFetch({\n      sessionToken: result?.sessionToken || ''\n    });\n    const current = await user.isCurrentAsync();\n    if (current) {\n      return DefaultController.setCurrentUser(user);\n    }\n    return _promise.default.resolve(user);\n  },\n  linkWith(user, authData, options) {\n    return user.save({\n      authData\n    }, options).then(() => {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n      return user;\n    });\n  },\n  verifyPassword(username, password, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    const data = {\n      username,\n      password,\n      ...(options.ignoreEmailVerification !== undefined && {\n        ignoreEmailVerification: options.ignoreEmailVerification\n      })\n    };\n    return RESTController.request('GET', 'verifyPassword', data, options);\n  },\n  requestEmailVerification(email, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'verificationEmailRequest', {\n      email: email\n    }, options);\n  }\n};\n_CoreManager.default.setParseUser(ParseUser);\n_CoreManager.default.setUserController(DefaultController);\nvar _default = exports.default = ParseUser;","map":{"version":3,"names":["_Object$defineProperty2","require","_interopRequireDefault","exports","value","default","_promise","_defineProperty","_stringify","_CoreManager","_isRevocableSession","_ParseError","_ParseObject","_Storage","CURRENT_USER_KEY","canUseCurrentUser","get","currentUserCacheMatchesDisk","currentUserCache","authProviders","ParseUser","constructor","attributes","set","Error","_upgradeToRevocableSession","options","upgradeOptions","hasOwnProperty","useMasterKey","controller","getUserController","upgradeToRevocableSession","linkWith","provider","saveOpts","arguments","length","undefined","sessionToken","getSessionToken","authType","authProvider","restoreAuthentication","getAuthType","authData","oldAnonymousData","anonymous","stripAnonymity","catch","e","restoreAnonimity","resolve","reject","authenticate","success","result","opts","then","error","_linkWith","_synchronizeAuthData","isCurrent","_unlinkFrom","_synchronizeAllAuthData","key","_cleanupAuthData","_isLinked","_logOutWithAll","_logOutWith","deauthenticate","_preserveFieldsOnFetch","current","id","isCurrentAsync","currentAsync","anonymousData","getUsername","username","setUsername","setPassword","password","getEmail","email","setEmail","token","authenticated","signUp","attrs","signupOptions","installationId","Object","prototype","toString","call","context","logIn","loginOptions","usePost","save","_len","args","Array","_key","apply","updateUserOnDisk","destroy","_len2","_key2","removeUserFromDisk","fetch","_len3","_key3","fetchWithInclude","_len4","_key4","verifyPassword","readOnlyAttributes","extend","protoProps","classProps","prop","enumerable","writable","configurable","currentUser","currentUserAsync","user","OTHER_CAUSE","_finishFetch","logInWithAdditionalAuth","loginAs","userId","USERNAME_MISSING","become","becomeOptions","me","meOptions","hydrate","userJSON","logInWith","logOut","requestPasswordReset","requestOptions","requestEmailVerification","allowCustomUserClass","isAllowed","enableRevocableSession","enableUnsafeCurrentUser","disableUnsafeCurrentUser","_registerAuthenticationProvider","_logInWith","_clearCache","_setCurrentUserCache","registerSubclass","DefaultController","path","generatePath","json","toJSON","className","userData","crypto","getCryptoController","encrypt","setItemAsync","removeItemAsync","setCurrentUser","async","getItem","decrypt","JSON","parse","_id","objectId","_sessionToken","fromJSON","getItemAsync","RESTController","getRESTController","stateController","getObjectStateController","auth","request","response","_migrateId","_setExisted","setPendingOp","_getStateIdentifier","promise","currentSession","SESSION_MISSING","data","ignoreEmailVerification","setParseUser","setUserController","_default"],"sources":["/Users/jonathandemarco/react/my-app/node_modules/parse/lib/browser/ParseUser.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _defineProperty = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\nconst CURRENT_USER_KEY = 'currentUser';\nlet canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nlet currentUserCacheMatchesDisk = false;\nlet currentUserCache = null;\nconst authProviders = {};\n\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n *\n * @alias Parse.User\n * @augments Parse.Object\n */\nclass ParseUser extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the user.\n   */\n  constructor(attributes) {\n    super('_User');\n    if (attributes && typeof attributes === 'object') {\n      if (!this.set(attributes || {})) {\n        throw new Error(\"Can't create an invalid Parse User\");\n      }\n    }\n  }\n\n  /**\n   * Request a revocable session token to replace the older style of token.\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n  _upgradeToRevocableSession(options) {\n    options = options || {};\n    const upgradeOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      upgradeOptions.useMasterKey = options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.upgradeToRevocableSession(this, upgradeOptions);\n  }\n\n  /**\n   * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling\n   * your users to sign up or log into your application using their existing identities.\n   * Since 2.9.0\n   *\n   * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options\n   * @param {object} [options.authData] AuthData to link with\n   * <ul>\n   *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}\n   *   <li>If provider is AuthProvider, options is saveOpts\n   * </ul>\n   * @param {object} saveOpts useMasterKey / sessionToken\n   * @returns {Promise} A promise that is fulfilled with the user is linked\n   */\n  linkWith(provider, options) {\n    let saveOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || '';\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n      if (authProviders[provider]) {\n        provider = authProviders[provider];\n      } else {\n        const authProvider = {\n          restoreAuthentication() {\n            return true;\n          },\n          getAuthType() {\n            return authType;\n          }\n        };\n        authProviders[authProvider.getAuthType()] = authProvider;\n        provider = authProvider;\n      }\n    } else {\n      authType = provider.getAuthType();\n    }\n    if (options && options.hasOwnProperty('authData')) {\n      const authData = this.get('authData') || {};\n      if (typeof authData !== 'object') {\n        throw new Error('Invalid type: authData field should be an object');\n      }\n      authData[authType] = options.authData;\n      const oldAnonymousData = authData.anonymous;\n      this.stripAnonymity();\n      const controller = _CoreManager.default.getUserController();\n      return controller.linkWith(this, authData, saveOpts).catch(e => {\n        delete authData[authType];\n        this.restoreAnonimity(oldAnonymousData);\n        throw e;\n      });\n    } else {\n      return new _promise.default((resolve, reject) => {\n        provider.authenticate({\n          success: (provider, result) => {\n            const opts = {};\n            opts.authData = result;\n            this.linkWith(provider, opts, saveOpts).then(() => {\n              resolve(this);\n            }, error => {\n              reject(error);\n            });\n          },\n          error: (provider, error) => {\n            reject(error);\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   * @returns {Promise}\n   */\n  _linkWith(provider, options) {\n    let saveOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.linkWith(provider, options, saveOpts);\n  }\n\n  /**\n   * Synchronizes auth data for a provider (e.g. puts the access token in the\n   * right place to be used by the Facebook SDK).\n   *\n   * @param provider\n   */\n  _synchronizeAuthData(provider) {\n    if (!this.isCurrent() || !provider) {\n      return;\n    }\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n      provider = authProviders[authType];\n    } else {\n      authType = provider.getAuthType();\n    }\n    const authData = this.get('authData');\n    if (!provider || !authData || typeof authData !== 'object') {\n      return;\n    }\n    const success = provider.restoreAuthentication(authData[authType]);\n    if (!success) {\n      this._unlinkFrom(provider);\n    }\n  }\n\n  /**\n   * Synchronizes authData for all providers.\n   */\n  _synchronizeAllAuthData() {\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      this._synchronizeAuthData(key);\n    }\n  }\n\n  /**\n   * Removes null values from authData (which exist temporarily for unlinking)\n   */\n  _cleanupAuthData() {\n    if (!this.isCurrent()) {\n      return;\n    }\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      if (!authData[key]) {\n        delete authData[key];\n      }\n    }\n  }\n\n  /**\n   * Unlinks a user from a service.\n   *\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options MasterKey / SessionToken\n   * @returns {Promise} A promise that is fulfilled when the unlinking\n   *     finishes.\n   */\n  _unlinkFrom(provider, options) {\n    return this.linkWith(provider, {\n      authData: null\n    }, options).then(() => {\n      this._synchronizeAuthData(provider);\n      return _promise.default.resolve(this);\n    });\n  }\n\n  /**\n   * Checks whether a user is linked to a service.\n   *\n   * @param {object} provider service to link to\n   * @returns {boolean} true if link was successful\n   */\n  _isLinked(provider) {\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n    } else {\n      authType = provider.getAuthType();\n    }\n    const authData = this.get('authData') || {};\n    if (typeof authData !== 'object') {\n      return false;\n    }\n    return !!authData[authType];\n  }\n\n  /**\n   * Deauthenticates all providers.\n   */\n  _logOutWithAll() {\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      this._logOutWith(key);\n    }\n  }\n\n  /**\n   * Deauthenticates a single provider (e.g. removing access tokens from the\n   * Facebook SDK).\n   *\n   * @param {object} provider service to logout of\n   */\n  _logOutWith(provider) {\n    if (!this.isCurrent()) {\n      return;\n    }\n    if (typeof provider === 'string') {\n      provider = authProviders[provider];\n    }\n    if (provider && provider.deauthenticate) {\n      provider.deauthenticate();\n    }\n  }\n\n  /**\n   * Class instance method used to maintain specific keys when a fetch occurs.\n   * Used to ensure that the session token is not lost.\n   *\n   * @returns {object} sessionToken\n   */\n  _preserveFieldsOnFetch() {\n    return {\n      sessionToken: this.get('sessionToken')\n    };\n  }\n\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {boolean} true if user is cached on disk\n   */\n  isCurrent() {\n    const current = ParseUser.current();\n    return !!current && current.id === this.id;\n  }\n\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {Promise<boolean>} true if user is cached on disk\n   */\n  async isCurrentAsync() {\n    const current = await ParseUser.currentAsync();\n    return !!current && current.id === this.id;\n  }\n  stripAnonymity() {\n    const authData = this.get('authData');\n    if (authData && typeof authData === 'object' && authData.hasOwnProperty('anonymous')) {\n      // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n      authData.anonymous = null;\n    }\n  }\n  restoreAnonimity(anonymousData) {\n    if (anonymousData) {\n      const authData = this.get('authData');\n      authData.anonymous = anonymousData;\n    }\n  }\n\n  /**\n   * Returns get(\"username\").\n   *\n   * @returns {string}\n   */\n  getUsername() {\n    const username = this.get('username');\n    if (username == null || typeof username === 'string') {\n      return username;\n    }\n    return '';\n  }\n\n  /**\n   * Calls set(\"username\", username, options) and returns the result.\n   *\n   * @param {string} username\n   */\n  setUsername(username) {\n    this.stripAnonymity();\n    this.set('username', username);\n  }\n\n  /**\n   * Calls set(\"password\", password, options) and returns the result.\n   *\n   * @param {string} password User's Password\n   */\n  setPassword(password) {\n    this.set('password', password);\n  }\n\n  /**\n   * Returns get(\"email\").\n   *\n   * @returns {string} User's Email\n   */\n  getEmail() {\n    const email = this.get('email');\n    if (email == null || typeof email === 'string') {\n      return email;\n    }\n    return '';\n  }\n\n  /**\n   * Calls set(\"email\", email) and returns the result.\n   *\n   * @param {string} email\n   * @returns {boolean}\n   */\n  setEmail(email) {\n    return this.set('email', email);\n  }\n\n  /**\n   * Returns the session token for this user, if the user has been logged in,\n   * or if it is the result of a query with the master key. Otherwise, returns\n   * undefined.\n   *\n   * @returns {string} the session token, or undefined\n   */\n  getSessionToken() {\n    const token = this.get('sessionToken');\n    if (token == null || typeof token === 'string') {\n      return token;\n    }\n    return '';\n  }\n\n  /**\n   * Checks whether this user is the current user and has been authenticated.\n   *\n   * @returns {boolean} whether this user is the current user and is logged in.\n   */\n  authenticated() {\n    const current = ParseUser.current();\n    return !!this.get('sessionToken') && !!current && current.id === this.id;\n  }\n\n  /**\n   * Signs up a new user. You should call this instead of save for\n   * new Parse.Users. This will create a new Parse.User on the server, and\n   * also persist the session on disk so that you can access the user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling signUp.</p>\n   *\n   * @param {object} attrs Extra fields to set on the new user, or null.\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled when the signup\n   *     finishes.\n   */\n  signUp(attrs, options) {\n    options = options || {};\n    const signupOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      signupOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('installationId')) {\n      signupOptions.installationId = options.installationId;\n    }\n    if (options.hasOwnProperty('context') && Object.prototype.toString.call(options.context) === '[object Object]') {\n      signupOptions.context = options.context;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.signUp(this, attrs, signupOptions);\n  }\n\n  /**\n   * Logs in a Parse.User. On success, this saves the session to disk,\n   * so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling logIn.</p>\n   *\n   * @param {object} options\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login is complete.\n   */\n  logIn() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options = options || {};\n    const loginOptions = {\n      usePost: true\n    };\n    if (options.hasOwnProperty('useMasterKey')) {\n      loginOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('installationId')) {\n      loginOptions.installationId = options.installationId;\n    }\n    if (options.hasOwnProperty('usePost')) {\n      loginOptions.usePost = options.usePost;\n    }\n    if (options.hasOwnProperty('context') && Object.prototype.toString.call(options.context) === '[object Object]') {\n      loginOptions.context = options.context;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.logIn(this, loginOptions);\n  }\n\n  /**\n   * Wrap the default save behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n  async save() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    await super.save.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default destroy behavior with functionality that logs out\n   * the current user when it is destroyed\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async destroy() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    await super.destroy.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().removeUserFromDisk();\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default fetch behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async fetch() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    await super.fetch.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default fetchWithInclude behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async fetchWithInclude() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    await super.fetchWithInclude.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} password The password to be verified.\n   * @param {object} options The options.\n   * @param {boolean} [options.ignoreEmailVerification] Set to `true` to bypass email verification and verify\n   * the password regardless of whether the email has been verified. This requires the master key.\n   * @returns {Promise} A promise that is fulfilled with a user when the password is correct.\n   */\n  verifyPassword(password, options) {\n    const username = this.getUsername() || '';\n    return ParseUser.verifyPassword(username, password, options);\n  }\n  static readOnlyAttributes() {\n    return ['sessionToken'];\n  }\n\n  /**\n   * Adds functionality to the existing Parse.User class.\n   *\n   * @param {object} protoProps A set of properties to add to the prototype\n   * @param {object} classProps A set of static properties to add to the class\n   * @static\n   * @returns {Parse.User} The newly extended Parse.User class\n   */\n  static extend(protoProps, classProps) {\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty.default)(ParseUser.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty.default)(ParseUser, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    return ParseUser;\n  }\n\n  /**\n   * Retrieves the currently logged in ParseUser with a valid session,\n   * either from memory or localStorage, if necessary.\n   *\n   * @static\n   * @returns {Parse.Object} The currently logged in Parse.User.\n   */\n  static current() {\n    if (!canUseCurrentUser) {\n      return null;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.currentUser();\n  }\n\n  /**\n   * Retrieves the currently logged in ParseUser from asynchronous Storage.\n   *\n   * @static\n   * @returns {Promise} A Promise that is resolved with the currently\n   *   logged in Parse User\n   */\n  static currentAsync() {\n    if (!canUseCurrentUser) {\n      return _promise.default.resolve(null);\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.currentUserAsync();\n  }\n\n  /**\n   * Signs up a new user with a username (or email) and password.\n   * This will create a new Parse.User on the server, and also persist the\n   * session in localStorage so that you can access the user using\n   * {@link #current}.\n   *\n   * @param {string} username The username (or email) to sign up with.\n   * @param {string} password The password to sign up with.\n   * @param {object} attrs Extra fields to set on the new user.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the signup completes.\n   */\n  static signUp(username, password, attrs, options) {\n    attrs = attrs || {};\n    attrs.username = username;\n    attrs.password = password;\n    const user = new this(attrs);\n    return user.signUp({}, options);\n  }\n\n  /**\n   * Logs in a user with a username (or email) and password. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static logIn(username, password, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    } else if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    const user = new this();\n    user._finishFetch({\n      username: username,\n      password: password\n    });\n    return user.logIn(options);\n  }\n\n  /**\n   * Logs in a user with a username (or email) and password, and authData. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} authData The authData to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static logInWithAdditionalAuth(username, password, authData, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n    if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    if (Object.prototype.toString.call(authData) !== '[object Object]') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Auth must be an object.'));\n    }\n    const user = new this();\n    user._finishFetch({\n      username: username,\n      password: password,\n      authData\n    });\n    return user.logIn(options);\n  }\n\n  /**\n   * Logs in a user with an objectId. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} userId The objectId for the user.\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static loginAs(userId) {\n    if (!userId) {\n      throw new _ParseError.default(_ParseError.default.USERNAME_MISSING, 'Cannot log in as user with an empty user id');\n    }\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.loginAs(user, userId);\n  }\n\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} sessionToken The sessionToken to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static become(sessionToken, options) {\n    if (!canUseCurrentUser) {\n      throw new Error('It is not memory-safe to become a user in a server environment');\n    }\n    options = options || {};\n    const becomeOptions = {\n      sessionToken: sessionToken\n    };\n    if (options.hasOwnProperty('useMasterKey')) {\n      becomeOptions.useMasterKey = options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.become(user, becomeOptions);\n  }\n\n  /**\n   * Retrieves a user with a session token.\n   *\n   * @param {string} sessionToken The sessionToken to get user with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user is fetched.\n   */\n  static me(sessionToken) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const controller = _CoreManager.default.getUserController();\n    const meOptions = {\n      sessionToken: sessionToken\n    };\n    if (options.useMasterKey) {\n      meOptions.useMasterKey = options.useMasterKey;\n    }\n    const user = new this();\n    return controller.me(user, meOptions);\n  }\n\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>. If there is no session token the user will not logged in.\n   *\n   * @param {object} userJSON The JSON map of the User's data\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static hydrate(userJSON) {\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.hydrate(user, userJSON);\n  }\n\n  /**\n   * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   *\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @static\n   * @returns {Promise}\n   */\n  static logInWith(provider, options, saveOpts) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n\n  /**\n   * Logs out the currently logged in user session. This will remove the\n   * session from disk, log out of linked services, and future calls to\n   * <code>current</code> will return <code>null</code>.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the session is\n   *   destroyed on the server.\n   */\n  static logOut() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const controller = _CoreManager.default.getUserController();\n    return controller.logOut(options);\n  }\n\n  /**\n   * Requests a password reset email to be sent to the specified email address\n   * associated with the user account. This email allows the user to securely\n   * reset their password on the Parse site.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n  static requestPasswordReset(email, options) {\n    options = options || {};\n    const requestOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.requestPasswordReset(email, requestOptions);\n  }\n\n  /**\n   * Request an email verification.\n   *\n   * @param {string} email The email address associated with the user that\n   *     needs to verify their email.\n   * @param {object} options\n   * @static\n   * @returns {Promise}\n   */\n  static requestEmailVerification(email, options) {\n    options = options || {};\n    const requestOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      requestOptions.useMasterKey = options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.requestEmailVerification(email, requestOptions);\n  }\n\n  /**\n   * Verify whether a given password is the password of the current user.\n   * @static\n   *\n   * @param {string} username  The username of the user whose password should be verified.\n   * @param {string} password The password to be verified.\n   * @param {object} options The options.\n   * @param {boolean} [options.ignoreEmailVerification] Set to `true` to bypass email verification and verify\n   * the password regardless of whether the email has been verified. This requires the master key.\n   * @returns {Promise} A promise that is fulfilled with a user when the password is correct.\n   */\n  static verifyPassword(username, password, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n    if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.verifyPassword(username, password, options || {});\n  }\n\n  /**\n   * Allow someone to define a custom User class without className\n   * being rewritten to _User. The default behavior is to rewrite\n   * User to _User for legacy reasons. This allows developers to\n   * override that behavior.\n   *\n   * @param {boolean} isAllowed Whether or not to allow custom User class\n   * @static\n   */\n  static allowCustomUserClass(isAllowed) {\n    _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n  }\n\n  /**\n   * Allows a legacy application to start using revocable sessions. If the\n   * current session token is not revocable, a request will be made for a new,\n   * revocable session.\n   * It is not necessary to call this method from cloud code unless you are\n   * handling user signup or login from the server side. In a cloud code call,\n   * this function will not attempt to upgrade the current token.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the process has\n   *   completed. If a replacement session token is requested, the promise\n   *   will be resolved after a new token has been fetched.\n   */\n  static enableRevocableSession(options) {\n    options = options || {};\n    _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n    if (canUseCurrentUser) {\n      const current = ParseUser.current();\n      if (current) {\n        return current._upgradeToRevocableSession(options);\n      }\n    }\n    return _promise.default.resolve();\n  }\n\n  /**\n   * Enables the use of become or the current user in a server\n   * environment. These features are disabled by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n  static enableUnsafeCurrentUser() {\n    canUseCurrentUser = true;\n  }\n\n  /**\n   * Disables the use of become or the current user in any environment.\n   * These features are disabled on servers by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n  static disableUnsafeCurrentUser() {\n    canUseCurrentUser = false;\n  }\n\n  /**\n   * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider\n   * is automatically created for you.\n   *\n   * For advanced authentication, you can register an Auth provider to\n   * implement custom authentication, deauthentication.\n   *\n   * @param provider\n   * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}\n   * @static\n   */\n  static _registerAuthenticationProvider(provider) {\n    authProviders[provider.getAuthType()] = provider;\n    // Synchronize the current user with the auth provider.\n    ParseUser.currentAsync().then(current => {\n      if (current) {\n        current._synchronizeAuthData(provider.getAuthType());\n      }\n    });\n  }\n\n  /**\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}\n   * @static\n   * @returns {Promise}\n   */\n  static _logInWith(provider, options, saveOpts) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n  static _clearCache() {\n    currentUserCache = null;\n    currentUserCacheMatchesDisk = false;\n  }\n  static _setCurrentUserCache(user) {\n    currentUserCache = user;\n  }\n}\n_ParseObject.default.registerSubclass('_User', ParseUser);\nconst DefaultController = {\n  updateUserOnDisk(user) {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    const json = user.toJSON();\n    delete json.password;\n    json.className = '_User';\n    let userData = (0, _stringify.default)(json);\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n      userData = crypto.encrypt(json, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n    return _Storage.default.setItemAsync(path, userData).then(() => {\n      return user;\n    });\n  },\n  removeUserFromDisk() {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n  setCurrentUser(user) {\n    currentUserCache = user;\n    user._cleanupAuthData();\n    user._synchronizeAllAuthData();\n    return DefaultController.updateUserOnDisk(user);\n  },\n  currentUser() {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    let userData = _Storage.default.getItem(path);\n    currentUserCacheMatchesDisk = true;\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n      userData = crypto.decrypt(userData, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n    userData = JSON.parse(userData);\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n      delete userData._id;\n    }\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n    const current = _ParseObject.default.fromJSON(userData);\n    currentUserCache = current;\n    current._synchronizeAllAuthData();\n    return current;\n  },\n  currentUserAsync() {\n    if (currentUserCache) {\n      return _promise.default.resolve(currentUserCache);\n    }\n    if (currentUserCacheMatchesDisk) {\n      return _promise.default.resolve(null);\n    }\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    return _Storage.default.getItemAsync(path).then(userData => {\n      currentUserCacheMatchesDisk = true;\n      if (!userData) {\n        currentUserCache = null;\n        return _promise.default.resolve(null);\n      }\n      if (_CoreManager.default.get('ENCRYPTED_USER')) {\n        const crypto = _CoreManager.default.getCryptoController();\n        userData = crypto.decrypt(userData.toString(), _CoreManager.default.get('ENCRYPTED_KEY'));\n      }\n      userData = JSON.parse(userData);\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n        delete userData._id;\n      }\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n      const current = _ParseObject.default.fromJSON(userData);\n      currentUserCache = current;\n      current._synchronizeAllAuthData();\n      return _promise.default.resolve(current);\n    });\n  },\n  signUp(user, attrs, options) {\n    const username = attrs && attrs.username || user.get('username');\n    const password = attrs && attrs.password || user.get('password');\n    if (!username || !username.length) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty username.'));\n    }\n    if (!password || !password.length) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n    return user.save(attrs, options).then(() => {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n      return user;\n    });\n  },\n  logIn(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    const stateController = _CoreManager.default.getObjectStateController();\n    const auth = {\n      username: user.get('username'),\n      password: user.get('password'),\n      authData: user.get('authData')\n    };\n    return RESTController.request(options.usePost ? 'POST' : 'GET', 'login', auth, options).then(response => {\n      user._migrateId(response.objectId);\n      user._setExisted(true);\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n      user._finishFetch(response);\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return _promise.default.resolve(user);\n      }\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  loginAs(user, userId) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'loginAs', {\n      userId\n    }, {\n      useMasterKey: true\n    }).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      if (!canUseCurrentUser) {\n        return _promise.default.resolve(user);\n      }\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  become(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  hydrate(user, userJSON) {\n    user._finishFetch(userJSON);\n    user._setExisted(true);\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    } else {\n      return _promise.default.resolve(user);\n    }\n  },\n  me(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      return user;\n    });\n  },\n  logOut(options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    if (options.sessionToken) {\n      return RESTController.request('POST', 'logout', {}, options);\n    }\n    return DefaultController.currentUserAsync().then(currentUser => {\n      const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n      let promise = _Storage.default.removeItemAsync(path);\n      if (currentUser !== null) {\n        const currentSession = currentUser.getSessionToken();\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(() => {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n        currentUser._logOutWithAll();\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n      }\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n  requestPasswordReset(email, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email: email\n    }, options);\n  },\n  async upgradeToRevocableSession(user, options) {\n    const token = user.getSessionToken();\n    if (!token) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n    options.sessionToken = token;\n    const RESTController = _CoreManager.default.getRESTController();\n    const result = await RESTController.request('POST', 'upgradeToRevocableSession', {}, options);\n    user._finishFetch({\n      sessionToken: result?.sessionToken || ''\n    });\n    const current = await user.isCurrentAsync();\n    if (current) {\n      return DefaultController.setCurrentUser(user);\n    }\n    return _promise.default.resolve(user);\n  },\n  linkWith(user, authData, options) {\n    return user.save({\n      authData\n    }, options).then(() => {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n      return user;\n    });\n  },\n  verifyPassword(username, password, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    const data = {\n      username,\n      password,\n      ...(options.ignoreEmailVerification !== undefined && {\n        ignoreEmailVerification: options.ignoreEmailVerification\n      })\n    };\n    return RESTController.request('GET', 'verifyPassword', data, options);\n  },\n  requestEmailVerification(email, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'verificationEmailRequest', {\n      email: email\n    }, options);\n  }\n};\n_CoreManager.default.setParseUser(ParseUser);\n_CoreManager.default.setUserController(DefaultController);\nvar _default = exports.default = ParseUser;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}