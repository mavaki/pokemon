{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _findIndex = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find-index\"));\nvar _setInterval2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-interval\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\nconst QUEUE_KEY = 'Parse/Eventually/Queue';\nlet queueCache = [];\nlet dirtyCache = true;\nlet polling = undefined;\n\n/**\n * Provides utility functions to queue objects that will be\n * saved to the server at a later date.\n *\n * @class Parse.EventuallyQueue\n * @static\n */\nconst EventuallyQueue = {\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function save\n   * @name Parse.EventuallyQueue.save\n   * @param {ParseObject} object Parse.Object to be saved eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#save Parse.Object.save} options.\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#saveEventually\n   */\n  save(object) {\n    let serverOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.enqueue('save', object, serverOptions);\n  },\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function destroy\n   * @name Parse.EventuallyQueue.destroy\n   * @param {ParseObject} object Parse.Object to be destroyed eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#destroy Parse.Object.destroy} options\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#destroyEventually\n   */\n  destroy(object) {\n    let serverOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.enqueue('destroy', object, serverOptions);\n  },\n  /**\n   * Generate unique identifier to avoid duplicates and maintain previous state.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @returns {string}\n   * @static\n   * @ignore\n   */\n  generateQueueId(action, object) {\n    object._getId();\n    const {\n      className,\n      id,\n      _localId\n    } = object;\n    const uniqueId = object.get('hash') || _localId;\n    return [action, className, id, uniqueId].join('_');\n  },\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @param {object} [serverOptions]\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @ignore\n   */\n  async enqueue(action, object, serverOptions) {\n    const queueData = await this.getQueue();\n    const queueId = this.generateQueueId(action, object);\n    let index = this.queueItemExists(queueData, queueId);\n    if (index > -1) {\n      // Add cached values to new object if they don't exist\n      for (const prop in queueData[index].object) {\n        if (typeof object.get(prop) === 'undefined') {\n          object.set(prop, queueData[index].object[prop]);\n        }\n      }\n    } else {\n      index = queueData.length;\n    }\n    queueData[index] = {\n      queueId,\n      action,\n      object: object.toJSON(),\n      serverOptions,\n      id: object.id,\n      className: object.className,\n      hash: object.get('hash'),\n      createdAt: new Date()\n    };\n    return this.setQueue(queueData);\n  },\n  store(data) {\n    return _Storage.default.setItemAsync(QUEUE_KEY, (0, _stringify.default)(data));\n  },\n  load() {\n    return _Storage.default.getItemAsync(QUEUE_KEY);\n  },\n  /**\n   * Sets the in-memory queue from local storage and returns.\n   *\n   * @function getQueue\n   * @name Parse.EventuallyQueue.getQueue\n   * @returns {Promise<QueueObject[]>}\n   * @static\n   */\n  async getQueue() {\n    if (dirtyCache) {\n      queueCache = JSON.parse((await this.load()) || '[]');\n      dirtyCache = false;\n    }\n    return queueCache;\n  },\n  /**\n   * Saves the queue to local storage\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  setQueue(queue) {\n    queueCache = queue;\n    return this.store(queueCache);\n  },\n  /**\n   * Removes Parse.Object data from queue.\n   *\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  async remove(queueId) {\n    const queueData = await this.getQueue();\n    const index = this.queueItemExists(queueData, queueId);\n    if (index > -1) {\n      (0, _splice.default)(queueData).call(queueData, index, 1);\n      await this.setQueue(queueData);\n    }\n  },\n  /**\n   * Removes all objects from queue.\n   *\n   * @function clear\n   * @name Parse.EventuallyQueue.clear\n   * @returns {Promise} A promise that is fulfilled when queue is cleared.\n   * @static\n   */\n  clear() {\n    queueCache = [];\n    return this.store([]);\n  },\n  /**\n   * Return the index of a queueId in the queue. Returns -1 if not found.\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {number}\n   * @static\n   * @ignore\n   */\n  queueItemExists(queue, queueId) {\n    return (0, _findIndex.default)(queue).call(queue, data => data.queueId === queueId);\n  },\n  /**\n   * Return the number of objects in the queue.\n   *\n   * @function length\n   * @name Parse.EventuallyQueue.length\n   * @returns {Promise<number>}\n   * @static\n   */\n  async length() {\n    const queueData = await this.getQueue();\n    return queueData.length;\n  },\n  /**\n   * Sends the queue to the server.\n   *\n   * @function sendQueue\n   * @name Parse.EventuallyQueue.sendQueue\n   * @returns {Promise<boolean>} Returns true if queue was sent successfully.\n   * @static\n   */\n  async sendQueue() {\n    const queue = await this.getQueue();\n    const queueData = [...queue];\n    if (queueData.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < queueData.length; i += 1) {\n      const queueObject = queueData[i];\n      const {\n        id,\n        hash,\n        className\n      } = queueObject;\n      const ObjectType = _ParseObject.default.extend(className);\n      if (id) {\n        await this.process.byId(ObjectType, queueObject);\n      } else if (hash) {\n        await this.process.byHash(ObjectType, queueObject);\n      } else {\n        await this.process.create(ObjectType, queueObject);\n      }\n    }\n    return true;\n  },\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {ParseObject} object Parse.Object to be processed\n   * @param {QueueObject} queueObject Parse.Object data from the queue\n   * @returns {Promise} A promise that is fulfilled when operation is performed.\n   * @static\n   * @ignore\n   */\n  async sendQueueCallback(object, queueObject) {\n    if (!object) {\n      return this.remove(queueObject.queueId);\n    }\n    switch (queueObject.action) {\n      case 'save':\n        // Queued update was overwritten by other request. Do not save\n        if (typeof object.updatedAt !== 'undefined' && object.updatedAt > new Date(queueObject.object.createdAt)) {\n          return this.remove(queueObject.queueId);\n        }\n        try {\n          await object.save(queueObject.object, queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.code !== _ParseError.default.CONNECTION_FAILED) {\n            await this.remove(queueObject.queueId);\n          }\n        }\n        break;\n      case 'destroy':\n        try {\n          await object.destroy(queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.code !== _ParseError.default.CONNECTION_FAILED) {\n            await this.remove(queueObject.queueId);\n          }\n        }\n        break;\n    }\n  },\n  /**\n   * Start polling server for network connection.\n   * Will send queue if connection is established.\n   *\n   * @function poll\n   * @name Parse.EventuallyQueue.poll\n   * @param [ms] Milliseconds to ping the server. Default 2000ms\n   * @static\n   */\n  poll() {\n    let ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;\n    if (polling) {\n      return;\n    }\n    polling = (0, _setInterval2.default)(() => {\n      const RESTController = _CoreManager.default.getRESTController();\n      RESTController.request('GET', 'health').then(_ref => {\n        let {\n          status\n        } = _ref;\n        if (status === 'ok') {\n          this.stopPoll();\n          return this.sendQueue();\n        }\n      }).catch(e => e);\n    }, ms);\n  },\n  /**\n   * Turns off polling.\n   *\n   * @function stopPoll\n   * @name Parse.EventuallyQueue.stopPoll\n   * @static\n   */\n  stopPoll() {\n    clearInterval(polling);\n    polling = undefined;\n  },\n  /**\n   * Return true if pinging the server.\n   *\n   * @function isPolling\n   * @name Parse.EventuallyQueue.isPolling\n   * @returns {boolean}\n   * @static\n   */\n  isPolling() {\n    return !!polling;\n  },\n  _setPolling(flag) {\n    polling = flag;\n  },\n  process: {\n    create(ObjectType, queueObject) {\n      const object = new ObjectType();\n      return EventuallyQueue.sendQueueCallback(object, queueObject);\n    },\n    async byId(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('objectId', queueObject.id);\n      const results = await (0, _find.default)(query).call(query, {\n        sessionToken\n      });\n      return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n    },\n    async byHash(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('hash', queueObject.hash);\n      const results = await (0, _find.default)(query).call(query, {\n        sessionToken\n      });\n      if (results.length > 0) {\n        return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n      }\n      return EventuallyQueue.process.create(ObjectType, queueObject);\n    }\n  }\n};\nmodule.exports = EventuallyQueue;\nvar _default = exports.default = EventuallyQueue;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_stringify","_splice","_findIndex","_setInterval2","_find","_CoreManager","_ParseError","_ParseObject","_ParseQuery","_Storage","QUEUE_KEY","queueCache","dirtyCache","polling","undefined","EventuallyQueue","save","object","serverOptions","arguments","length","enqueue","destroy","generateQueueId","action","_getId","className","id","_localId","uniqueId","get","join","queueData","getQueue","queueId","index","queueItemExists","prop","set","toJSON","hash","createdAt","Date","setQueue","store","data","setItemAsync","load","getItemAsync","JSON","parse","queue","remove","call","clear","sendQueue","i","queueObject","ObjectType","extend","process","byId","byHash","create","sendQueueCallback","updatedAt","e","code","CONNECTION_FAILED","poll","ms","RESTController","getRESTController","request","then","_ref","status","stopPoll","catch","clearInterval","isPolling","_setPolling","flag","sessionToken","query","equalTo","results","module","_default"],"sources":["/home/mavrik/Documents/classes/web-dev/feature05/node_modules/parse/lib/browser/EventuallyQueue.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _findIndex = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find-index\"));\nvar _setInterval2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-interval\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\nconst QUEUE_KEY = 'Parse/Eventually/Queue';\nlet queueCache = [];\nlet dirtyCache = true;\nlet polling = undefined;\n\n/**\n * Provides utility functions to queue objects that will be\n * saved to the server at a later date.\n *\n * @class Parse.EventuallyQueue\n * @static\n */\nconst EventuallyQueue = {\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function save\n   * @name Parse.EventuallyQueue.save\n   * @param {ParseObject} object Parse.Object to be saved eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#save Parse.Object.save} options.\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#saveEventually\n   */\n  save(object) {\n    let serverOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.enqueue('save', object, serverOptions);\n  },\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function destroy\n   * @name Parse.EventuallyQueue.destroy\n   * @param {ParseObject} object Parse.Object to be destroyed eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#destroy Parse.Object.destroy} options\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#destroyEventually\n   */\n  destroy(object) {\n    let serverOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.enqueue('destroy', object, serverOptions);\n  },\n  /**\n   * Generate unique identifier to avoid duplicates and maintain previous state.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @returns {string}\n   * @static\n   * @ignore\n   */\n  generateQueueId(action, object) {\n    object._getId();\n    const {\n      className,\n      id,\n      _localId\n    } = object;\n    const uniqueId = object.get('hash') || _localId;\n    return [action, className, id, uniqueId].join('_');\n  },\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @param {object} [serverOptions]\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @ignore\n   */\n  async enqueue(action, object, serverOptions) {\n    const queueData = await this.getQueue();\n    const queueId = this.generateQueueId(action, object);\n    let index = this.queueItemExists(queueData, queueId);\n    if (index > -1) {\n      // Add cached values to new object if they don't exist\n      for (const prop in queueData[index].object) {\n        if (typeof object.get(prop) === 'undefined') {\n          object.set(prop, queueData[index].object[prop]);\n        }\n      }\n    } else {\n      index = queueData.length;\n    }\n    queueData[index] = {\n      queueId,\n      action,\n      object: object.toJSON(),\n      serverOptions,\n      id: object.id,\n      className: object.className,\n      hash: object.get('hash'),\n      createdAt: new Date()\n    };\n    return this.setQueue(queueData);\n  },\n  store(data) {\n    return _Storage.default.setItemAsync(QUEUE_KEY, (0, _stringify.default)(data));\n  },\n  load() {\n    return _Storage.default.getItemAsync(QUEUE_KEY);\n  },\n  /**\n   * Sets the in-memory queue from local storage and returns.\n   *\n   * @function getQueue\n   * @name Parse.EventuallyQueue.getQueue\n   * @returns {Promise<QueueObject[]>}\n   * @static\n   */\n  async getQueue() {\n    if (dirtyCache) {\n      queueCache = JSON.parse((await this.load()) || '[]');\n      dirtyCache = false;\n    }\n    return queueCache;\n  },\n  /**\n   * Saves the queue to local storage\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  setQueue(queue) {\n    queueCache = queue;\n    return this.store(queueCache);\n  },\n  /**\n   * Removes Parse.Object data from queue.\n   *\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  async remove(queueId) {\n    const queueData = await this.getQueue();\n    const index = this.queueItemExists(queueData, queueId);\n    if (index > -1) {\n      (0, _splice.default)(queueData).call(queueData, index, 1);\n      await this.setQueue(queueData);\n    }\n  },\n  /**\n   * Removes all objects from queue.\n   *\n   * @function clear\n   * @name Parse.EventuallyQueue.clear\n   * @returns {Promise} A promise that is fulfilled when queue is cleared.\n   * @static\n   */\n  clear() {\n    queueCache = [];\n    return this.store([]);\n  },\n  /**\n   * Return the index of a queueId in the queue. Returns -1 if not found.\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {number}\n   * @static\n   * @ignore\n   */\n  queueItemExists(queue, queueId) {\n    return (0, _findIndex.default)(queue).call(queue, data => data.queueId === queueId);\n  },\n  /**\n   * Return the number of objects in the queue.\n   *\n   * @function length\n   * @name Parse.EventuallyQueue.length\n   * @returns {Promise<number>}\n   * @static\n   */\n  async length() {\n    const queueData = await this.getQueue();\n    return queueData.length;\n  },\n  /**\n   * Sends the queue to the server.\n   *\n   * @function sendQueue\n   * @name Parse.EventuallyQueue.sendQueue\n   * @returns {Promise<boolean>} Returns true if queue was sent successfully.\n   * @static\n   */\n  async sendQueue() {\n    const queue = await this.getQueue();\n    const queueData = [...queue];\n    if (queueData.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < queueData.length; i += 1) {\n      const queueObject = queueData[i];\n      const {\n        id,\n        hash,\n        className\n      } = queueObject;\n      const ObjectType = _ParseObject.default.extend(className);\n      if (id) {\n        await this.process.byId(ObjectType, queueObject);\n      } else if (hash) {\n        await this.process.byHash(ObjectType, queueObject);\n      } else {\n        await this.process.create(ObjectType, queueObject);\n      }\n    }\n    return true;\n  },\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {ParseObject} object Parse.Object to be processed\n   * @param {QueueObject} queueObject Parse.Object data from the queue\n   * @returns {Promise} A promise that is fulfilled when operation is performed.\n   * @static\n   * @ignore\n   */\n  async sendQueueCallback(object, queueObject) {\n    if (!object) {\n      return this.remove(queueObject.queueId);\n    }\n    switch (queueObject.action) {\n      case 'save':\n        // Queued update was overwritten by other request. Do not save\n        if (typeof object.updatedAt !== 'undefined' && object.updatedAt > new Date(queueObject.object.createdAt)) {\n          return this.remove(queueObject.queueId);\n        }\n        try {\n          await object.save(queueObject.object, queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.code !== _ParseError.default.CONNECTION_FAILED) {\n            await this.remove(queueObject.queueId);\n          }\n        }\n        break;\n      case 'destroy':\n        try {\n          await object.destroy(queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.code !== _ParseError.default.CONNECTION_FAILED) {\n            await this.remove(queueObject.queueId);\n          }\n        }\n        break;\n    }\n  },\n  /**\n   * Start polling server for network connection.\n   * Will send queue if connection is established.\n   *\n   * @function poll\n   * @name Parse.EventuallyQueue.poll\n   * @param [ms] Milliseconds to ping the server. Default 2000ms\n   * @static\n   */\n  poll() {\n    let ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2000;\n    if (polling) {\n      return;\n    }\n    polling = (0, _setInterval2.default)(() => {\n      const RESTController = _CoreManager.default.getRESTController();\n      RESTController.request('GET', 'health').then(_ref => {\n        let {\n          status\n        } = _ref;\n        if (status === 'ok') {\n          this.stopPoll();\n          return this.sendQueue();\n        }\n      }).catch(e => e);\n    }, ms);\n  },\n  /**\n   * Turns off polling.\n   *\n   * @function stopPoll\n   * @name Parse.EventuallyQueue.stopPoll\n   * @static\n   */\n  stopPoll() {\n    clearInterval(polling);\n    polling = undefined;\n  },\n  /**\n   * Return true if pinging the server.\n   *\n   * @function isPolling\n   * @name Parse.EventuallyQueue.isPolling\n   * @returns {boolean}\n   * @static\n   */\n  isPolling() {\n    return !!polling;\n  },\n  _setPolling(flag) {\n    polling = flag;\n  },\n  process: {\n    create(ObjectType, queueObject) {\n      const object = new ObjectType();\n      return EventuallyQueue.sendQueueCallback(object, queueObject);\n    },\n    async byId(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('objectId', queueObject.id);\n      const results = await (0, _find.default)(query).call(query, {\n        sessionToken\n      });\n      return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n    },\n    async byHash(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('hash', queueObject.hash);\n      const results = await (0, _find.default)(query).call(query, {\n        sessionToken\n      });\n      if (results.length > 0) {\n        return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n      }\n      return EventuallyQueue.process.create(ObjectType, queueObject);\n    }\n  }\n};\nmodule.exports = EventuallyQueue;\nvar _default = exports.default = EventuallyQueue;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}