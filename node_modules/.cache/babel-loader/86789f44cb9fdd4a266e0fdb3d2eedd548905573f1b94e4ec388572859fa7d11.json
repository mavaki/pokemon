{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _ParseCLP = _interopRequireDefault(require(\"./ParseCLP\"));\nconst FIELD_TYPES = ['String', 'Number', 'Boolean', 'Bytes', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\n *\n * <pre>\n * const options = { required: true, defaultValue: 'hello world' };\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field', options);\n * schema.addIndex('index_name', { 'field': 1 });\n * schema.save();\n * </pre>\n * </p>\n *\n * @alias Parse.Schema\n */\nclass ParseSchema {\n  /**\n   * @param {string} className Parse Class string.\n   */\n  constructor(className) {\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\n    (0, _defineProperty2.default)(this, \"_clp\", void 0);\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n    this._fields = {};\n    this._indexes = {};\n  }\n\n  /**\n   * Static method to get all schemas\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  static all() {\n    const controller = _CoreManager.default.getSchemaController();\n    return controller.get('').then(response => {\n      if (response.results.length === 0) {\n        throw new Error('Schema not found.');\n      }\n      return response.results;\n    });\n  }\n\n  /**\n   * Get the Schema from Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  get() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    return controller.get(this.className).then(response => {\n      if (!response) {\n        throw new Error('Schema not found.');\n      }\n      return response;\n    });\n  }\n\n  /**\n   * Create a new Schema on Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  save() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    const params = {\n      className: this.className,\n      fields: this._fields,\n      indexes: this._indexes,\n      classLevelPermissions: this._clp\n    };\n    return controller.create(this.className, params);\n  }\n\n  /**\n   * Update a Schema on Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  update() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    const params = {\n      className: this.className,\n      fields: this._fields,\n      indexes: this._indexes,\n      classLevelPermissions: this._clp\n    };\n    this._fields = {};\n    this._indexes = {};\n    return controller.update(this.className, params);\n  }\n\n  /**\n   * Removing a Schema from Parse\n   * Can only be used on Schema without objects\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  delete() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    return controller.delete(this.className);\n  }\n\n  /**\n   * Removes all objects from a Schema (class) in Parse.\n   * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  purge() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    return controller.purge(this.className);\n  }\n\n  /**\n   * Assert if ClassName has been filled\n   *\n   * @private\n   */\n  assertClassName() {\n    if (!this.className) {\n      throw new Error('You must set a Class Name before making any request.');\n    }\n  }\n\n  /**\n   * Sets Class Level Permissions when creating / updating a Schema.\n   * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\n   *\n   * @param {object | Parse.CLP} clp Class Level Permissions\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  setCLP(clp) {\n    if (clp instanceof _ParseCLP.default) {\n      this._clp = clp.toJSON();\n    } else {\n      this._clp = clp;\n    }\n    return this;\n  }\n\n  /**\n   * Adding a Field to Create / Update a Schema\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\n   *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\n   *   <li>targetClass: Required if type is Pointer or Parse.Relation\n   * </ul>\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addField(name, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    type = type || 'String';\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n    if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {\n      throw new Error(`${type} is not a valid type.`);\n    }\n    if (type === 'Pointer') {\n      return this.addPointer(name, options.targetClass, options);\n    }\n    if (type === 'Relation') {\n      return this.addRelation(name, options.targetClass);\n    }\n    const fieldOptions = {\n      type\n    };\n    if (typeof options.required === 'boolean') {\n      fieldOptions.required = options.required;\n    }\n    if (options.defaultValue !== undefined) {\n      fieldOptions.defaultValue = options.defaultValue;\n    }\n    if (type === 'Date') {\n      if (options && options.defaultValue) {\n        fieldOptions.defaultValue = {\n          __type: 'Date',\n          iso: new Date(options.defaultValue)\n        };\n      }\n    }\n    if (type === 'Bytes') {\n      if (options && options.defaultValue) {\n        fieldOptions.defaultValue = {\n          __type: 'Bytes',\n          base64: options.defaultValue\n        };\n      }\n    }\n    this._fields[name] = fieldOptions;\n    return this;\n  }\n\n  /**\n   * Adding an Index to Create / Update a Schema\n   *\n   * @param {string} name Name of the index\n   * @param {object} index { field: value }\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   *\n   * <pre>\n   * schema.addIndex('index_name', { 'field': 1 });\n   * </pre>\n   */\n  addIndex(name, index) {\n    if (!name) {\n      throw new Error('index name may not be null.');\n    }\n    if (!index) {\n      throw new Error('index may not be null.');\n    }\n    this._indexes[name] = index;\n    return this;\n  }\n\n  /**\n   * Adding String Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addString(name, options) {\n    return this.addField(name, 'String', options);\n  }\n\n  /**\n   * Adding Number Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addNumber(name, options) {\n    return this.addField(name, 'Number', options);\n  }\n\n  /**\n   * Adding Boolean Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addBoolean(name, options) {\n    return this.addField(name, 'Boolean', options);\n  }\n\n  /**\n   * Adding Bytes Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addBytes(name, options) {\n    return this.addField(name, 'Bytes', options);\n  }\n\n  /**\n   * Adding Date Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addDate(name, options) {\n    return this.addField(name, 'Date', options);\n  }\n\n  /**\n   * Adding File Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addFile(name, options) {\n    return this.addField(name, 'File', options);\n  }\n\n  /**\n   * Adding GeoPoint Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addGeoPoint(name, options) {\n    return this.addField(name, 'GeoPoint', options);\n  }\n\n  /**\n   * Adding Polygon Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addPolygon(name, options) {\n    return this.addField(name, 'Polygon', options);\n  }\n\n  /**\n   * Adding Array Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addArray(name, options) {\n    return this.addField(name, 'Array', options);\n  }\n\n  /**\n   * Adding Object Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addObject(name, options) {\n    return this.addField(name, 'Object', options);\n  }\n\n  /**\n   * Adding Pointer Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} targetClass Name of the target Pointer Class\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addPointer(name, targetClass) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n    if (!targetClass) {\n      throw new Error('You need to set the targetClass of the Pointer.');\n    }\n    const fieldOptions = {\n      type: 'Pointer',\n      targetClass\n    };\n    if (typeof options.required === 'boolean') {\n      fieldOptions.required = options.required;\n    }\n    if (options.defaultValue !== undefined) {\n      fieldOptions.defaultValue = options.defaultValue;\n      if (options.defaultValue instanceof _ParseObject.default) {\n        fieldOptions.defaultValue = options.defaultValue.toPointer();\n      }\n    }\n    this._fields[name] = fieldOptions;\n    return this;\n  }\n\n  /**\n   * Adding Relation Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} targetClass Name of the target Pointer Class\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addRelation(name, targetClass) {\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n    if (!targetClass) {\n      throw new Error('You need to set the targetClass of the Relation.');\n    }\n    this._fields[name] = {\n      type: 'Relation',\n      targetClass\n    };\n    return this;\n  }\n\n  /**\n   * Deleting a Field to Update on a Schema\n   *\n   * @param {string} name Name of the field\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  deleteField(name) {\n    this._fields[name] = {\n      __op: 'Delete'\n    };\n    return this;\n  }\n\n  /**\n   * Deleting an Index to Update on a Schema\n   *\n   * @param {string} name Name of the field\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  deleteIndex(name) {\n    this._indexes[name] = {\n      __op: 'Delete'\n    };\n    return this;\n  }\n}\nconst DefaultController = {\n  send(className, method) {\n    let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request(method, `schemas/${className}`, params, {\n      useMasterKey: true\n    });\n  },\n  get(className) {\n    return this.send(className, 'GET');\n  },\n  create(className, params) {\n    return this.send(className, 'POST', params);\n  },\n  update(className, params) {\n    return this.send(className, 'PUT', params);\n  },\n  delete(className) {\n    return this.send(className, 'DELETE');\n  },\n  purge(className) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('DELETE', `purge/${className}`, {}, {\n      useMasterKey: true\n    });\n  }\n};\n_CoreManager.default.setSchemaController(DefaultController);\nvar _default = exports.default = ParseSchema;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_indexOf","_defineProperty2","_CoreManager","_ParseObject","_ParseCLP","FIELD_TYPES","ParseSchema","constructor","className","get","_fields","_indexes","all","controller","getSchemaController","then","response","results","length","Error","assertClassName","save","params","fields","indexes","classLevelPermissions","_clp","create","update","delete","purge","setCLP","clp","toJSON","addField","name","type","options","arguments","undefined","call","addPointer","targetClass","addRelation","fieldOptions","required","defaultValue","__type","iso","Date","base64","addIndex","index","addString","addNumber","addBoolean","addBytes","addDate","addFile","addGeoPoint","addPolygon","addArray","addObject","toPointer","deleteField","__op","deleteIndex","DefaultController","send","method","RESTController","getRESTController","request","useMasterKey","setSchemaController","_default"],"sources":["/home/mavrik/Documents/github/pokemon/node_modules/parse/lib/browser/ParseSchema.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _ParseCLP = _interopRequireDefault(require(\"./ParseCLP\"));\nconst FIELD_TYPES = ['String', 'Number', 'Boolean', 'Bytes', 'Date', 'File', 'GeoPoint', 'Polygon', 'Array', 'Object', 'Pointer', 'Relation'];\n/**\n * A Parse.Schema object is for handling schema data from Parse.\n * <p>All the schemas methods require MasterKey.\n *\n * When adding fields, you may set required and default values. (Requires Parse Server 3.7.0+)\n *\n * <pre>\n * const options = { required: true, defaultValue: 'hello world' };\n * const schema = new Parse.Schema('MyClass');\n * schema.addString('field', options);\n * schema.addIndex('index_name', { 'field': 1 });\n * schema.save();\n * </pre>\n * </p>\n *\n * @alias Parse.Schema\n */\nclass ParseSchema {\n  /**\n   * @param {string} className Parse Class string.\n   */\n  constructor(className) {\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_fields\", void 0);\n    (0, _defineProperty2.default)(this, \"_indexes\", void 0);\n    (0, _defineProperty2.default)(this, \"_clp\", void 0);\n    if (typeof className === 'string') {\n      if (className === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = className;\n      }\n    }\n    this._fields = {};\n    this._indexes = {};\n  }\n\n  /**\n   * Static method to get all schemas\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  static all() {\n    const controller = _CoreManager.default.getSchemaController();\n    return controller.get('').then(response => {\n      if (response.results.length === 0) {\n        throw new Error('Schema not found.');\n      }\n      return response.results;\n    });\n  }\n\n  /**\n   * Get the Schema from Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  get() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    return controller.get(this.className).then(response => {\n      if (!response) {\n        throw new Error('Schema not found.');\n      }\n      return response;\n    });\n  }\n\n  /**\n   * Create a new Schema on Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  save() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    const params = {\n      className: this.className,\n      fields: this._fields,\n      indexes: this._indexes,\n      classLevelPermissions: this._clp\n    };\n    return controller.create(this.className, params);\n  }\n\n  /**\n   * Update a Schema on Parse\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  update() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    const params = {\n      className: this.className,\n      fields: this._fields,\n      indexes: this._indexes,\n      classLevelPermissions: this._clp\n    };\n    this._fields = {};\n    this._indexes = {};\n    return controller.update(this.className, params);\n  }\n\n  /**\n   * Removing a Schema from Parse\n   * Can only be used on Schema without objects\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  delete() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    return controller.delete(this.className);\n  }\n\n  /**\n   * Removes all objects from a Schema (class) in Parse.\n   * EXERCISE CAUTION, running this will delete all objects for this schema and cannot be reversed\n   *\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  purge() {\n    this.assertClassName();\n    const controller = _CoreManager.default.getSchemaController();\n    return controller.purge(this.className);\n  }\n\n  /**\n   * Assert if ClassName has been filled\n   *\n   * @private\n   */\n  assertClassName() {\n    if (!this.className) {\n      throw new Error('You must set a Class Name before making any request.');\n    }\n  }\n\n  /**\n   * Sets Class Level Permissions when creating / updating a Schema.\n   * EXERCISE CAUTION, running this may override CLP for this schema and cannot be reversed\n   *\n   * @param {object | Parse.CLP} clp Class Level Permissions\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  setCLP(clp) {\n    if (clp instanceof _ParseCLP.default) {\n      this._clp = clp.toJSON();\n    } else {\n      this._clp = clp;\n    }\n    return this;\n  }\n\n  /**\n   * Adding a Field to Create / Update a Schema\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} type Can be a (String|Number|Boolean|Date|Parse.File|Parse.GeoPoint|Array|Object|Pointer|Parse.Relation)\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>required: If field is not set, save operation fails (Requires Parse Server 3.7.0+)\n   *   <li>defaultValue: If field is not set, a default value is selected (Requires Parse Server 3.7.0+)\n   *   <li>targetClass: Required if type is Pointer or Parse.Relation\n   * </ul>\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addField(name, type) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    type = type || 'String';\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n    if ((0, _indexOf.default)(FIELD_TYPES).call(FIELD_TYPES, type) === -1) {\n      throw new Error(`${type} is not a valid type.`);\n    }\n    if (type === 'Pointer') {\n      return this.addPointer(name, options.targetClass, options);\n    }\n    if (type === 'Relation') {\n      return this.addRelation(name, options.targetClass);\n    }\n    const fieldOptions = {\n      type\n    };\n    if (typeof options.required === 'boolean') {\n      fieldOptions.required = options.required;\n    }\n    if (options.defaultValue !== undefined) {\n      fieldOptions.defaultValue = options.defaultValue;\n    }\n    if (type === 'Date') {\n      if (options && options.defaultValue) {\n        fieldOptions.defaultValue = {\n          __type: 'Date',\n          iso: new Date(options.defaultValue)\n        };\n      }\n    }\n    if (type === 'Bytes') {\n      if (options && options.defaultValue) {\n        fieldOptions.defaultValue = {\n          __type: 'Bytes',\n          base64: options.defaultValue\n        };\n      }\n    }\n    this._fields[name] = fieldOptions;\n    return this;\n  }\n\n  /**\n   * Adding an Index to Create / Update a Schema\n   *\n   * @param {string} name Name of the index\n   * @param {object} index { field: value }\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   *\n   * <pre>\n   * schema.addIndex('index_name', { 'field': 1 });\n   * </pre>\n   */\n  addIndex(name, index) {\n    if (!name) {\n      throw new Error('index name may not be null.');\n    }\n    if (!index) {\n      throw new Error('index may not be null.');\n    }\n    this._indexes[name] = index;\n    return this;\n  }\n\n  /**\n   * Adding String Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addString(name, options) {\n    return this.addField(name, 'String', options);\n  }\n\n  /**\n   * Adding Number Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addNumber(name, options) {\n    return this.addField(name, 'Number', options);\n  }\n\n  /**\n   * Adding Boolean Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addBoolean(name, options) {\n    return this.addField(name, 'Boolean', options);\n  }\n\n  /**\n   * Adding Bytes Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addBytes(name, options) {\n    return this.addField(name, 'Bytes', options);\n  }\n\n  /**\n   * Adding Date Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addDate(name, options) {\n    return this.addField(name, 'Date', options);\n  }\n\n  /**\n   * Adding File Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addFile(name, options) {\n    return this.addField(name, 'File', options);\n  }\n\n  /**\n   * Adding GeoPoint Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addGeoPoint(name, options) {\n    return this.addField(name, 'GeoPoint', options);\n  }\n\n  /**\n   * Adding Polygon Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addPolygon(name, options) {\n    return this.addField(name, 'Polygon', options);\n  }\n\n  /**\n   * Adding Array Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addArray(name, options) {\n    return this.addField(name, 'Array', options);\n  }\n\n  /**\n   * Adding Object Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addObject(name, options) {\n    return this.addField(name, 'Object', options);\n  }\n\n  /**\n   * Adding Pointer Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} targetClass Name of the target Pointer Class\n   * @param {object} options See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Schema.html#addField addField}\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addPointer(name, targetClass) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n    if (!targetClass) {\n      throw new Error('You need to set the targetClass of the Pointer.');\n    }\n    const fieldOptions = {\n      type: 'Pointer',\n      targetClass\n    };\n    if (typeof options.required === 'boolean') {\n      fieldOptions.required = options.required;\n    }\n    if (options.defaultValue !== undefined) {\n      fieldOptions.defaultValue = options.defaultValue;\n      if (options.defaultValue instanceof _ParseObject.default) {\n        fieldOptions.defaultValue = options.defaultValue.toPointer();\n      }\n    }\n    this._fields[name] = fieldOptions;\n    return this;\n  }\n\n  /**\n   * Adding Relation Field\n   *\n   * @param {string} name Name of the field that will be created on Parse\n   * @param {string} targetClass Name of the target Pointer Class\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  addRelation(name, targetClass) {\n    if (!name) {\n      throw new Error('field name may not be null.');\n    }\n    if (!targetClass) {\n      throw new Error('You need to set the targetClass of the Relation.');\n    }\n    this._fields[name] = {\n      type: 'Relation',\n      targetClass\n    };\n    return this;\n  }\n\n  /**\n   * Deleting a Field to Update on a Schema\n   *\n   * @param {string} name Name of the field\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  deleteField(name) {\n    this._fields[name] = {\n      __op: 'Delete'\n    };\n    return this;\n  }\n\n  /**\n   * Deleting an Index to Update on a Schema\n   *\n   * @param {string} name Name of the field\n   * @returns {Parse.Schema} Returns the schema, so you can chain this call.\n   */\n  deleteIndex(name) {\n    this._indexes[name] = {\n      __op: 'Delete'\n    };\n    return this;\n  }\n}\nconst DefaultController = {\n  send(className, method) {\n    let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request(method, `schemas/${className}`, params, {\n      useMasterKey: true\n    });\n  },\n  get(className) {\n    return this.send(className, 'GET');\n  },\n  create(className, params) {\n    return this.send(className, 'POST', params);\n  },\n  update(className, params) {\n    return this.send(className, 'PUT', params);\n  },\n  delete(className) {\n    return this.send(className, 'DELETE');\n  },\n  purge(className) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('DELETE', `purge/${className}`, {}, {\n      useMasterKey: true\n    });\n  }\n};\n_CoreManager.default.setSchemaController(DefaultController);\nvar _default = exports.default = ParseSchema;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}