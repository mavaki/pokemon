{"ast":null,"code":"\"use strict\";\n\nvar _WeakMap = require(\"@babel/runtime-corejs3/core-js-stable/weak-map\");\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _freeze = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/freeze\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _getPrototypeOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/get-prototype-of\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\nvar _defineProperty3 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _canBeSerialized = _interopRequireDefault(require(\"./canBeSerialized\"));\nvar _decode = _interopRequireDefault(require(\"./decode\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _escape = _interopRequireDefault(require(\"./escape\"));\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\nvar _parseDate = _interopRequireDefault(require(\"./parseDate\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\nvar _uuid = _interopRequireDefault(require(\"./uuid\"));\nvar _ParseOp = require(\"./ParseOp\");\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\nvar SingleInstanceStateController = _interopRequireWildcard(require(\"./SingleInstanceStateController\"));\nvar _unique = _interopRequireDefault(require(\"./unique\"));\nvar UniqueInstanceStateController = _interopRequireWildcard(require(\"./UniqueInstanceStateController\"));\nvar _unsavedChildren = _interopRequireDefault(require(\"./unsavedChildren\"));\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof _WeakMap) return null;\n  var r = new _WeakMap(),\n    t = new _WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n    __proto__: null\n  };\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = _Object$defineProperty2 && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? _Object$defineProperty2(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\n// Mapping of class names to constructors, so we can populate objects from the\n// server with appropriate subclasses of ParseObject\nconst classMap = {};\n\n// Global counter for generating unique Ids for non-single-instance objects\nlet objectCount = 0;\n// On web clients, objects are single-instance: any two objects with the same Id\n// will have the same attributes. However, this may be dangerous default\n// behavior in a server scenario\nlet singleInstance = !_CoreManager.default.get('IS_NODE');\nif (singleInstance) {\n  _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n} else {\n  _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n}\nfunction getServerUrlPath() {\n  let serverUrl = _CoreManager.default.get('SERVER_URL');\n  if (serverUrl[serverUrl.length - 1] !== '/') {\n    serverUrl += '/';\n  }\n  const url = serverUrl.replace(/https?:\\/\\//, '');\n  return url.substr((0, _indexOf.default)(url).call(url, '/'));\n}\n\n/**\n * Creates a new model with defined attributes.\n *\n * <p>You won't normally call this method directly.  It is recommended that\n * you use a subclass of <code>Parse.Object</code> instead, created by calling\n * <code>extend</code>.</p>\n *\n * <p>However, if you don't want to use a subclass, or aren't sure which\n * subclass is appropriate, you can use this form:<pre>\n *     var object = new Parse.Object(\"ClassName\");\n * </pre>\n * That is basically equivalent to:<pre>\n *     var MyClass = Parse.Object.extend(\"ClassName\");\n *     var object = new MyClass();\n * </pre></p>\n *\n * @alias Parse.Object\n */\nclass ParseObject {\n  /**\n   * @param {string} className The class name for the object\n   * @param {object} attributes The initial set of data to store in the object.\n   * @param {object} options The options for this object instance.\n   * @param {boolean} [options.ignoreValidation] Set to `true` ignore any attribute validation errors.\n   */\n  constructor(className, attributes, options) {\n    /**\n     * The ID of this object, unique within its class.\n     *\n     * @property {string} id\n     */\n    (0, _defineProperty2.default)(this, \"id\", void 0);\n    (0, _defineProperty2.default)(this, \"_localId\", void 0);\n    (0, _defineProperty2.default)(this, \"_objCount\", void 0);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    // Enable legacy initializers\n    if (typeof this.initialize === 'function') {\n      this.initialize.apply(this, arguments);\n    }\n    let toSet = null;\n    this._objCount = objectCount++;\n    if (typeof className === 'string') {\n      this.className = className;\n      if (attributes && typeof attributes === 'object') {\n        toSet = attributes;\n      }\n    } else if (className && typeof className === 'object') {\n      this.className = className.className;\n      toSet = {};\n      for (const attr in className) {\n        if (attr !== 'className') {\n          toSet[attr] = className[attr];\n        }\n      }\n      if (attributes && typeof attributes === 'object') {\n        options = attributes;\n      }\n    }\n    if (toSet && !this.set(toSet, options)) {\n      throw new Error(\"Can't create an invalid Parse Object\");\n    }\n  }\n  /* Prototype getters / setters */\n\n  get attributes() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return (0, _freeze.default)(stateController.estimateAttributes(this._getStateIdentifier()));\n  }\n\n  /**\n   * The first time this object was saved on the server.\n   *\n   * @property {Date} createdAt\n   * @returns {Date}\n   */\n  get createdAt() {\n    return this._getServerData().createdAt;\n  }\n\n  /**\n   * The last time this object was updated on the server.\n   *\n   * @property {Date} updatedAt\n   * @returns {Date}\n   */\n  get updatedAt() {\n    return this._getServerData().updatedAt;\n  }\n\n  /* Private methods */\n\n  /**\n   * Returns a local or server Id used uniquely identify this object\n   *\n   * @returns {string}\n   */\n  _getId() {\n    if (typeof this.id === 'string') {\n      return this.id;\n    }\n    if (typeof this._localId === 'string') {\n      return this._localId;\n    }\n    const localId = 'local' + (0, _uuid.default)();\n    this._localId = localId;\n    return localId;\n  }\n\n  /**\n   * Returns a unique identifier used to pull data from the State Controller.\n   *\n   * @returns {Parse.Object|object}\n   */\n  _getStateIdentifier() {\n    if (singleInstance) {\n      let id = this.id;\n      if (!id) {\n        id = this._getId();\n      }\n      return {\n        id: id,\n        className: this.className\n      };\n    } else {\n      return this;\n    }\n  }\n  _getServerData() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return stateController.getServerData(this._getStateIdentifier());\n  }\n  _clearServerData() {\n    const serverData = this._getServerData();\n    const unset = {};\n    for (const attr in serverData) {\n      unset[attr] = undefined;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.setServerData(this._getStateIdentifier(), unset);\n  }\n  _getPendingOps() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return stateController.getPendingOps(this._getStateIdentifier());\n  }\n\n  /**\n   * @param {Array<string>} [keysToClear] - if specified, only ops matching\n   * these fields will be cleared\n   */\n  _clearPendingOps(keysToClear) {\n    const pending = this._getPendingOps();\n    const latest = pending[pending.length - 1];\n    const keys = keysToClear || (0, _keys.default)(latest);\n    (0, _forEach.default)(keys).call(keys, key => {\n      delete latest[key];\n    });\n  }\n  _getDirtyObjectAttributes() {\n    const attributes = this.attributes;\n    const stateController = _CoreManager.default.getObjectStateController();\n    const objectCache = stateController.getObjectCache(this._getStateIdentifier());\n    const dirty = {};\n    for (const attr in attributes) {\n      const val = attributes[attr];\n      if (val && typeof val === 'object' && !(val instanceof ParseObject) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {\n        // Due to the way browsers construct maps, the key order will not change\n        // unless the object is changed\n        try {\n          const json = (0, _encode.default)(val, false, true);\n          const stringified = (0, _stringify.default)(json);\n          if (objectCache[attr] !== stringified) {\n            dirty[attr] = val;\n          }\n        } catch (e) {\n          // Error occurred, possibly by a nested unsaved pointer in a mutable container\n          // No matter how it happened, it indicates a change in the attribute\n          dirty[attr] = val;\n        }\n      }\n    }\n    return dirty;\n  }\n  _toFullJSON(seen, offline) {\n    const json = this.toJSON(seen, offline);\n    json.__type = 'Object';\n    json.className = this.className;\n    return json;\n  }\n  _getSaveJSON() {\n    const pending = this._getPendingOps();\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    const json = {};\n    for (var attr in dirtyObjects) {\n      let isDotNotation = false;\n      for (let i = 0; i < pending.length; i += 1) {\n        for (const field in pending[i]) {\n          // Dot notation operations are handled later\n          if ((0, _includes.default)(field).call(field, '.')) {\n            const fieldName = field.split('.')[0];\n            if (fieldName === attr) {\n              isDotNotation = true;\n              break;\n            }\n          }\n        }\n      }\n      if (!isDotNotation) {\n        json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();\n      }\n    }\n    for (attr in pending[0]) {\n      json[attr] = pending[0][attr].toJSON();\n    }\n    return json;\n  }\n  _getSaveParams() {\n    let method = this.id ? 'PUT' : 'POST';\n    const body = this._getSaveJSON();\n    let path = 'classes/' + this.className;\n    if (_CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID')) {\n      if (!this.createdAt) {\n        method = 'POST';\n        body.objectId = this.id;\n      } else {\n        method = 'PUT';\n        path += '/' + this.id;\n      }\n    } else if (this.id) {\n      path += '/' + this.id;\n    } else if (this.className === '_User') {\n      path = 'users';\n    }\n    return {\n      method,\n      body,\n      path\n    };\n  }\n  _finishFetch(serverData) {\n    if (!this.id && serverData.objectId) {\n      this.id = serverData.objectId;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.initializeState(this._getStateIdentifier());\n    const decoded = {};\n    for (const attr in serverData) {\n      if (attr === 'ACL') {\n        decoded[attr] = new _ParseACL.default(serverData[attr]);\n      } else if (attr !== 'objectId') {\n        decoded[attr] = (0, _decode.default)(serverData[attr]);\n        if (decoded[attr] instanceof _ParseRelation.default) {\n          decoded[attr]._ensureParentAndKey(this, attr);\n        }\n      }\n    }\n    if (decoded.createdAt && typeof decoded.createdAt === 'string') {\n      decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);\n    }\n    if (decoded.updatedAt && typeof decoded.updatedAt === 'string') {\n      decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);\n    }\n    if (!decoded.updatedAt && decoded.createdAt) {\n      decoded.updatedAt = decoded.createdAt;\n    }\n    stateController.commitServerChanges(this._getStateIdentifier(), decoded);\n  }\n  _setExisted(existed) {\n    const stateController = _CoreManager.default.getObjectStateController();\n    const state = stateController.getState(this._getStateIdentifier());\n    if (state) {\n      state.existed = existed;\n    }\n  }\n  _migrateId(serverId) {\n    if (this._localId && serverId) {\n      if (singleInstance) {\n        const stateController = _CoreManager.default.getObjectStateController();\n        const oldState = stateController.removeState(this._getStateIdentifier());\n        this.id = serverId;\n        delete this._localId;\n        if (oldState) {\n          stateController.initializeState(this._getStateIdentifier(), oldState);\n        }\n      } else {\n        this.id = serverId;\n        delete this._localId;\n      }\n    }\n  }\n  _handleSaveResponse(response, status) {\n    const changes = {};\n    const stateController = _CoreManager.default.getObjectStateController();\n    const pending = stateController.popPendingState(this._getStateIdentifier());\n    for (var attr in pending) {\n      if (pending[attr] instanceof _ParseOp.RelationOp) {\n        changes[attr] = pending[attr].applyTo(undefined, this, attr);\n      } else if (!(attr in response)) {\n        // Only SetOps and UnsetOps should not come back with results\n        changes[attr] = pending[attr].applyTo(undefined);\n      }\n    }\n    for (attr in response) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && typeof response[attr] === 'string') {\n        changes[attr] = (0, _parseDate.default)(response[attr]);\n      } else if (attr === 'ACL') {\n        changes[attr] = new _ParseACL.default(response[attr]);\n      } else if (attr !== 'objectId') {\n        const val = (0, _decode.default)(response[attr]);\n        if (val && (0, _getPrototypeOf.default)(val) === Object.prototype) {\n          changes[attr] = {\n            ...this.attributes[attr],\n            ...val\n          };\n        } else {\n          changes[attr] = val;\n        }\n        if (changes[attr] instanceof _ParseOp.UnsetOp) {\n          changes[attr] = undefined;\n        }\n      }\n    }\n    if (changes.createdAt && !changes.updatedAt) {\n      changes.updatedAt = changes.createdAt;\n    }\n    this._migrateId(response.objectId);\n    if (status !== 201) {\n      this._setExisted(true);\n    }\n    stateController.commitServerChanges(this._getStateIdentifier(), changes);\n  }\n  _handleSaveError() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.mergeFirstPendingState(this._getStateIdentifier());\n  }\n  static _getClassMap() {\n    return classMap;\n  }\n\n  /* Public methods */\n\n  initialize() {\n    // NOOP\n  }\n\n  /**\n   * Returns a JSON version of the object suitable for saving to Parse.\n   *\n   * @param seen\n   * @param offline\n   * @returns {object}\n   */\n  toJSON(seen, offline) {\n    const seenEntry = this.id ? this.className + ':' + this.id : this;\n    seen = seen || [seenEntry];\n    const json = {};\n    const attrs = this.attributes;\n    for (const attr in attrs) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && attrs[attr].toJSON) {\n        json[attr] = attrs[attr].toJSON();\n      } else {\n        json[attr] = (0, _encode.default)(attrs[attr], false, false, seen, offline);\n      }\n    }\n    const pending = this._getPendingOps();\n    for (const attr in pending[0]) {\n      if ((0, _indexOf.default)(attr).call(attr, '.') < 0) {\n        json[attr] = pending[0][attr].toJSON(offline);\n      }\n    }\n    if (this.id) {\n      json.objectId = this.id;\n    }\n    return json;\n  }\n\n  /**\n   * Determines whether this ParseObject is equal to another ParseObject\n   *\n   * @param {object} other - An other object ot compare\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    return other instanceof ParseObject && this.className === other.className && this.id === other.id && typeof this.id !== 'undefined';\n  }\n\n  /**\n   * Returns true if this object has been modified since its last\n   * save/refresh.  If an attribute is specified, it returns true only if that\n   * particular attribute has been modified since the last save/refresh.\n   *\n   * @param {string} attr An attribute name (optional).\n   * @returns {boolean}\n   */\n  dirty(attr) {\n    if (!this.id) {\n      return true;\n    }\n    const pendingOps = this._getPendingOps();\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    if (attr) {\n      if (dirtyObjects.hasOwnProperty(attr)) {\n        return true;\n      }\n      for (let i = 0; i < pendingOps.length; i++) {\n        if (pendingOps[i].hasOwnProperty(attr)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if ((0, _keys.default)(pendingOps[0]).length !== 0) {\n      return true;\n    }\n    if ((0, _keys.default)(dirtyObjects).length !== 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns an array of keys that have been modified since last save/refresh\n   *\n   * @returns {string[]}\n   */\n  dirtyKeys() {\n    const pendingOps = this._getPendingOps();\n    const keys = {};\n    for (let i = 0; i < pendingOps.length; i++) {\n      for (const attr in pendingOps[i]) {\n        keys[attr] = true;\n      }\n    }\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    for (const attr in dirtyObjects) {\n      keys[attr] = true;\n    }\n    return (0, _keys.default)(keys);\n  }\n\n  /**\n   * Returns true if the object has been fetched.\n   *\n   * @returns {boolean}\n   */\n  isDataAvailable() {\n    const serverData = this._getServerData();\n    return !!(0, _keys.default)(serverData).length;\n  }\n\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n  toPointer() {\n    if (!this.id) {\n      throw new Error('Cannot create a pointer to an unsaved ParseObject');\n    }\n    return {\n      __type: 'Pointer',\n      className: this.className,\n      objectId: this.id\n    };\n  }\n\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n  toOfflinePointer() {\n    if (!this._localId) {\n      throw new Error('Cannot create a offline pointer to a saved ParseObject');\n    }\n    return {\n      __type: 'Object',\n      className: this.className,\n      _localId: this._localId\n    };\n  }\n\n  /**\n   * Gets the value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {*}\n   */\n  get(attr) {\n    return this.attributes[attr];\n  }\n\n  /**\n   * Gets a relation on the given class for the attribute.\n   *\n   * @param {string} attr The attribute to get the relation for.\n   * @returns {Parse.Relation}\n   */\n  relation(attr) {\n    const value = this.get(attr);\n    if (value) {\n      if (!(value instanceof _ParseRelation.default)) {\n        throw new Error('Called relation() on non-relation field ' + attr);\n      }\n      value._ensureParentAndKey(this, attr);\n      return value;\n    }\n    return new _ParseRelation.default(this, attr);\n  }\n\n  /**\n   * Gets the HTML-escaped value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {string}\n   */\n  escape(attr) {\n    let val = this.attributes[attr];\n    if (val == null) {\n      return '';\n    }\n    if (typeof val !== 'string') {\n      if (typeof val.toString !== 'function') {\n        return '';\n      }\n      val = val.toString();\n    }\n    return (0, _escape.default)(val);\n  }\n\n  /**\n   * Returns <code>true</code> if the attribute contains a value that is not\n   * null or undefined.\n   *\n   * @param {string} attr The string name of the attribute.\n   * @returns {boolean}\n   */\n  has(attr) {\n    const attributes = this.attributes;\n    if (attributes.hasOwnProperty(attr)) {\n      return attributes[attr] != null;\n    }\n    return false;\n  }\n\n  /**\n   * Sets a hash of model attributes on the object.\n   *\n   * <p>You can call it with an object containing keys and values, with one\n   * key and value, or dot notation.  For example:<pre>\n   *   gameTurn.set({\n   *     player: player1,\n   *     diceRoll: 2\n   *   }, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"currentPlayer\", player2, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"finished\", true);</pre></p>\n   *\n   *   game.set(\"player.score\", 10);</pre></p>\n   *\n   * @param {(string|object)} key The key to set.\n   * @param {(string|object)} value The value to give it.\n   * @param {object} options A set of options for the set.\n   *     The only supported option is <code>error</code>.\n   * @returns {(ParseObject|boolean)} true if the set succeeded.\n   */\n  set(key, value, options) {\n    let changes = {};\n    const newOps = {};\n    if (key && typeof key === 'object') {\n      changes = key;\n      options = value;\n    } else if (typeof key === 'string') {\n      changes[key] = value;\n    } else {\n      return this;\n    }\n    options = options || {};\n    let readonly = [];\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());\n    }\n    for (const k in changes) {\n      if (k === 'createdAt' || k === 'updatedAt') {\n        // This property is read-only, but for legacy reasons we silently\n        // ignore it\n        continue;\n      }\n      if ((0, _indexOf.default)(readonly).call(readonly, k) > -1) {\n        throw new Error('Cannot modify readonly attribute: ' + k);\n      }\n      if (options.unset) {\n        newOps[k] = new _ParseOp.UnsetOp();\n      } else if (changes[k] instanceof _ParseOp.Op) {\n        newOps[k] = changes[k];\n      } else if (changes[k] && typeof changes[k] === 'object' && typeof changes[k].__op === 'string') {\n        newOps[k] = (0, _ParseOp.opFromJSON)(changes[k]);\n      } else if (k === 'objectId' || k === 'id') {\n        if (typeof changes[k] === 'string') {\n          this.id = changes[k];\n        }\n      } else if (k === 'ACL' && typeof changes[k] === 'object' && !(changes[k] instanceof _ParseACL.default)) {\n        newOps[k] = new _ParseOp.SetOp(new _ParseACL.default(changes[k]));\n      } else if (changes[k] instanceof _ParseRelation.default) {\n        const relation = new _ParseRelation.default(this, k);\n        relation.targetClassName = changes[k].targetClassName;\n        newOps[k] = new _ParseOp.SetOp(relation);\n      } else {\n        newOps[k] = new _ParseOp.SetOp(changes[k]);\n      }\n    }\n    const currentAttributes = this.attributes;\n\n    // Calculate new values\n    const newValues = {};\n    for (const attr in newOps) {\n      if (newOps[attr] instanceof _ParseOp.RelationOp) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr], this, attr);\n      } else if (!(newOps[attr] instanceof _ParseOp.UnsetOp)) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr]);\n      }\n    }\n\n    // Validate changes\n    if (!options.ignoreValidation) {\n      const validation = this.validate(newValues);\n      if (validation) {\n        if (typeof options.error === 'function') {\n          options.error(this, validation);\n        }\n        return false;\n      }\n    }\n\n    // Consolidate Ops\n    const pendingOps = this._getPendingOps();\n    const last = pendingOps.length - 1;\n    const stateController = _CoreManager.default.getObjectStateController();\n    for (const attr in newOps) {\n      const nextOp = newOps[attr].mergeWith(pendingOps[last][attr]);\n      stateController.setPendingOp(this._getStateIdentifier(), attr, nextOp);\n    }\n    return this;\n  }\n\n  /**\n   * Remove an attribute from the model. This is a noop if the attribute doesn't\n   * exist.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @param options\n   * @returns {(ParseObject | boolean)}\n   */\n  unset(attr, options) {\n    options = options || {};\n    options.unset = true;\n    return this.set(attr, null, options);\n  }\n\n  /**\n   * Atomically increments the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to increment by (optional).\n   * @returns {(ParseObject|boolean)}\n   */\n  increment(attr, amount) {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot increment by a non-numeric amount.');\n    }\n    return this.set(attr, new _ParseOp.IncrementOp(amount));\n  }\n\n  /**\n   * Atomically decrements the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to decrement by (optional).\n   * @returns {(ParseObject | boolean)}\n   */\n  decrement(attr, amount) {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot decrement by a non-numeric amount.');\n    }\n    return this.set(attr, new _ParseOp.IncrementOp(amount * -1));\n  }\n\n  /**\n   * Atomically add an object to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The item to add.\n   * @returns {(ParseObject | boolean)}\n   */\n  add(attr, item) {\n    return this.set(attr, new _ParseOp.AddOp([item]));\n  }\n\n  /**\n   * Atomically add the objects to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The items to add.\n   * @returns {(ParseObject | boolean)}\n   */\n  addAll(attr, items) {\n    return this.set(attr, new _ParseOp.AddOp(items));\n  }\n\n  /**\n   * Atomically add an object to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to add.\n   * @returns {(ParseObject | boolean)}\n   */\n  addUnique(attr, item) {\n    return this.set(attr, new _ParseOp.AddUniqueOp([item]));\n  }\n\n  /**\n   * Atomically add the objects to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The objects to add.\n   * @returns {(ParseObject | boolean)}\n   */\n  addAllUnique(attr, items) {\n    return this.set(attr, new _ParseOp.AddUniqueOp(items));\n  }\n\n  /**\n   * Atomically remove all instances of an object from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to remove.\n   * @returns {(ParseObject | boolean)}\n   */\n  remove(attr, item) {\n    return this.set(attr, new _ParseOp.RemoveOp([item]));\n  }\n\n  /**\n   * Atomically remove all instances of the objects from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The object to remove.\n   * @returns {(ParseObject | boolean)}\n   */\n  removeAll(attr, items) {\n    return this.set(attr, new _ParseOp.RemoveOp(items));\n  }\n\n  /**\n   * Returns an instance of a subclass of Parse.Op describing what kind of\n   * modification has been performed on this field since the last time it was\n   * saved. For example, after calling object.increment(\"x\"), calling\n   * object.op(\"x\") would return an instance of Parse.Op.Increment.\n   *\n   * @param attr {String} The key.\n   * @returns {Parse.Op | undefined} The operation, or undefined if none.\n   */\n  op(attr) {\n    const pending = this._getPendingOps();\n    for (let i = pending.length; i--;) {\n      if (pending[i][attr]) {\n        return pending[i][attr];\n      }\n    }\n  }\n\n  /**\n   * Creates a new model with identical attributes to this one.\n   *\n   * @returns {Parse.Object}\n   */\n  clone() {\n    const clone = new this.constructor(this.className);\n    let attributes = this.attributes;\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      const readonly = this.constructor.readOnlyAttributes() || [];\n      // Attributes are frozen, so we have to rebuild an object,\n      // rather than delete readonly keys\n      const copy = {};\n      for (const a in attributes) {\n        if ((0, _indexOf.default)(readonly).call(readonly, a) < 0) {\n          copy[a] = attributes[a];\n        }\n      }\n      attributes = copy;\n    }\n    if (clone.set) {\n      clone.set(attributes);\n    }\n    return clone;\n  }\n\n  /**\n   * Creates a new instance of this object. Not to be confused with clone()\n   *\n   * @returns {Parse.Object}\n   */\n  newInstance() {\n    const clone = new this.constructor(this.className);\n    clone.id = this.id;\n    if (singleInstance) {\n      // Just return an object with the right id\n      return clone;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    if (stateController) {\n      stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());\n    }\n    return clone;\n  }\n\n  /**\n   * Returns true if this object has never been saved to Parse.\n   *\n   * @returns {boolean}\n   */\n  isNew() {\n    return !this.id;\n  }\n\n  /**\n   * Returns true if this object was created by the Parse server when the\n   * object might have already been there (e.g. in the case of a Facebook\n   * login)\n   *\n   * @returns {boolean}\n   */\n  existed() {\n    if (!this.id) {\n      return false;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    const state = stateController.getState(this._getStateIdentifier());\n    if (state) {\n      return state.existed;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this object exists on the Server\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object exists.\n   */\n  async exists(options) {\n    if (!this.id) {\n      return false;\n    }\n    try {\n      const ParseQuery = _CoreManager.default.getParseQuery();\n      const query = new ParseQuery(this.className);\n      await query.get(this.id, options);\n      return true;\n    } catch (e) {\n      if (e.code === _ParseError.default.OBJECT_NOT_FOUND) {\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Checks if the model is currently in a valid state.\n   *\n   * @returns {boolean}\n   */\n  isValid() {\n    return !this.validate(this.attributes);\n  }\n\n  /**\n   * You should not call this function directly unless you subclass\n   * <code>Parse.Object</code>, in which case you can override this method\n   * to provide additional validation on <code>set</code> and\n   * <code>save</code>.  Your implementation should return\n   *\n   * @param {object} attrs The current data to validate.\n   * @returns {Parse.Error|boolean} False if the data is valid.  An error object otherwise.\n   * @see Parse.Object#set\n   */\n  validate(attrs) {\n    if (attrs.hasOwnProperty('ACL') && !(attrs.ACL instanceof _ParseACL.default)) {\n      return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'ACL must be a Parse ACL.');\n    }\n    for (const key in attrs) {\n      if (!/^[A-Za-z][0-9A-Za-z_.]*$/.test(key)) {\n        return new _ParseError.default(_ParseError.default.INVALID_KEY_NAME);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the ACL for this object.\n   *\n   * @returns {Parse.ACL|null} An instance of Parse.ACL.\n   * @see Parse.Object#get\n   */\n  getACL() {\n    const acl = this.get('ACL');\n    if (acl instanceof _ParseACL.default) {\n      return acl;\n    }\n    return null;\n  }\n\n  /**\n   * Sets the ACL to be used for this object.\n   *\n   * @param {Parse.ACL} acl An instance of Parse.ACL.\n   * @param {object} options\n   * @returns {(ParseObject | boolean)} Whether the set passed validation.\n   * @see Parse.Object#set\n   */\n  setACL(acl, options) {\n    return this.set('ACL', acl, options);\n  }\n\n  /**\n   * Clears any (or specific) changes to this object made since the last call to save()\n   *\n   * @param {string} [keys] - specify which fields to revert\n   */\n  revert() {\n    let keysToRevert;\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    if (keys.length) {\n      keysToRevert = [];\n      for (const key of keys) {\n        if (typeof key === 'string') {\n          keysToRevert.push(key);\n        } else {\n          throw new Error('Parse.Object#revert expects either no, or a list of string, arguments.');\n        }\n      }\n    }\n    this._clearPendingOps(keysToRevert);\n  }\n\n  /**\n   * Clears all attributes on a model\n   *\n   * @returns {(ParseObject | boolean)}\n   */\n  clear() {\n    const attributes = this.attributes;\n    const erasable = {};\n    let readonly = ['createdAt', 'updatedAt'];\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());\n    }\n    for (const attr in attributes) {\n      if ((0, _indexOf.default)(readonly).call(readonly, attr) < 0) {\n        erasable[attr] = true;\n      }\n    }\n    return this.set(erasable, {\n      unset: true\n    });\n  }\n\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n  fetch(options) {\n    options = options || {};\n    const fetchOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      fetchOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      fetchOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      fetchOptions.context = options.context;\n    }\n    if (options.hasOwnProperty('include')) {\n      fetchOptions.include = [];\n      if ((0, _isArray.default)(options.include)) {\n        var _context;\n        (0, _forEach.default)(_context = options.include).call(_context, key => {\n          if ((0, _isArray.default)(key)) {\n            var _context2;\n            fetchOptions.include = (0, _concat.default)(_context2 = fetchOptions.include).call(_context2, key);\n          } else {\n            fetchOptions.include.push(key);\n          }\n        });\n      } else {\n        fetchOptions.include.push(options.include);\n      }\n    }\n    const controller = _CoreManager.default.getObjectController();\n    return controller.fetch(this, true, fetchOptions);\n  }\n\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n  fetchWithInclude(keys, options) {\n    options = options || {};\n    options.include = keys;\n    return this.fetch(options);\n  }\n\n  /**\n   * Saves this object to the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection, and don't need to know when the save completes.\n   * If there is some problem with the object such that it can't be saved, it will be silently discarded.\n   *\n   * Objects saved with this method will be stored locally in an on-disk cache until they can be delivered to Parse.\n   * They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection is\n   * available. Objects saved this way will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n  async saveEventually(options) {\n    try {\n      await this.save(null, options);\n    } catch (e) {\n      if (e.code === _ParseError.default.CONNECTION_FAILED) {\n        await _CoreManager.default.getEventuallyQueue().save(this, options);\n        _CoreManager.default.getEventuallyQueue().poll();\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Set a hash of model attributes, and save the model to the server.\n   * updatedAt will be updated when the request returns.\n   * You can either call it as:<pre>\n   * object.save();</pre>\n   * or<pre>\n   * object.save(attrs);</pre>\n   * or<pre>\n   * object.save(null, options);</pre>\n   * or<pre>\n   * object.save(attrs, options);</pre>\n   * or<pre>\n   * object.save(key, value);</pre>\n   * or<pre>\n   * object.save(key, value, options);</pre>\n   *\n   * Example 1: <pre>\n   * gameTurn.save({\n   * player: \"Jake Cutter\",\n   * diceRoll: 2\n   * }).then(function(gameTurnAgain) {\n   * // The save was successful.\n   * }, function(error) {\n   * // The save failed.  Error is an instance of Parse.Error.\n   * });</pre>\n   *\n   * Example 2: <pre>\n   * gameTurn.save(\"player\", \"Jake Cutter\");</pre>\n   *\n   * @param {string | object | null} [arg1]\n   * Valid options are:<ul>\n   * <li>`Object` - Key/value pairs to update on the object.</li>\n   * <li>`String` Key - Key of attribute to update (requires arg2 to also be string)</li>\n   * <li>`null` - Passing null for arg1 allows you to save the object with options passed in arg2.</li>\n   * </ul>\n   * @param {string | object} [arg2]\n   * <ul>\n   * <li>`String` Value - If arg1 was passed as a key, arg2 is the value that should be set on that key.</li>\n   * <li>`Object` Options - Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * </li>\n   * </ul>\n   * @param {object} [arg3]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n  save(arg1, arg2, arg3) {\n    let attrs;\n    let options;\n    if (typeof arg1 === 'object' || typeof arg1 === 'undefined') {\n      attrs = arg1;\n      if (typeof arg2 === 'object') {\n        options = arg2;\n      }\n    } else {\n      attrs = {};\n      attrs[arg1] = arg2;\n      options = arg3;\n    }\n    options = options || {};\n    if (attrs) {\n      let validationError;\n      options.error = (_, validation) => {\n        validationError = validation;\n      };\n      const success = this.set(attrs, options);\n      if (!success) {\n        return _promise.default.reject(validationError);\n      }\n    }\n    const saveOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      saveOptions.useMasterKey = !!options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken') && typeof options.sessionToken === 'string') {\n      saveOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('installationId') && typeof options.installationId === 'string') {\n      saveOptions.installationId = options.installationId;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      saveOptions.context = options.context;\n    }\n    const controller = _CoreManager.default.getObjectController();\n    const unsaved = options.cascadeSave !== false ? (0, _unsavedChildren.default)(this) : null;\n    return controller.save(unsaved, saveOptions).then(() => {\n      return controller.save(this, saveOptions);\n    });\n  }\n\n  /**\n   * Deletes this object from the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection,\n   * and don't need to know when the delete completes. If there is some problem with the object\n   * such that it can't be deleted, the request will be silently discarded.\n   *\n   * Delete instructions made with this method will be stored locally in an on-disk cache until they can be transmitted\n   * to Parse. They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection\n   * is available. Delete requests will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n  async destroyEventually(options) {\n    try {\n      await this.destroy(options);\n    } catch (e) {\n      if (e.code === _ParseError.default.CONNECTION_FAILED) {\n        await _CoreManager.default.getEventuallyQueue().destroy(this, options);\n        _CoreManager.default.getEventuallyQueue().poll();\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Destroy this model on the server if it was already persisted.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n  destroy(options) {\n    options = options || {};\n    const destroyOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      destroyOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      destroyOptions.context = options.context;\n    }\n    if (!this.id) {\n      return _promise.default.resolve();\n    }\n    return _CoreManager.default.getObjectController().destroy(this, destroyOptions);\n  }\n\n  /**\n   * Asynchronously stores the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pin();\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n  pin() {\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await object.unPin();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n  unPin() {\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n\n  /**\n   * Asynchronously returns if the object is pinned\n   *\n   * <pre>\n   * const isPinned = await object.isPinned();\n   * </pre>\n   *\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object is pinned.\n   */\n  async isPinned() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pin = await localDatastore.fromPinWithName(objectKey);\n    return pin.length > 0;\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pinWithName(name);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n  pinWithName(name) {\n    return ParseObject.pinAllWithName(name, [this]);\n  }\n\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore, recursively.\n   *\n   * <pre>\n   * await object.unPinWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n  unPinWithName(name) {\n    return ParseObject.unPinAllWithName(name, [this]);\n  }\n\n  /**\n   * Asynchronously loads data from the local datastore into this object.\n   *\n   * <pre>\n   * await object.fetchFromLocalDatastore();\n   * </pre>\n   *\n   * You can create an unfetched pointer with <code>Parse.Object.createWithoutData()</code>\n   * and then call <code>fetchFromLocalDatastore()</code> on it.\n   *\n   * @returns {Promise} A promise that is fulfilled when the fetch completes.\n   */\n  async fetchFromLocalDatastore() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      throw new Error('Parse.enableLocalDatastore() must be called first');\n    }\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pinned = await localDatastore._serializeObject(objectKey);\n    if (!pinned) {\n      throw new Error('Cannot fetch an unsaved ParseObject');\n    }\n    const result = ParseObject.fromJSON(pinned);\n    this._finishFetch(result.toJSON());\n    return this;\n  }\n\n  /* Static methods */\n\n  static _clearAllState() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.clearAllState();\n  }\n\n  /**\n   * Fetches the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAll([object1, object2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAll(list) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const queryOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      queryOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      queryOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('include')) {\n      queryOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n    return _CoreManager.default.getObjectController().fetch(list, true, queryOptions);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllWithInclude(list, keys, options) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAll(list, options);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeededWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllIfNeededWithInclude(list, keys, options) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAllIfNeeded(list, options);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeeded([object1, ...])\n   *    .then((list) => {\n   *      // Objects were fetched and updated.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllIfNeeded(list, options) {\n    options = options || {};\n    const queryOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      queryOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      queryOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('include')) {\n      queryOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n    return _CoreManager.default.getObjectController().fetch(list, false, queryOptions);\n  }\n  static handleIncludeOptions(options) {\n    let include = [];\n    if ((0, _isArray.default)(options.include)) {\n      var _context3;\n      (0, _forEach.default)(_context3 = options.include).call(_context3, key => {\n        if ((0, _isArray.default)(key)) {\n          include = (0, _concat.default)(include).call(include, key);\n        } else {\n          include.push(key);\n        }\n      });\n    } else {\n      include.push(options.include);\n    }\n    return include;\n  }\n\n  /**\n   * Destroy the given list of models on the server if it was already persisted.\n   *\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n   * this method will continue trying to delete the rest of the models if\n   * possible, except in the case of a fatal error like a connection error.\n   *\n   * <p>In particular, the Parse.Error object returned in the case of error may\n   * be one of two types:\n   *\n   * <ul>\n   * <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n   * array of other Parse.Error objects. Each error object in this array\n   * has an \"object\" property that references the object that could not be\n   * deleted (for instance, because that object could not be found).</li>\n   * <li>A non-aggregate Parse.Error. This indicates a serious error that\n   * caused the delete operation to be aborted partway through (for\n   * instance, a connection failure in the middle of the delete).</li>\n   * </ul>\n   *\n   * <pre>\n   * Parse.Object.destroyAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were deleted.\n   * }, (error) => {\n   * // An error occurred while deleting one or more of the objects.\n   * // If this is an aggregate error, then we can inspect each error\n   * // object individually to determine the reason why a particular\n   * // object was not deleted.\n   * if (error.code === Parse.Error.AGGREGATE_ERROR) {\n   * for (var i = 0; i < error.errors.length; i++) {\n   * console.log(\"Couldn't delete \" + error.errors[i].object.id +\n   * \"due to \" + error.errors[i].message);\n   * }\n   * } else {\n   * console.log(\"Delete aborted because of \" + error.message);\n   * }\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled when the destroyAll\n   * completes.\n   */\n  static destroyAll(list) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const destroyOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      destroyOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n      destroyOptions.batchSize = options.batchSize;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      destroyOptions.context = options.context;\n    }\n    return _CoreManager.default.getObjectController().destroy(list, destroyOptions);\n  }\n\n  /**\n   * Saves the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   * Parse.Object.saveAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were saved.\n   * }, (error) => {\n   * // An error occurred while saving one of the objects.\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static saveAll(list) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const saveOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      saveOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      saveOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n      saveOptions.batchSize = options.batchSize;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      saveOptions.context = options.context;\n    }\n    return _CoreManager.default.getObjectController().save(list, saveOptions);\n  }\n\n  /**\n   * Creates a reference to a subclass of Parse.Object with the given id. This\n   * does not exist on Parse.Object, only on subclasses.\n   *\n   * <p>A shortcut for: <pre>\n   *  var Foo = Parse.Object.extend(\"Foo\");\n   *  var pointerToFoo = new Foo();\n   *  pointerToFoo.id = \"myObjectId\";\n   * </pre>\n   *\n   * @param {string} id The ID of the object to create a reference to.\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference.\n   */\n  static createWithoutData(id) {\n    const obj = new this();\n    obj.id = id;\n    return obj;\n  }\n\n  /**\n   * Creates a new instance of a Parse Object from a JSON representation.\n   *\n   * @param {object} json The JSON map of the Object's data\n   * @param {boolean} override In single instance mode, all old server data\n   *   is overwritten if this is set to true\n   * @param {boolean} dirty Whether the Parse.Object should set JSON keys to dirty\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference\n   */\n  static fromJSON(json, override, dirty) {\n    if (!json.className) {\n      throw new Error('Cannot create an object without a className');\n    }\n    const constructor = classMap[json.className];\n    const o = constructor ? new constructor(json.className) : new ParseObject(json.className);\n    const otherAttributes = {};\n    for (const attr in json) {\n      if (attr !== 'className' && attr !== '__type') {\n        otherAttributes[attr] = json[attr];\n        if (dirty) {\n          o.set(attr, json[attr]);\n        }\n      }\n    }\n    if (override) {\n      // id needs to be set before clearServerData can work\n      if (otherAttributes.objectId) {\n        o.id = otherAttributes.objectId;\n      }\n      let preserved = null;\n      if (typeof o._preserveFieldsOnFetch === 'function') {\n        preserved = o._preserveFieldsOnFetch();\n      }\n      o._clearServerData();\n      if (preserved) {\n        o._finishFetch(preserved);\n      }\n    }\n    o._finishFetch(otherAttributes);\n    if (json.objectId) {\n      o._setExisted(true);\n    }\n    return o;\n  }\n\n  /**\n   * Registers a subclass of Parse.Object with a specific class name.\n   * When objects of that class are retrieved from a query, they will be\n   * instantiated with this subclass.\n   * This is only necessary when using ES6 subclassing.\n   *\n   * @param {string} className The class name of the subclass\n   * @param {Function} constructor The subclass\n   */\n  static registerSubclass(className, constructor) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n    if (typeof constructor === 'undefined') {\n      throw new TypeError('You must supply a subclass constructor.');\n    }\n    if (typeof constructor !== 'function') {\n      throw new TypeError('You must register the subclass constructor. ' + 'Did you attempt to register an instance of the subclass?');\n    }\n    classMap[className] = constructor;\n    if (!constructor.className) {\n      constructor.className = className;\n    }\n  }\n\n  /**\n   * Unegisters a subclass of Parse.Object with a specific class name.\n   *\n   * @param {string} className The class name of the subclass\n   */\n  static unregisterSubclass(className) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n    delete classMap[className];\n  }\n\n  /**\n   * Creates a new subclass of Parse.Object for the given Parse class name.\n   *\n   * <p>Every extension of a Parse class will inherit from the most recent\n   * previous extension of that class. When a Parse.Object is automatically\n   * created by parsing JSON, it will use the most recent extension of that\n   * class.</p>\n   *\n   * <p>You should call either:<pre>\n   *     var MyClass = Parse.Object.extend(\"MyClass\", {\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre>\n   * or, for Backbone compatibility:<pre>\n   *     var MyClass = Parse.Object.extend({\n   *         className: \"MyClass\",\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre></p>\n   *\n   * @param {string} className The name of the Parse class backing this model.\n   * @param {object} [protoProps] Instance properties to add to instances of the\n   *     class returned from this method.\n   * @param {object} [classProps] Class properties to add the class returned from\n   *     this method.\n   * @returns {Parse.Object} A new subclass of Parse.Object.\n   */\n  static extend(className, protoProps, classProps) {\n    if (typeof className !== 'string') {\n      if (className && typeof className.className === 'string') {\n        return ParseObject.extend(className.className, className, protoProps);\n      } else {\n        throw new Error(\"Parse.Object.extend's first argument should be the className.\");\n      }\n    }\n    let adjustedClassName = className;\n    if (adjustedClassName === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n      adjustedClassName = '_User';\n    }\n    let parentProto = ParseObject.prototype;\n    if (this.hasOwnProperty('__super__') && this.__super__) {\n      parentProto = this.prototype;\n    }\n    let ParseObjectSubclass = function (attributes, options) {\n      this.className = adjustedClassName;\n      this._objCount = objectCount++;\n      // Enable legacy initializers\n      if (typeof this.initialize === 'function') {\n        this.initialize.apply(this, arguments);\n      }\n      if (this._initializers) {\n        for (const initializer of this._initializers) {\n          initializer.apply(this, arguments);\n        }\n      }\n      if (attributes && typeof attributes === 'object') {\n        if (!this.set(attributes || {}, options)) {\n          throw new Error(\"Can't create an invalid Parse Object\");\n        }\n      }\n    };\n    if (classMap[adjustedClassName]) {\n      ParseObjectSubclass = classMap[adjustedClassName];\n    } else {\n      ParseObjectSubclass.extend = function (name, protoProps, classProps) {\n        if (typeof name === 'string') {\n          return ParseObject.extend.call(ParseObjectSubclass, name, protoProps, classProps);\n        }\n        return ParseObject.extend.call(ParseObjectSubclass, adjustedClassName, name, protoProps);\n      };\n      ParseObjectSubclass.createWithoutData = ParseObject.createWithoutData;\n      ParseObjectSubclass.className = adjustedClassName;\n      ParseObjectSubclass.__super__ = parentProto;\n      ParseObjectSubclass.prototype = (0, _create.default)(parentProto, {\n        constructor: {\n          value: ParseObjectSubclass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop === 'initialize') {\n          (0, _defineProperty3.default)(ParseObjectSubclass.prototype, '_initializers', {\n            value: [...(ParseObjectSubclass.prototype._initializers || []), protoProps[prop]],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n          continue;\n        }\n        if (prop !== 'className') {\n          (0, _defineProperty3.default)(ParseObjectSubclass.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty3.default)(ParseObjectSubclass, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    classMap[adjustedClassName] = ParseObjectSubclass;\n    return ParseObjectSubclass;\n  }\n\n  /**\n   * Enable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * This is disabled by default in server environments, since it can lead to\n   * security issues.\n   *\n   * @static\n   */\n  static enableSingleInstance() {\n    singleInstance = true;\n    _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n  }\n\n  /**\n   * Disable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * When disabled, you can have two instances of the same object in memory\n   * without them sharing attributes.\n   *\n   * @static\n   */\n  static disableSingleInstance() {\n    singleInstance = false;\n    _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAll([...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n  static pinAll(objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n  static pinAllWithName(name, objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore._handlePinAllWithName(name, objects);\n  }\n\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAll([...]);\n   * </pre>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAll(objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore, recursively.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllWithName(name, objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore._handleUnPinAllWithName(name, objects);\n  }\n\n  /**\n   * Asynchronously removes all objects in the local datastore using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjects();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllObjects() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n\n  /**\n   * Asynchronously removes all objects with the specified pin name.\n   * Deletes the pin name also.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjectsWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllObjectsWithName(name) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.PIN_PREFIX + name);\n  }\n}\nconst DefaultController = {\n  fetch(target, forceFetch, options) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      const objs = [];\n      const ids = [];\n      let className = null;\n      const results = [];\n      let error = null;\n      (0, _forEach.default)(target).call(target, el => {\n        if (error) {\n          return;\n        }\n        if (!className) {\n          className = el.className;\n        }\n        if (className !== el.className) {\n          error = new _ParseError.default(_ParseError.default.INVALID_CLASS_NAME, 'All objects should be of the same class');\n        }\n        if (!el.id) {\n          error = new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'All objects must have an ID');\n        }\n        if (forceFetch || !el.isDataAvailable()) {\n          ids.push(el.id);\n          objs.push(el);\n        }\n        results.push(el);\n      });\n      if (error) {\n        return _promise.default.reject(error);\n      }\n      const ParseQuery = _CoreManager.default.getParseQuery();\n      const query = new ParseQuery(className);\n      query.containedIn('objectId', ids);\n      if (options && options.include) {\n        query.include(options.include);\n      }\n      query._limit = ids.length;\n      return (0, _find.default)(query).call(query, options).then(async objects => {\n        const idMap = {};\n        (0, _forEach.default)(objects).call(objects, o => {\n          idMap[o.id] = o;\n        });\n        for (let i = 0; i < objs.length; i++) {\n          const obj = objs[i];\n          if (!obj || !obj.id || !idMap[obj.id]) {\n            if (forceFetch) {\n              return _promise.default.reject(new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'All objects must exist on the server.'));\n            }\n          }\n        }\n        if (!singleInstance) {\n          // If single instance objects are disabled, we need to replace the\n          for (let i = 0; i < results.length; i++) {\n            const obj = results[i];\n            if (obj && obj.id && idMap[obj.id]) {\n              const id = obj.id;\n              obj._finishFetch(idMap[id].toJSON());\n              results[i] = idMap[id];\n            }\n          }\n        }\n        for (const object of results) {\n          await localDatastore._updateObjectIfPinned(object);\n        }\n        return _promise.default.resolve(results);\n      });\n    } else if (target instanceof ParseObject) {\n      if (!target.id) {\n        return _promise.default.reject(new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'Object does not have an ID'));\n      }\n      const RESTController = _CoreManager.default.getRESTController();\n      const params = {};\n      if (options && options.include) {\n        params.include = options.include.join();\n      }\n      return RESTController.request('GET', 'classes/' + target.className + '/' + target._getId(), params, options).then(async response => {\n        target._clearPendingOps();\n        target._clearServerData();\n        target._finishFetch(response);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      });\n    }\n    return _promise.default.resolve(undefined);\n  },\n  async destroy(target, options) {\n    const batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const RESTController = _CoreManager.default.getRESTController();\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      const batches = [[]];\n      (0, _forEach.default)(target).call(target, obj => {\n        if (!obj.id) {\n          return;\n        }\n        batches[batches.length - 1].push(obj);\n        if (batches[batches.length - 1].length >= batchSize) {\n          batches.push([]);\n        }\n      });\n      if (batches[batches.length - 1].length === 0) {\n        // If the last batch is empty, remove it\n        batches.pop();\n      }\n      let deleteCompleted = _promise.default.resolve();\n      const errors = [];\n      (0, _forEach.default)(batches).call(batches, batch => {\n        deleteCompleted = deleteCompleted.then(() => {\n          return RESTController.request('POST', 'batch', {\n            requests: (0, _map.default)(batch).call(batch, obj => {\n              return {\n                method: 'DELETE',\n                path: getServerUrlPath() + 'classes/' + obj.className + '/' + obj._getId(),\n                body: {}\n              };\n            })\n          }, options).then(results => {\n            for (let i = 0; i < results.length; i++) {\n              if (results[i] && results[i].hasOwnProperty('error')) {\n                const err = new _ParseError.default(results[i].error.code, results[i].error.error);\n                err.object = batch[i];\n                errors.push(err);\n              }\n            }\n          });\n        });\n      });\n      return deleteCompleted.then(async () => {\n        if (errors.length) {\n          const aggregate = new _ParseError.default(_ParseError.default.AGGREGATE_ERROR);\n          aggregate.errors = errors;\n          return _promise.default.reject(aggregate);\n        }\n        for (const object of target) {\n          await localDatastore._destroyObjectIfPinned(object);\n        }\n        return _promise.default.resolve(target);\n      });\n    } else if (target instanceof ParseObject) {\n      return RESTController.request('DELETE', 'classes/' + target.className + '/' + target._getId(), {}, options).then(async () => {\n        await localDatastore._destroyObjectIfPinned(target);\n        return _promise.default.resolve(target);\n      });\n    }\n    return _promise.default.resolve(target);\n  },\n  save(target, options) {\n    const batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const mapIdForPin = {};\n    const RESTController = _CoreManager.default.getRESTController();\n    const stateController = _CoreManager.default.getObjectStateController();\n    const allowCustomObjectId = _CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID');\n    options = options || {};\n    options.returnStatus = options.returnStatus || true;\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      let unsaved = (0, _concat.default)(target).call(target);\n      for (let i = 0; i < target.length; i++) {\n        const target_i = target[i];\n        if (target_i instanceof ParseObject) {\n          unsaved = (0, _concat.default)(unsaved).call(unsaved, (0, _unsavedChildren.default)(target_i, true));\n        }\n      }\n      unsaved = (0, _unique.default)(unsaved);\n      const filesSaved = [];\n      let pending = [];\n      (0, _forEach.default)(unsaved).call(unsaved, el => {\n        if (el instanceof _ParseFile.default) {\n          filesSaved.push(el.save(options));\n        } else if (el instanceof ParseObject) {\n          pending.push(el);\n        }\n      });\n      return _promise.default.all(filesSaved).then(() => {\n        let objectError = null;\n        return (0, _promiseUtils.continueWhile)(() => {\n          return pending.length > 0;\n        }, () => {\n          const batch = [];\n          const nextPending = [];\n          (0, _forEach.default)(pending).call(pending, el => {\n            if (allowCustomObjectId && Object.prototype.hasOwnProperty.call(el, 'id') && !el.id) {\n              throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty or null');\n            }\n            if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {\n              batch.push(el);\n            } else {\n              nextPending.push(el);\n            }\n          });\n          pending = nextPending;\n          if (batch.length < 1) {\n            return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a batch with a cycle.'));\n          }\n\n          // Queue up tasks for each object in the batch.\n          // When every task is ready, the API request will execute\n          const batchReturned = (0, _promiseUtils.resolvingPromise)();\n          const batchReady = [];\n          const batchTasks = [];\n          (0, _forEach.default)(batch).call(batch, (obj, index) => {\n            const ready = (0, _promiseUtils.resolvingPromise)();\n            batchReady.push(ready);\n            stateController.pushPendingState(obj._getStateIdentifier());\n            batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function () {\n              ready.resolve();\n              return batchReturned.then(responses => {\n                if (responses[index].hasOwnProperty('success')) {\n                  const objectId = responses[index].success.objectId;\n                  const status = responses[index]._status;\n                  delete responses[index]._status;\n                  delete responses[index]._headers;\n                  delete responses[index]._xhr;\n                  mapIdForPin[objectId] = obj._localId;\n                  obj._handleSaveResponse(responses[index].success, status);\n                } else {\n                  if (!objectError && responses[index].hasOwnProperty('error')) {\n                    const serverError = responses[index].error;\n                    objectError = new _ParseError.default(serverError.code, serverError.error);\n                    // Cancel the rest of the save\n                    pending = [];\n                  }\n                  obj._handleSaveError();\n                }\n              });\n            }));\n          });\n          (0, _promiseUtils.when)(batchReady).then(() => {\n            // Kick off the batch request\n            return RESTController.request('POST', 'batch', {\n              requests: (0, _map.default)(batch).call(batch, obj => {\n                const params = obj._getSaveParams();\n                params.path = getServerUrlPath() + params.path;\n                return params;\n              })\n            }, options);\n          }).then(batchReturned.resolve, error => {\n            batchReturned.reject(new _ParseError.default(_ParseError.default.INCORRECT_TYPE, error.message));\n          });\n          return (0, _promiseUtils.when)(batchTasks);\n        }).then(async () => {\n          if (objectError) {\n            return _promise.default.reject(objectError);\n          }\n          for (const object of target) {\n            // Make sure that it is a ParseObject before updating it into the localDataStore\n            if (object instanceof ParseObject) {\n              await localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);\n              await localDatastore._updateObjectIfPinned(object);\n            }\n          }\n          return _promise.default.resolve(target);\n        });\n      });\n    } else if (target instanceof ParseObject) {\n      if (allowCustomObjectId && Object.prototype.hasOwnProperty.call(target, 'id') && !target.id) {\n        throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty or null');\n      }\n      // generate _localId in case if cascadeSave=false\n      target._getId();\n      const localId = target._localId;\n      // copying target lets guarantee the pointer isn't modified elsewhere\n      const targetCopy = target;\n      const task = function () {\n        const params = targetCopy._getSaveParams();\n        return RESTController.request(params.method, params.path, params.body, options).then(response => {\n          const status = response._status;\n          delete response._status;\n          delete response._headers;\n          delete response._xhr;\n          targetCopy._handleSaveResponse(response, status);\n        }, error => {\n          targetCopy._handleSaveError();\n          return _promise.default.reject(error);\n        });\n      };\n      stateController.pushPendingState(target._getStateIdentifier());\n      return stateController.enqueueTask(target._getStateIdentifier(), task).then(async () => {\n        await localDatastore._updateLocalIdForObject(localId, target);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      }, error => {\n        return _promise.default.reject(error);\n      });\n    }\n    return _promise.default.resolve(undefined);\n  }\n};\n_CoreManager.default.setParseObject(ParseObject);\n_CoreManager.default.setObjectController(DefaultController);\nvar _default = exports.default = ParseObject;","map":{"version":3,"names":["_WeakMap","require","_Object$defineProperty2","_Object$getOwnPropertyDescriptor","_interopRequireDefault","exports","value","default","_defineProperty2","_indexOf","_freeze","_keys","_forEach","_stringify","_includes","_getPrototypeOf","_concat","_isArray","_promise","_create","_defineProperty3","_find","_map","_CoreManager","_canBeSerialized","_decode","_encode","_escape","_ParseACL","_parseDate","_ParseError","_ParseFile","_promiseUtils","_LocalDatastoreUtils","_uuid","_ParseOp","_ParseRelation","SingleInstanceStateController","_interopRequireWildcard","_unique","UniqueInstanceStateController","_unsavedChildren","_getRequireWildcardCache","e","r","t","__esModule","has","get","n","__proto__","u","hasOwnProperty","call","i","set","classMap","objectCount","singleInstance","setObjectStateController","getServerUrlPath","serverUrl","length","url","replace","substr","ParseObject","constructor","className","attributes","options","initialize","apply","arguments","toSet","_objCount","attr","Error","stateController","getObjectStateController","estimateAttributes","_getStateIdentifier","createdAt","_getServerData","updatedAt","_getId","id","_localId","localId","getServerData","_clearServerData","serverData","unset","undefined","setServerData","_getPendingOps","getPendingOps","_clearPendingOps","keysToClear","pending","latest","keys","key","_getDirtyObjectAttributes","objectCache","getObjectCache","dirty","val","json","stringified","_toFullJSON","seen","offline","toJSON","__type","_getSaveJSON","dirtyObjects","isDotNotation","field","fieldName","split","SetOp","_getSaveParams","method","body","path","objectId","_finishFetch","initializeState","decoded","_ensureParentAndKey","commitServerChanges","_setExisted","existed","state","getState","_migrateId","serverId","oldState","removeState","_handleSaveResponse","response","status","changes","popPendingState","RelationOp","applyTo","Object","prototype","UnsetOp","_handleSaveError","mergeFirstPendingState","_getClassMap","seenEntry","attrs","equals","other","pendingOps","dirtyKeys","isDataAvailable","toPointer","toOfflinePointer","relation","escape","toString","newOps","readonly","readOnlyAttributes","k","Op","__op","opFromJSON","targetClassName","currentAttributes","newValues","ignoreValidation","validation","validate","error","last","nextOp","mergeWith","setPendingOp","increment","amount","IncrementOp","decrement","add","item","AddOp","addAll","items","addUnique","AddUniqueOp","addAllUnique","remove","RemoveOp","removeAll","op","clone","copy","a","newInstance","duplicateState","isNew","exists","ParseQuery","getParseQuery","query","code","OBJECT_NOT_FOUND","isValid","ACL","OTHER_CAUSE","test","INVALID_KEY_NAME","getACL","acl","setACL","revert","keysToRevert","_len","Array","_key","push","clear","erasable","fetch","fetchOptions","useMasterKey","sessionToken","context","include","_context","_context2","controller","getObjectController","fetchWithInclude","saveEventually","save","CONNECTION_FAILED","getEventuallyQueue","poll","arg1","arg2","arg3","validationError","_","success","reject","saveOptions","installationId","unsaved","cascadeSave","then","destroyEventually","destroy","destroyOptions","resolve","pin","pinAllWithName","DEFAULT_PIN","unPin","unPinAllWithName","isPinned","localDatastore","getLocalDatastore","isEnabled","objectKey","getKeyForObject","fromPinWithName","pinWithName","name","unPinWithName","fetchFromLocalDatastore","pinned","_serializeObject","result","fromJSON","_clearAllState","clearAllState","fetchAll","list","queryOptions","handleIncludeOptions","fetchAllWithInclude","fetchAllIfNeededWithInclude","fetchAllIfNeeded","_context3","destroyAll","batchSize","saveAll","createWithoutData","obj","override","o","otherAttributes","preserved","_preserveFieldsOnFetch","registerSubclass","TypeError","unregisterSubclass","extend","protoProps","classProps","adjustedClassName","parentProto","__super__","ParseObjectSubclass","_initializers","initializer","enumerable","writable","configurable","prop","enableSingleInstance","disableSingleInstance","pinAll","objects","_handlePinAllWithName","unPinAll","_handleUnPinAllWithName","unPinAllObjects","unPinAllObjectsWithName","PIN_PREFIX","DefaultController","target","forceFetch","objs","ids","results","el","INVALID_CLASS_NAME","MISSING_OBJECT_ID","containedIn","_limit","idMap","object","_updateObjectIfPinned","RESTController","getRESTController","params","join","request","batches","pop","deleteCompleted","errors","batch","requests","err","aggregate","AGGREGATE_ERROR","_destroyObjectIfPinned","mapIdForPin","allowCustomObjectId","returnStatus","target_i","filesSaved","all","objectError","continueWhile","nextPending","batchReturned","resolvingPromise","batchReady","batchTasks","index","ready","pushPendingState","enqueueTask","responses","_status","_headers","_xhr","serverError","when","INCORRECT_TYPE","message","_updateLocalIdForObject","targetCopy","task","setParseObject","setObjectController","_default"],"sources":["/home/mavrik/Documents/classes/web-dev/feature05/node_modules/parse/lib/browser/ParseObject.js"],"sourcesContent":["\"use strict\";\n\nvar _WeakMap = require(\"@babel/runtime-corejs3/core-js-stable/weak-map\");\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _freeze = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/freeze\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _getPrototypeOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/get-prototype-of\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\nvar _defineProperty3 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _canBeSerialized = _interopRequireDefault(require(\"./canBeSerialized\"));\nvar _decode = _interopRequireDefault(require(\"./decode\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _escape = _interopRequireDefault(require(\"./escape\"));\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\nvar _parseDate = _interopRequireDefault(require(\"./parseDate\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\nvar _uuid = _interopRequireDefault(require(\"./uuid\"));\nvar _ParseOp = require(\"./ParseOp\");\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\nvar SingleInstanceStateController = _interopRequireWildcard(require(\"./SingleInstanceStateController\"));\nvar _unique = _interopRequireDefault(require(\"./unique\"));\nvar UniqueInstanceStateController = _interopRequireWildcard(require(\"./UniqueInstanceStateController\"));\nvar _unsavedChildren = _interopRequireDefault(require(\"./unsavedChildren\"));\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof _WeakMap) return null;\n  var r = new _WeakMap(),\n    t = new _WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n    __proto__: null\n  };\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = _Object$defineProperty2 && _Object$getOwnPropertyDescriptor ? _Object$getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? _Object$defineProperty2(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\n// Mapping of class names to constructors, so we can populate objects from the\n// server with appropriate subclasses of ParseObject\nconst classMap = {};\n\n// Global counter for generating unique Ids for non-single-instance objects\nlet objectCount = 0;\n// On web clients, objects are single-instance: any two objects with the same Id\n// will have the same attributes. However, this may be dangerous default\n// behavior in a server scenario\nlet singleInstance = !_CoreManager.default.get('IS_NODE');\nif (singleInstance) {\n  _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n} else {\n  _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n}\nfunction getServerUrlPath() {\n  let serverUrl = _CoreManager.default.get('SERVER_URL');\n  if (serverUrl[serverUrl.length - 1] !== '/') {\n    serverUrl += '/';\n  }\n  const url = serverUrl.replace(/https?:\\/\\//, '');\n  return url.substr((0, _indexOf.default)(url).call(url, '/'));\n}\n\n/**\n * Creates a new model with defined attributes.\n *\n * <p>You won't normally call this method directly.  It is recommended that\n * you use a subclass of <code>Parse.Object</code> instead, created by calling\n * <code>extend</code>.</p>\n *\n * <p>However, if you don't want to use a subclass, or aren't sure which\n * subclass is appropriate, you can use this form:<pre>\n *     var object = new Parse.Object(\"ClassName\");\n * </pre>\n * That is basically equivalent to:<pre>\n *     var MyClass = Parse.Object.extend(\"ClassName\");\n *     var object = new MyClass();\n * </pre></p>\n *\n * @alias Parse.Object\n */\nclass ParseObject {\n  /**\n   * @param {string} className The class name for the object\n   * @param {object} attributes The initial set of data to store in the object.\n   * @param {object} options The options for this object instance.\n   * @param {boolean} [options.ignoreValidation] Set to `true` ignore any attribute validation errors.\n   */\n  constructor(className, attributes, options) {\n    /**\n     * The ID of this object, unique within its class.\n     *\n     * @property {string} id\n     */\n    (0, _defineProperty2.default)(this, \"id\", void 0);\n    (0, _defineProperty2.default)(this, \"_localId\", void 0);\n    (0, _defineProperty2.default)(this, \"_objCount\", void 0);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    // Enable legacy initializers\n    if (typeof this.initialize === 'function') {\n      this.initialize.apply(this, arguments);\n    }\n    let toSet = null;\n    this._objCount = objectCount++;\n    if (typeof className === 'string') {\n      this.className = className;\n      if (attributes && typeof attributes === 'object') {\n        toSet = attributes;\n      }\n    } else if (className && typeof className === 'object') {\n      this.className = className.className;\n      toSet = {};\n      for (const attr in className) {\n        if (attr !== 'className') {\n          toSet[attr] = className[attr];\n        }\n      }\n      if (attributes && typeof attributes === 'object') {\n        options = attributes;\n      }\n    }\n    if (toSet && !this.set(toSet, options)) {\n      throw new Error(\"Can't create an invalid Parse Object\");\n    }\n  }\n  /* Prototype getters / setters */\n\n  get attributes() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return (0, _freeze.default)(stateController.estimateAttributes(this._getStateIdentifier()));\n  }\n\n  /**\n   * The first time this object was saved on the server.\n   *\n   * @property {Date} createdAt\n   * @returns {Date}\n   */\n  get createdAt() {\n    return this._getServerData().createdAt;\n  }\n\n  /**\n   * The last time this object was updated on the server.\n   *\n   * @property {Date} updatedAt\n   * @returns {Date}\n   */\n  get updatedAt() {\n    return this._getServerData().updatedAt;\n  }\n\n  /* Private methods */\n\n  /**\n   * Returns a local or server Id used uniquely identify this object\n   *\n   * @returns {string}\n   */\n  _getId() {\n    if (typeof this.id === 'string') {\n      return this.id;\n    }\n    if (typeof this._localId === 'string') {\n      return this._localId;\n    }\n    const localId = 'local' + (0, _uuid.default)();\n    this._localId = localId;\n    return localId;\n  }\n\n  /**\n   * Returns a unique identifier used to pull data from the State Controller.\n   *\n   * @returns {Parse.Object|object}\n   */\n  _getStateIdentifier() {\n    if (singleInstance) {\n      let id = this.id;\n      if (!id) {\n        id = this._getId();\n      }\n      return {\n        id: id,\n        className: this.className\n      };\n    } else {\n      return this;\n    }\n  }\n  _getServerData() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return stateController.getServerData(this._getStateIdentifier());\n  }\n  _clearServerData() {\n    const serverData = this._getServerData();\n    const unset = {};\n    for (const attr in serverData) {\n      unset[attr] = undefined;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.setServerData(this._getStateIdentifier(), unset);\n  }\n  _getPendingOps() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return stateController.getPendingOps(this._getStateIdentifier());\n  }\n\n  /**\n   * @param {Array<string>} [keysToClear] - if specified, only ops matching\n   * these fields will be cleared\n   */\n  _clearPendingOps(keysToClear) {\n    const pending = this._getPendingOps();\n    const latest = pending[pending.length - 1];\n    const keys = keysToClear || (0, _keys.default)(latest);\n    (0, _forEach.default)(keys).call(keys, key => {\n      delete latest[key];\n    });\n  }\n  _getDirtyObjectAttributes() {\n    const attributes = this.attributes;\n    const stateController = _CoreManager.default.getObjectStateController();\n    const objectCache = stateController.getObjectCache(this._getStateIdentifier());\n    const dirty = {};\n    for (const attr in attributes) {\n      const val = attributes[attr];\n      if (val && typeof val === 'object' && !(val instanceof ParseObject) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {\n        // Due to the way browsers construct maps, the key order will not change\n        // unless the object is changed\n        try {\n          const json = (0, _encode.default)(val, false, true);\n          const stringified = (0, _stringify.default)(json);\n          if (objectCache[attr] !== stringified) {\n            dirty[attr] = val;\n          }\n        } catch (e) {\n          // Error occurred, possibly by a nested unsaved pointer in a mutable container\n          // No matter how it happened, it indicates a change in the attribute\n          dirty[attr] = val;\n        }\n      }\n    }\n    return dirty;\n  }\n  _toFullJSON(seen, offline) {\n    const json = this.toJSON(seen, offline);\n    json.__type = 'Object';\n    json.className = this.className;\n    return json;\n  }\n  _getSaveJSON() {\n    const pending = this._getPendingOps();\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    const json = {};\n    for (var attr in dirtyObjects) {\n      let isDotNotation = false;\n      for (let i = 0; i < pending.length; i += 1) {\n        for (const field in pending[i]) {\n          // Dot notation operations are handled later\n          if ((0, _includes.default)(field).call(field, '.')) {\n            const fieldName = field.split('.')[0];\n            if (fieldName === attr) {\n              isDotNotation = true;\n              break;\n            }\n          }\n        }\n      }\n      if (!isDotNotation) {\n        json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();\n      }\n    }\n    for (attr in pending[0]) {\n      json[attr] = pending[0][attr].toJSON();\n    }\n    return json;\n  }\n  _getSaveParams() {\n    let method = this.id ? 'PUT' : 'POST';\n    const body = this._getSaveJSON();\n    let path = 'classes/' + this.className;\n    if (_CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID')) {\n      if (!this.createdAt) {\n        method = 'POST';\n        body.objectId = this.id;\n      } else {\n        method = 'PUT';\n        path += '/' + this.id;\n      }\n    } else if (this.id) {\n      path += '/' + this.id;\n    } else if (this.className === '_User') {\n      path = 'users';\n    }\n    return {\n      method,\n      body,\n      path\n    };\n  }\n  _finishFetch(serverData) {\n    if (!this.id && serverData.objectId) {\n      this.id = serverData.objectId;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.initializeState(this._getStateIdentifier());\n    const decoded = {};\n    for (const attr in serverData) {\n      if (attr === 'ACL') {\n        decoded[attr] = new _ParseACL.default(serverData[attr]);\n      } else if (attr !== 'objectId') {\n        decoded[attr] = (0, _decode.default)(serverData[attr]);\n        if (decoded[attr] instanceof _ParseRelation.default) {\n          decoded[attr]._ensureParentAndKey(this, attr);\n        }\n      }\n    }\n    if (decoded.createdAt && typeof decoded.createdAt === 'string') {\n      decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);\n    }\n    if (decoded.updatedAt && typeof decoded.updatedAt === 'string') {\n      decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);\n    }\n    if (!decoded.updatedAt && decoded.createdAt) {\n      decoded.updatedAt = decoded.createdAt;\n    }\n    stateController.commitServerChanges(this._getStateIdentifier(), decoded);\n  }\n  _setExisted(existed) {\n    const stateController = _CoreManager.default.getObjectStateController();\n    const state = stateController.getState(this._getStateIdentifier());\n    if (state) {\n      state.existed = existed;\n    }\n  }\n  _migrateId(serverId) {\n    if (this._localId && serverId) {\n      if (singleInstance) {\n        const stateController = _CoreManager.default.getObjectStateController();\n        const oldState = stateController.removeState(this._getStateIdentifier());\n        this.id = serverId;\n        delete this._localId;\n        if (oldState) {\n          stateController.initializeState(this._getStateIdentifier(), oldState);\n        }\n      } else {\n        this.id = serverId;\n        delete this._localId;\n      }\n    }\n  }\n  _handleSaveResponse(response, status) {\n    const changes = {};\n    const stateController = _CoreManager.default.getObjectStateController();\n    const pending = stateController.popPendingState(this._getStateIdentifier());\n    for (var attr in pending) {\n      if (pending[attr] instanceof _ParseOp.RelationOp) {\n        changes[attr] = pending[attr].applyTo(undefined, this, attr);\n      } else if (!(attr in response)) {\n        // Only SetOps and UnsetOps should not come back with results\n        changes[attr] = pending[attr].applyTo(undefined);\n      }\n    }\n    for (attr in response) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && typeof response[attr] === 'string') {\n        changes[attr] = (0, _parseDate.default)(response[attr]);\n      } else if (attr === 'ACL') {\n        changes[attr] = new _ParseACL.default(response[attr]);\n      } else if (attr !== 'objectId') {\n        const val = (0, _decode.default)(response[attr]);\n        if (val && (0, _getPrototypeOf.default)(val) === Object.prototype) {\n          changes[attr] = {\n            ...this.attributes[attr],\n            ...val\n          };\n        } else {\n          changes[attr] = val;\n        }\n        if (changes[attr] instanceof _ParseOp.UnsetOp) {\n          changes[attr] = undefined;\n        }\n      }\n    }\n    if (changes.createdAt && !changes.updatedAt) {\n      changes.updatedAt = changes.createdAt;\n    }\n    this._migrateId(response.objectId);\n    if (status !== 201) {\n      this._setExisted(true);\n    }\n    stateController.commitServerChanges(this._getStateIdentifier(), changes);\n  }\n  _handleSaveError() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.mergeFirstPendingState(this._getStateIdentifier());\n  }\n  static _getClassMap() {\n    return classMap;\n  }\n\n  /* Public methods */\n\n  initialize() {\n    // NOOP\n  }\n\n  /**\n   * Returns a JSON version of the object suitable for saving to Parse.\n   *\n   * @param seen\n   * @param offline\n   * @returns {object}\n   */\n  toJSON(seen, offline) {\n    const seenEntry = this.id ? this.className + ':' + this.id : this;\n    seen = seen || [seenEntry];\n    const json = {};\n    const attrs = this.attributes;\n    for (const attr in attrs) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && attrs[attr].toJSON) {\n        json[attr] = attrs[attr].toJSON();\n      } else {\n        json[attr] = (0, _encode.default)(attrs[attr], false, false, seen, offline);\n      }\n    }\n    const pending = this._getPendingOps();\n    for (const attr in pending[0]) {\n      if ((0, _indexOf.default)(attr).call(attr, '.') < 0) {\n        json[attr] = pending[0][attr].toJSON(offline);\n      }\n    }\n    if (this.id) {\n      json.objectId = this.id;\n    }\n    return json;\n  }\n\n  /**\n   * Determines whether this ParseObject is equal to another ParseObject\n   *\n   * @param {object} other - An other object ot compare\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    return other instanceof ParseObject && this.className === other.className && this.id === other.id && typeof this.id !== 'undefined';\n  }\n\n  /**\n   * Returns true if this object has been modified since its last\n   * save/refresh.  If an attribute is specified, it returns true only if that\n   * particular attribute has been modified since the last save/refresh.\n   *\n   * @param {string} attr An attribute name (optional).\n   * @returns {boolean}\n   */\n  dirty(attr) {\n    if (!this.id) {\n      return true;\n    }\n    const pendingOps = this._getPendingOps();\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    if (attr) {\n      if (dirtyObjects.hasOwnProperty(attr)) {\n        return true;\n      }\n      for (let i = 0; i < pendingOps.length; i++) {\n        if (pendingOps[i].hasOwnProperty(attr)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if ((0, _keys.default)(pendingOps[0]).length !== 0) {\n      return true;\n    }\n    if ((0, _keys.default)(dirtyObjects).length !== 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns an array of keys that have been modified since last save/refresh\n   *\n   * @returns {string[]}\n   */\n  dirtyKeys() {\n    const pendingOps = this._getPendingOps();\n    const keys = {};\n    for (let i = 0; i < pendingOps.length; i++) {\n      for (const attr in pendingOps[i]) {\n        keys[attr] = true;\n      }\n    }\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    for (const attr in dirtyObjects) {\n      keys[attr] = true;\n    }\n    return (0, _keys.default)(keys);\n  }\n\n  /**\n   * Returns true if the object has been fetched.\n   *\n   * @returns {boolean}\n   */\n  isDataAvailable() {\n    const serverData = this._getServerData();\n    return !!(0, _keys.default)(serverData).length;\n  }\n\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n  toPointer() {\n    if (!this.id) {\n      throw new Error('Cannot create a pointer to an unsaved ParseObject');\n    }\n    return {\n      __type: 'Pointer',\n      className: this.className,\n      objectId: this.id\n    };\n  }\n\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n  toOfflinePointer() {\n    if (!this._localId) {\n      throw new Error('Cannot create a offline pointer to a saved ParseObject');\n    }\n    return {\n      __type: 'Object',\n      className: this.className,\n      _localId: this._localId\n    };\n  }\n\n  /**\n   * Gets the value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {*}\n   */\n  get(attr) {\n    return this.attributes[attr];\n  }\n\n  /**\n   * Gets a relation on the given class for the attribute.\n   *\n   * @param {string} attr The attribute to get the relation for.\n   * @returns {Parse.Relation}\n   */\n  relation(attr) {\n    const value = this.get(attr);\n    if (value) {\n      if (!(value instanceof _ParseRelation.default)) {\n        throw new Error('Called relation() on non-relation field ' + attr);\n      }\n      value._ensureParentAndKey(this, attr);\n      return value;\n    }\n    return new _ParseRelation.default(this, attr);\n  }\n\n  /**\n   * Gets the HTML-escaped value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {string}\n   */\n  escape(attr) {\n    let val = this.attributes[attr];\n    if (val == null) {\n      return '';\n    }\n    if (typeof val !== 'string') {\n      if (typeof val.toString !== 'function') {\n        return '';\n      }\n      val = val.toString();\n    }\n    return (0, _escape.default)(val);\n  }\n\n  /**\n   * Returns <code>true</code> if the attribute contains a value that is not\n   * null or undefined.\n   *\n   * @param {string} attr The string name of the attribute.\n   * @returns {boolean}\n   */\n  has(attr) {\n    const attributes = this.attributes;\n    if (attributes.hasOwnProperty(attr)) {\n      return attributes[attr] != null;\n    }\n    return false;\n  }\n\n  /**\n   * Sets a hash of model attributes on the object.\n   *\n   * <p>You can call it with an object containing keys and values, with one\n   * key and value, or dot notation.  For example:<pre>\n   *   gameTurn.set({\n   *     player: player1,\n   *     diceRoll: 2\n   *   }, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"currentPlayer\", player2, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"finished\", true);</pre></p>\n   *\n   *   game.set(\"player.score\", 10);</pre></p>\n   *\n   * @param {(string|object)} key The key to set.\n   * @param {(string|object)} value The value to give it.\n   * @param {object} options A set of options for the set.\n   *     The only supported option is <code>error</code>.\n   * @returns {(ParseObject|boolean)} true if the set succeeded.\n   */\n  set(key, value, options) {\n    let changes = {};\n    const newOps = {};\n    if (key && typeof key === 'object') {\n      changes = key;\n      options = value;\n    } else if (typeof key === 'string') {\n      changes[key] = value;\n    } else {\n      return this;\n    }\n    options = options || {};\n    let readonly = [];\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());\n    }\n    for (const k in changes) {\n      if (k === 'createdAt' || k === 'updatedAt') {\n        // This property is read-only, but for legacy reasons we silently\n        // ignore it\n        continue;\n      }\n      if ((0, _indexOf.default)(readonly).call(readonly, k) > -1) {\n        throw new Error('Cannot modify readonly attribute: ' + k);\n      }\n      if (options.unset) {\n        newOps[k] = new _ParseOp.UnsetOp();\n      } else if (changes[k] instanceof _ParseOp.Op) {\n        newOps[k] = changes[k];\n      } else if (changes[k] && typeof changes[k] === 'object' && typeof changes[k].__op === 'string') {\n        newOps[k] = (0, _ParseOp.opFromJSON)(changes[k]);\n      } else if (k === 'objectId' || k === 'id') {\n        if (typeof changes[k] === 'string') {\n          this.id = changes[k];\n        }\n      } else if (k === 'ACL' && typeof changes[k] === 'object' && !(changes[k] instanceof _ParseACL.default)) {\n        newOps[k] = new _ParseOp.SetOp(new _ParseACL.default(changes[k]));\n      } else if (changes[k] instanceof _ParseRelation.default) {\n        const relation = new _ParseRelation.default(this, k);\n        relation.targetClassName = changes[k].targetClassName;\n        newOps[k] = new _ParseOp.SetOp(relation);\n      } else {\n        newOps[k] = new _ParseOp.SetOp(changes[k]);\n      }\n    }\n    const currentAttributes = this.attributes;\n\n    // Calculate new values\n    const newValues = {};\n    for (const attr in newOps) {\n      if (newOps[attr] instanceof _ParseOp.RelationOp) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr], this, attr);\n      } else if (!(newOps[attr] instanceof _ParseOp.UnsetOp)) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr]);\n      }\n    }\n\n    // Validate changes\n    if (!options.ignoreValidation) {\n      const validation = this.validate(newValues);\n      if (validation) {\n        if (typeof options.error === 'function') {\n          options.error(this, validation);\n        }\n        return false;\n      }\n    }\n\n    // Consolidate Ops\n    const pendingOps = this._getPendingOps();\n    const last = pendingOps.length - 1;\n    const stateController = _CoreManager.default.getObjectStateController();\n    for (const attr in newOps) {\n      const nextOp = newOps[attr].mergeWith(pendingOps[last][attr]);\n      stateController.setPendingOp(this._getStateIdentifier(), attr, nextOp);\n    }\n    return this;\n  }\n\n  /**\n   * Remove an attribute from the model. This is a noop if the attribute doesn't\n   * exist.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @param options\n   * @returns {(ParseObject | boolean)}\n   */\n  unset(attr, options) {\n    options = options || {};\n    options.unset = true;\n    return this.set(attr, null, options);\n  }\n\n  /**\n   * Atomically increments the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to increment by (optional).\n   * @returns {(ParseObject|boolean)}\n   */\n  increment(attr, amount) {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot increment by a non-numeric amount.');\n    }\n    return this.set(attr, new _ParseOp.IncrementOp(amount));\n  }\n\n  /**\n   * Atomically decrements the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to decrement by (optional).\n   * @returns {(ParseObject | boolean)}\n   */\n  decrement(attr, amount) {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot decrement by a non-numeric amount.');\n    }\n    return this.set(attr, new _ParseOp.IncrementOp(amount * -1));\n  }\n\n  /**\n   * Atomically add an object to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The item to add.\n   * @returns {(ParseObject | boolean)}\n   */\n  add(attr, item) {\n    return this.set(attr, new _ParseOp.AddOp([item]));\n  }\n\n  /**\n   * Atomically add the objects to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The items to add.\n   * @returns {(ParseObject | boolean)}\n   */\n  addAll(attr, items) {\n    return this.set(attr, new _ParseOp.AddOp(items));\n  }\n\n  /**\n   * Atomically add an object to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to add.\n   * @returns {(ParseObject | boolean)}\n   */\n  addUnique(attr, item) {\n    return this.set(attr, new _ParseOp.AddUniqueOp([item]));\n  }\n\n  /**\n   * Atomically add the objects to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The objects to add.\n   * @returns {(ParseObject | boolean)}\n   */\n  addAllUnique(attr, items) {\n    return this.set(attr, new _ParseOp.AddUniqueOp(items));\n  }\n\n  /**\n   * Atomically remove all instances of an object from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to remove.\n   * @returns {(ParseObject | boolean)}\n   */\n  remove(attr, item) {\n    return this.set(attr, new _ParseOp.RemoveOp([item]));\n  }\n\n  /**\n   * Atomically remove all instances of the objects from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The object to remove.\n   * @returns {(ParseObject | boolean)}\n   */\n  removeAll(attr, items) {\n    return this.set(attr, new _ParseOp.RemoveOp(items));\n  }\n\n  /**\n   * Returns an instance of a subclass of Parse.Op describing what kind of\n   * modification has been performed on this field since the last time it was\n   * saved. For example, after calling object.increment(\"x\"), calling\n   * object.op(\"x\") would return an instance of Parse.Op.Increment.\n   *\n   * @param attr {String} The key.\n   * @returns {Parse.Op | undefined} The operation, or undefined if none.\n   */\n  op(attr) {\n    const pending = this._getPendingOps();\n    for (let i = pending.length; i--;) {\n      if (pending[i][attr]) {\n        return pending[i][attr];\n      }\n    }\n  }\n\n  /**\n   * Creates a new model with identical attributes to this one.\n   *\n   * @returns {Parse.Object}\n   */\n  clone() {\n    const clone = new this.constructor(this.className);\n    let attributes = this.attributes;\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      const readonly = this.constructor.readOnlyAttributes() || [];\n      // Attributes are frozen, so we have to rebuild an object,\n      // rather than delete readonly keys\n      const copy = {};\n      for (const a in attributes) {\n        if ((0, _indexOf.default)(readonly).call(readonly, a) < 0) {\n          copy[a] = attributes[a];\n        }\n      }\n      attributes = copy;\n    }\n    if (clone.set) {\n      clone.set(attributes);\n    }\n    return clone;\n  }\n\n  /**\n   * Creates a new instance of this object. Not to be confused with clone()\n   *\n   * @returns {Parse.Object}\n   */\n  newInstance() {\n    const clone = new this.constructor(this.className);\n    clone.id = this.id;\n    if (singleInstance) {\n      // Just return an object with the right id\n      return clone;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    if (stateController) {\n      stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());\n    }\n    return clone;\n  }\n\n  /**\n   * Returns true if this object has never been saved to Parse.\n   *\n   * @returns {boolean}\n   */\n  isNew() {\n    return !this.id;\n  }\n\n  /**\n   * Returns true if this object was created by the Parse server when the\n   * object might have already been there (e.g. in the case of a Facebook\n   * login)\n   *\n   * @returns {boolean}\n   */\n  existed() {\n    if (!this.id) {\n      return false;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    const state = stateController.getState(this._getStateIdentifier());\n    if (state) {\n      return state.existed;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this object exists on the Server\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object exists.\n   */\n  async exists(options) {\n    if (!this.id) {\n      return false;\n    }\n    try {\n      const ParseQuery = _CoreManager.default.getParseQuery();\n      const query = new ParseQuery(this.className);\n      await query.get(this.id, options);\n      return true;\n    } catch (e) {\n      if (e.code === _ParseError.default.OBJECT_NOT_FOUND) {\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Checks if the model is currently in a valid state.\n   *\n   * @returns {boolean}\n   */\n  isValid() {\n    return !this.validate(this.attributes);\n  }\n\n  /**\n   * You should not call this function directly unless you subclass\n   * <code>Parse.Object</code>, in which case you can override this method\n   * to provide additional validation on <code>set</code> and\n   * <code>save</code>.  Your implementation should return\n   *\n   * @param {object} attrs The current data to validate.\n   * @returns {Parse.Error|boolean} False if the data is valid.  An error object otherwise.\n   * @see Parse.Object#set\n   */\n  validate(attrs) {\n    if (attrs.hasOwnProperty('ACL') && !(attrs.ACL instanceof _ParseACL.default)) {\n      return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'ACL must be a Parse ACL.');\n    }\n    for (const key in attrs) {\n      if (!/^[A-Za-z][0-9A-Za-z_.]*$/.test(key)) {\n        return new _ParseError.default(_ParseError.default.INVALID_KEY_NAME);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the ACL for this object.\n   *\n   * @returns {Parse.ACL|null} An instance of Parse.ACL.\n   * @see Parse.Object#get\n   */\n  getACL() {\n    const acl = this.get('ACL');\n    if (acl instanceof _ParseACL.default) {\n      return acl;\n    }\n    return null;\n  }\n\n  /**\n   * Sets the ACL to be used for this object.\n   *\n   * @param {Parse.ACL} acl An instance of Parse.ACL.\n   * @param {object} options\n   * @returns {(ParseObject | boolean)} Whether the set passed validation.\n   * @see Parse.Object#set\n   */\n  setACL(acl, options) {\n    return this.set('ACL', acl, options);\n  }\n\n  /**\n   * Clears any (or specific) changes to this object made since the last call to save()\n   *\n   * @param {string} [keys] - specify which fields to revert\n   */\n  revert() {\n    let keysToRevert;\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    if (keys.length) {\n      keysToRevert = [];\n      for (const key of keys) {\n        if (typeof key === 'string') {\n          keysToRevert.push(key);\n        } else {\n          throw new Error('Parse.Object#revert expects either no, or a list of string, arguments.');\n        }\n      }\n    }\n    this._clearPendingOps(keysToRevert);\n  }\n\n  /**\n   * Clears all attributes on a model\n   *\n   * @returns {(ParseObject | boolean)}\n   */\n  clear() {\n    const attributes = this.attributes;\n    const erasable = {};\n    let readonly = ['createdAt', 'updatedAt'];\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());\n    }\n    for (const attr in attributes) {\n      if ((0, _indexOf.default)(readonly).call(readonly, attr) < 0) {\n        erasable[attr] = true;\n      }\n    }\n    return this.set(erasable, {\n      unset: true\n    });\n  }\n\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n  fetch(options) {\n    options = options || {};\n    const fetchOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      fetchOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      fetchOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      fetchOptions.context = options.context;\n    }\n    if (options.hasOwnProperty('include')) {\n      fetchOptions.include = [];\n      if ((0, _isArray.default)(options.include)) {\n        var _context;\n        (0, _forEach.default)(_context = options.include).call(_context, key => {\n          if ((0, _isArray.default)(key)) {\n            var _context2;\n            fetchOptions.include = (0, _concat.default)(_context2 = fetchOptions.include).call(_context2, key);\n          } else {\n            fetchOptions.include.push(key);\n          }\n        });\n      } else {\n        fetchOptions.include.push(options.include);\n      }\n    }\n    const controller = _CoreManager.default.getObjectController();\n    return controller.fetch(this, true, fetchOptions);\n  }\n\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n  fetchWithInclude(keys, options) {\n    options = options || {};\n    options.include = keys;\n    return this.fetch(options);\n  }\n\n  /**\n   * Saves this object to the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection, and don't need to know when the save completes.\n   * If there is some problem with the object such that it can't be saved, it will be silently discarded.\n   *\n   * Objects saved with this method will be stored locally in an on-disk cache until they can be delivered to Parse.\n   * They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection is\n   * available. Objects saved this way will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n  async saveEventually(options) {\n    try {\n      await this.save(null, options);\n    } catch (e) {\n      if (e.code === _ParseError.default.CONNECTION_FAILED) {\n        await _CoreManager.default.getEventuallyQueue().save(this, options);\n        _CoreManager.default.getEventuallyQueue().poll();\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Set a hash of model attributes, and save the model to the server.\n   * updatedAt will be updated when the request returns.\n   * You can either call it as:<pre>\n   * object.save();</pre>\n   * or<pre>\n   * object.save(attrs);</pre>\n   * or<pre>\n   * object.save(null, options);</pre>\n   * or<pre>\n   * object.save(attrs, options);</pre>\n   * or<pre>\n   * object.save(key, value);</pre>\n   * or<pre>\n   * object.save(key, value, options);</pre>\n   *\n   * Example 1: <pre>\n   * gameTurn.save({\n   * player: \"Jake Cutter\",\n   * diceRoll: 2\n   * }).then(function(gameTurnAgain) {\n   * // The save was successful.\n   * }, function(error) {\n   * // The save failed.  Error is an instance of Parse.Error.\n   * });</pre>\n   *\n   * Example 2: <pre>\n   * gameTurn.save(\"player\", \"Jake Cutter\");</pre>\n   *\n   * @param {string | object | null} [arg1]\n   * Valid options are:<ul>\n   * <li>`Object` - Key/value pairs to update on the object.</li>\n   * <li>`String` Key - Key of attribute to update (requires arg2 to also be string)</li>\n   * <li>`null` - Passing null for arg1 allows you to save the object with options passed in arg2.</li>\n   * </ul>\n   * @param {string | object} [arg2]\n   * <ul>\n   * <li>`String` Value - If arg1 was passed as a key, arg2 is the value that should be set on that key.</li>\n   * <li>`Object` Options - Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * </li>\n   * </ul>\n   * @param {object} [arg3]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n  save(arg1, arg2, arg3) {\n    let attrs;\n    let options;\n    if (typeof arg1 === 'object' || typeof arg1 === 'undefined') {\n      attrs = arg1;\n      if (typeof arg2 === 'object') {\n        options = arg2;\n      }\n    } else {\n      attrs = {};\n      attrs[arg1] = arg2;\n      options = arg3;\n    }\n    options = options || {};\n    if (attrs) {\n      let validationError;\n      options.error = (_, validation) => {\n        validationError = validation;\n      };\n      const success = this.set(attrs, options);\n      if (!success) {\n        return _promise.default.reject(validationError);\n      }\n    }\n    const saveOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      saveOptions.useMasterKey = !!options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken') && typeof options.sessionToken === 'string') {\n      saveOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('installationId') && typeof options.installationId === 'string') {\n      saveOptions.installationId = options.installationId;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      saveOptions.context = options.context;\n    }\n    const controller = _CoreManager.default.getObjectController();\n    const unsaved = options.cascadeSave !== false ? (0, _unsavedChildren.default)(this) : null;\n    return controller.save(unsaved, saveOptions).then(() => {\n      return controller.save(this, saveOptions);\n    });\n  }\n\n  /**\n   * Deletes this object from the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection,\n   * and don't need to know when the delete completes. If there is some problem with the object\n   * such that it can't be deleted, the request will be silently discarded.\n   *\n   * Delete instructions made with this method will be stored locally in an on-disk cache until they can be transmitted\n   * to Parse. They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection\n   * is available. Delete requests will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n  async destroyEventually(options) {\n    try {\n      await this.destroy(options);\n    } catch (e) {\n      if (e.code === _ParseError.default.CONNECTION_FAILED) {\n        await _CoreManager.default.getEventuallyQueue().destroy(this, options);\n        _CoreManager.default.getEventuallyQueue().poll();\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Destroy this model on the server if it was already persisted.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n  destroy(options) {\n    options = options || {};\n    const destroyOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      destroyOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      destroyOptions.context = options.context;\n    }\n    if (!this.id) {\n      return _promise.default.resolve();\n    }\n    return _CoreManager.default.getObjectController().destroy(this, destroyOptions);\n  }\n\n  /**\n   * Asynchronously stores the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pin();\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n  pin() {\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await object.unPin();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n  unPin() {\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n\n  /**\n   * Asynchronously returns if the object is pinned\n   *\n   * <pre>\n   * const isPinned = await object.isPinned();\n   * </pre>\n   *\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object is pinned.\n   */\n  async isPinned() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pin = await localDatastore.fromPinWithName(objectKey);\n    return pin.length > 0;\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pinWithName(name);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n  pinWithName(name) {\n    return ParseObject.pinAllWithName(name, [this]);\n  }\n\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore, recursively.\n   *\n   * <pre>\n   * await object.unPinWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n  unPinWithName(name) {\n    return ParseObject.unPinAllWithName(name, [this]);\n  }\n\n  /**\n   * Asynchronously loads data from the local datastore into this object.\n   *\n   * <pre>\n   * await object.fetchFromLocalDatastore();\n   * </pre>\n   *\n   * You can create an unfetched pointer with <code>Parse.Object.createWithoutData()</code>\n   * and then call <code>fetchFromLocalDatastore()</code> on it.\n   *\n   * @returns {Promise} A promise that is fulfilled when the fetch completes.\n   */\n  async fetchFromLocalDatastore() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      throw new Error('Parse.enableLocalDatastore() must be called first');\n    }\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pinned = await localDatastore._serializeObject(objectKey);\n    if (!pinned) {\n      throw new Error('Cannot fetch an unsaved ParseObject');\n    }\n    const result = ParseObject.fromJSON(pinned);\n    this._finishFetch(result.toJSON());\n    return this;\n  }\n\n  /* Static methods */\n\n  static _clearAllState() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.clearAllState();\n  }\n\n  /**\n   * Fetches the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAll([object1, object2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAll(list) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const queryOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      queryOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      queryOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('include')) {\n      queryOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n    return _CoreManager.default.getObjectController().fetch(list, true, queryOptions);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllWithInclude(list, keys, options) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAll(list, options);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeededWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllIfNeededWithInclude(list, keys, options) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAllIfNeeded(list, options);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeeded([object1, ...])\n   *    .then((list) => {\n   *      // Objects were fetched and updated.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllIfNeeded(list, options) {\n    options = options || {};\n    const queryOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      queryOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      queryOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('include')) {\n      queryOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n    return _CoreManager.default.getObjectController().fetch(list, false, queryOptions);\n  }\n  static handleIncludeOptions(options) {\n    let include = [];\n    if ((0, _isArray.default)(options.include)) {\n      var _context3;\n      (0, _forEach.default)(_context3 = options.include).call(_context3, key => {\n        if ((0, _isArray.default)(key)) {\n          include = (0, _concat.default)(include).call(include, key);\n        } else {\n          include.push(key);\n        }\n      });\n    } else {\n      include.push(options.include);\n    }\n    return include;\n  }\n\n  /**\n   * Destroy the given list of models on the server if it was already persisted.\n   *\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n   * this method will continue trying to delete the rest of the models if\n   * possible, except in the case of a fatal error like a connection error.\n   *\n   * <p>In particular, the Parse.Error object returned in the case of error may\n   * be one of two types:\n   *\n   * <ul>\n   * <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n   * array of other Parse.Error objects. Each error object in this array\n   * has an \"object\" property that references the object that could not be\n   * deleted (for instance, because that object could not be found).</li>\n   * <li>A non-aggregate Parse.Error. This indicates a serious error that\n   * caused the delete operation to be aborted partway through (for\n   * instance, a connection failure in the middle of the delete).</li>\n   * </ul>\n   *\n   * <pre>\n   * Parse.Object.destroyAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were deleted.\n   * }, (error) => {\n   * // An error occurred while deleting one or more of the objects.\n   * // If this is an aggregate error, then we can inspect each error\n   * // object individually to determine the reason why a particular\n   * // object was not deleted.\n   * if (error.code === Parse.Error.AGGREGATE_ERROR) {\n   * for (var i = 0; i < error.errors.length; i++) {\n   * console.log(\"Couldn't delete \" + error.errors[i].object.id +\n   * \"due to \" + error.errors[i].message);\n   * }\n   * } else {\n   * console.log(\"Delete aborted because of \" + error.message);\n   * }\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled when the destroyAll\n   * completes.\n   */\n  static destroyAll(list) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const destroyOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      destroyOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      destroyOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n      destroyOptions.batchSize = options.batchSize;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      destroyOptions.context = options.context;\n    }\n    return _CoreManager.default.getObjectController().destroy(list, destroyOptions);\n  }\n\n  /**\n   * Saves the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   * Parse.Object.saveAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were saved.\n   * }, (error) => {\n   * // An error occurred while saving one of the objects.\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static saveAll(list) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const saveOptions = {};\n    if (options.hasOwnProperty('useMasterKey')) {\n      saveOptions.useMasterKey = options.useMasterKey;\n    }\n    if (options.hasOwnProperty('sessionToken')) {\n      saveOptions.sessionToken = options.sessionToken;\n    }\n    if (options.hasOwnProperty('batchSize') && typeof options.batchSize === 'number') {\n      saveOptions.batchSize = options.batchSize;\n    }\n    if (options.hasOwnProperty('context') && typeof options.context === 'object') {\n      saveOptions.context = options.context;\n    }\n    return _CoreManager.default.getObjectController().save(list, saveOptions);\n  }\n\n  /**\n   * Creates a reference to a subclass of Parse.Object with the given id. This\n   * does not exist on Parse.Object, only on subclasses.\n   *\n   * <p>A shortcut for: <pre>\n   *  var Foo = Parse.Object.extend(\"Foo\");\n   *  var pointerToFoo = new Foo();\n   *  pointerToFoo.id = \"myObjectId\";\n   * </pre>\n   *\n   * @param {string} id The ID of the object to create a reference to.\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference.\n   */\n  static createWithoutData(id) {\n    const obj = new this();\n    obj.id = id;\n    return obj;\n  }\n\n  /**\n   * Creates a new instance of a Parse Object from a JSON representation.\n   *\n   * @param {object} json The JSON map of the Object's data\n   * @param {boolean} override In single instance mode, all old server data\n   *   is overwritten if this is set to true\n   * @param {boolean} dirty Whether the Parse.Object should set JSON keys to dirty\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference\n   */\n  static fromJSON(json, override, dirty) {\n    if (!json.className) {\n      throw new Error('Cannot create an object without a className');\n    }\n    const constructor = classMap[json.className];\n    const o = constructor ? new constructor(json.className) : new ParseObject(json.className);\n    const otherAttributes = {};\n    for (const attr in json) {\n      if (attr !== 'className' && attr !== '__type') {\n        otherAttributes[attr] = json[attr];\n        if (dirty) {\n          o.set(attr, json[attr]);\n        }\n      }\n    }\n    if (override) {\n      // id needs to be set before clearServerData can work\n      if (otherAttributes.objectId) {\n        o.id = otherAttributes.objectId;\n      }\n      let preserved = null;\n      if (typeof o._preserveFieldsOnFetch === 'function') {\n        preserved = o._preserveFieldsOnFetch();\n      }\n      o._clearServerData();\n      if (preserved) {\n        o._finishFetch(preserved);\n      }\n    }\n    o._finishFetch(otherAttributes);\n    if (json.objectId) {\n      o._setExisted(true);\n    }\n    return o;\n  }\n\n  /**\n   * Registers a subclass of Parse.Object with a specific class name.\n   * When objects of that class are retrieved from a query, they will be\n   * instantiated with this subclass.\n   * This is only necessary when using ES6 subclassing.\n   *\n   * @param {string} className The class name of the subclass\n   * @param {Function} constructor The subclass\n   */\n  static registerSubclass(className, constructor) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n    if (typeof constructor === 'undefined') {\n      throw new TypeError('You must supply a subclass constructor.');\n    }\n    if (typeof constructor !== 'function') {\n      throw new TypeError('You must register the subclass constructor. ' + 'Did you attempt to register an instance of the subclass?');\n    }\n    classMap[className] = constructor;\n    if (!constructor.className) {\n      constructor.className = className;\n    }\n  }\n\n  /**\n   * Unegisters a subclass of Parse.Object with a specific class name.\n   *\n   * @param {string} className The class name of the subclass\n   */\n  static unregisterSubclass(className) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n    delete classMap[className];\n  }\n\n  /**\n   * Creates a new subclass of Parse.Object for the given Parse class name.\n   *\n   * <p>Every extension of a Parse class will inherit from the most recent\n   * previous extension of that class. When a Parse.Object is automatically\n   * created by parsing JSON, it will use the most recent extension of that\n   * class.</p>\n   *\n   * <p>You should call either:<pre>\n   *     var MyClass = Parse.Object.extend(\"MyClass\", {\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre>\n   * or, for Backbone compatibility:<pre>\n   *     var MyClass = Parse.Object.extend({\n   *         className: \"MyClass\",\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre></p>\n   *\n   * @param {string} className The name of the Parse class backing this model.\n   * @param {object} [protoProps] Instance properties to add to instances of the\n   *     class returned from this method.\n   * @param {object} [classProps] Class properties to add the class returned from\n   *     this method.\n   * @returns {Parse.Object} A new subclass of Parse.Object.\n   */\n  static extend(className, protoProps, classProps) {\n    if (typeof className !== 'string') {\n      if (className && typeof className.className === 'string') {\n        return ParseObject.extend(className.className, className, protoProps);\n      } else {\n        throw new Error(\"Parse.Object.extend's first argument should be the className.\");\n      }\n    }\n    let adjustedClassName = className;\n    if (adjustedClassName === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n      adjustedClassName = '_User';\n    }\n    let parentProto = ParseObject.prototype;\n    if (this.hasOwnProperty('__super__') && this.__super__) {\n      parentProto = this.prototype;\n    }\n    let ParseObjectSubclass = function (attributes, options) {\n      this.className = adjustedClassName;\n      this._objCount = objectCount++;\n      // Enable legacy initializers\n      if (typeof this.initialize === 'function') {\n        this.initialize.apply(this, arguments);\n      }\n      if (this._initializers) {\n        for (const initializer of this._initializers) {\n          initializer.apply(this, arguments);\n        }\n      }\n      if (attributes && typeof attributes === 'object') {\n        if (!this.set(attributes || {}, options)) {\n          throw new Error(\"Can't create an invalid Parse Object\");\n        }\n      }\n    };\n    if (classMap[adjustedClassName]) {\n      ParseObjectSubclass = classMap[adjustedClassName];\n    } else {\n      ParseObjectSubclass.extend = function (name, protoProps, classProps) {\n        if (typeof name === 'string') {\n          return ParseObject.extend.call(ParseObjectSubclass, name, protoProps, classProps);\n        }\n        return ParseObject.extend.call(ParseObjectSubclass, adjustedClassName, name, protoProps);\n      };\n      ParseObjectSubclass.createWithoutData = ParseObject.createWithoutData;\n      ParseObjectSubclass.className = adjustedClassName;\n      ParseObjectSubclass.__super__ = parentProto;\n      ParseObjectSubclass.prototype = (0, _create.default)(parentProto, {\n        constructor: {\n          value: ParseObjectSubclass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop === 'initialize') {\n          (0, _defineProperty3.default)(ParseObjectSubclass.prototype, '_initializers', {\n            value: [...(ParseObjectSubclass.prototype._initializers || []), protoProps[prop]],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n          continue;\n        }\n        if (prop !== 'className') {\n          (0, _defineProperty3.default)(ParseObjectSubclass.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty3.default)(ParseObjectSubclass, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    classMap[adjustedClassName] = ParseObjectSubclass;\n    return ParseObjectSubclass;\n  }\n\n  /**\n   * Enable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * This is disabled by default in server environments, since it can lead to\n   * security issues.\n   *\n   * @static\n   */\n  static enableSingleInstance() {\n    singleInstance = true;\n    _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n  }\n\n  /**\n   * Disable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * When disabled, you can have two instances of the same object in memory\n   * without them sharing attributes.\n   *\n   * @static\n   */\n  static disableSingleInstance() {\n    singleInstance = false;\n    _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAll([...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n  static pinAll(objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n  static pinAllWithName(name, objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore._handlePinAllWithName(name, objects);\n  }\n\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAll([...]);\n   * </pre>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAll(objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore, recursively.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllWithName(name, objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore._handleUnPinAllWithName(name, objects);\n  }\n\n  /**\n   * Asynchronously removes all objects in the local datastore using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjects();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllObjects() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n\n  /**\n   * Asynchronously removes all objects with the specified pin name.\n   * Deletes the pin name also.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjectsWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllObjectsWithName(name) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.PIN_PREFIX + name);\n  }\n}\nconst DefaultController = {\n  fetch(target, forceFetch, options) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      const objs = [];\n      const ids = [];\n      let className = null;\n      const results = [];\n      let error = null;\n      (0, _forEach.default)(target).call(target, el => {\n        if (error) {\n          return;\n        }\n        if (!className) {\n          className = el.className;\n        }\n        if (className !== el.className) {\n          error = new _ParseError.default(_ParseError.default.INVALID_CLASS_NAME, 'All objects should be of the same class');\n        }\n        if (!el.id) {\n          error = new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'All objects must have an ID');\n        }\n        if (forceFetch || !el.isDataAvailable()) {\n          ids.push(el.id);\n          objs.push(el);\n        }\n        results.push(el);\n      });\n      if (error) {\n        return _promise.default.reject(error);\n      }\n      const ParseQuery = _CoreManager.default.getParseQuery();\n      const query = new ParseQuery(className);\n      query.containedIn('objectId', ids);\n      if (options && options.include) {\n        query.include(options.include);\n      }\n      query._limit = ids.length;\n      return (0, _find.default)(query).call(query, options).then(async objects => {\n        const idMap = {};\n        (0, _forEach.default)(objects).call(objects, o => {\n          idMap[o.id] = o;\n        });\n        for (let i = 0; i < objs.length; i++) {\n          const obj = objs[i];\n          if (!obj || !obj.id || !idMap[obj.id]) {\n            if (forceFetch) {\n              return _promise.default.reject(new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'All objects must exist on the server.'));\n            }\n          }\n        }\n        if (!singleInstance) {\n          // If single instance objects are disabled, we need to replace the\n          for (let i = 0; i < results.length; i++) {\n            const obj = results[i];\n            if (obj && obj.id && idMap[obj.id]) {\n              const id = obj.id;\n              obj._finishFetch(idMap[id].toJSON());\n              results[i] = idMap[id];\n            }\n          }\n        }\n        for (const object of results) {\n          await localDatastore._updateObjectIfPinned(object);\n        }\n        return _promise.default.resolve(results);\n      });\n    } else if (target instanceof ParseObject) {\n      if (!target.id) {\n        return _promise.default.reject(new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'Object does not have an ID'));\n      }\n      const RESTController = _CoreManager.default.getRESTController();\n      const params = {};\n      if (options && options.include) {\n        params.include = options.include.join();\n      }\n      return RESTController.request('GET', 'classes/' + target.className + '/' + target._getId(), params, options).then(async response => {\n        target._clearPendingOps();\n        target._clearServerData();\n        target._finishFetch(response);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      });\n    }\n    return _promise.default.resolve(undefined);\n  },\n  async destroy(target, options) {\n    const batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const RESTController = _CoreManager.default.getRESTController();\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      const batches = [[]];\n      (0, _forEach.default)(target).call(target, obj => {\n        if (!obj.id) {\n          return;\n        }\n        batches[batches.length - 1].push(obj);\n        if (batches[batches.length - 1].length >= batchSize) {\n          batches.push([]);\n        }\n      });\n      if (batches[batches.length - 1].length === 0) {\n        // If the last batch is empty, remove it\n        batches.pop();\n      }\n      let deleteCompleted = _promise.default.resolve();\n      const errors = [];\n      (0, _forEach.default)(batches).call(batches, batch => {\n        deleteCompleted = deleteCompleted.then(() => {\n          return RESTController.request('POST', 'batch', {\n            requests: (0, _map.default)(batch).call(batch, obj => {\n              return {\n                method: 'DELETE',\n                path: getServerUrlPath() + 'classes/' + obj.className + '/' + obj._getId(),\n                body: {}\n              };\n            })\n          }, options).then(results => {\n            for (let i = 0; i < results.length; i++) {\n              if (results[i] && results[i].hasOwnProperty('error')) {\n                const err = new _ParseError.default(results[i].error.code, results[i].error.error);\n                err.object = batch[i];\n                errors.push(err);\n              }\n            }\n          });\n        });\n      });\n      return deleteCompleted.then(async () => {\n        if (errors.length) {\n          const aggregate = new _ParseError.default(_ParseError.default.AGGREGATE_ERROR);\n          aggregate.errors = errors;\n          return _promise.default.reject(aggregate);\n        }\n        for (const object of target) {\n          await localDatastore._destroyObjectIfPinned(object);\n        }\n        return _promise.default.resolve(target);\n      });\n    } else if (target instanceof ParseObject) {\n      return RESTController.request('DELETE', 'classes/' + target.className + '/' + target._getId(), {}, options).then(async () => {\n        await localDatastore._destroyObjectIfPinned(target);\n        return _promise.default.resolve(target);\n      });\n    }\n    return _promise.default.resolve(target);\n  },\n  save(target, options) {\n    const batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const mapIdForPin = {};\n    const RESTController = _CoreManager.default.getRESTController();\n    const stateController = _CoreManager.default.getObjectStateController();\n    const allowCustomObjectId = _CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID');\n    options = options || {};\n    options.returnStatus = options.returnStatus || true;\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      let unsaved = (0, _concat.default)(target).call(target);\n      for (let i = 0; i < target.length; i++) {\n        const target_i = target[i];\n        if (target_i instanceof ParseObject) {\n          unsaved = (0, _concat.default)(unsaved).call(unsaved, (0, _unsavedChildren.default)(target_i, true));\n        }\n      }\n      unsaved = (0, _unique.default)(unsaved);\n      const filesSaved = [];\n      let pending = [];\n      (0, _forEach.default)(unsaved).call(unsaved, el => {\n        if (el instanceof _ParseFile.default) {\n          filesSaved.push(el.save(options));\n        } else if (el instanceof ParseObject) {\n          pending.push(el);\n        }\n      });\n      return _promise.default.all(filesSaved).then(() => {\n        let objectError = null;\n        return (0, _promiseUtils.continueWhile)(() => {\n          return pending.length > 0;\n        }, () => {\n          const batch = [];\n          const nextPending = [];\n          (0, _forEach.default)(pending).call(pending, el => {\n            if (allowCustomObjectId && Object.prototype.hasOwnProperty.call(el, 'id') && !el.id) {\n              throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty or null');\n            }\n            if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {\n              batch.push(el);\n            } else {\n              nextPending.push(el);\n            }\n          });\n          pending = nextPending;\n          if (batch.length < 1) {\n            return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a batch with a cycle.'));\n          }\n\n          // Queue up tasks for each object in the batch.\n          // When every task is ready, the API request will execute\n          const batchReturned = (0, _promiseUtils.resolvingPromise)();\n          const batchReady = [];\n          const batchTasks = [];\n          (0, _forEach.default)(batch).call(batch, (obj, index) => {\n            const ready = (0, _promiseUtils.resolvingPromise)();\n            batchReady.push(ready);\n            stateController.pushPendingState(obj._getStateIdentifier());\n            batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function () {\n              ready.resolve();\n              return batchReturned.then(responses => {\n                if (responses[index].hasOwnProperty('success')) {\n                  const objectId = responses[index].success.objectId;\n                  const status = responses[index]._status;\n                  delete responses[index]._status;\n                  delete responses[index]._headers;\n                  delete responses[index]._xhr;\n                  mapIdForPin[objectId] = obj._localId;\n                  obj._handleSaveResponse(responses[index].success, status);\n                } else {\n                  if (!objectError && responses[index].hasOwnProperty('error')) {\n                    const serverError = responses[index].error;\n                    objectError = new _ParseError.default(serverError.code, serverError.error);\n                    // Cancel the rest of the save\n                    pending = [];\n                  }\n                  obj._handleSaveError();\n                }\n              });\n            }));\n          });\n          (0, _promiseUtils.when)(batchReady).then(() => {\n            // Kick off the batch request\n            return RESTController.request('POST', 'batch', {\n              requests: (0, _map.default)(batch).call(batch, obj => {\n                const params = obj._getSaveParams();\n                params.path = getServerUrlPath() + params.path;\n                return params;\n              })\n            }, options);\n          }).then(batchReturned.resolve, error => {\n            batchReturned.reject(new _ParseError.default(_ParseError.default.INCORRECT_TYPE, error.message));\n          });\n          return (0, _promiseUtils.when)(batchTasks);\n        }).then(async () => {\n          if (objectError) {\n            return _promise.default.reject(objectError);\n          }\n          for (const object of target) {\n            // Make sure that it is a ParseObject before updating it into the localDataStore\n            if (object instanceof ParseObject) {\n              await localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);\n              await localDatastore._updateObjectIfPinned(object);\n            }\n          }\n          return _promise.default.resolve(target);\n        });\n      });\n    } else if (target instanceof ParseObject) {\n      if (allowCustomObjectId && Object.prototype.hasOwnProperty.call(target, 'id') && !target.id) {\n        throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty or null');\n      }\n      // generate _localId in case if cascadeSave=false\n      target._getId();\n      const localId = target._localId;\n      // copying target lets guarantee the pointer isn't modified elsewhere\n      const targetCopy = target;\n      const task = function () {\n        const params = targetCopy._getSaveParams();\n        return RESTController.request(params.method, params.path, params.body, options).then(response => {\n          const status = response._status;\n          delete response._status;\n          delete response._headers;\n          delete response._xhr;\n          targetCopy._handleSaveResponse(response, status);\n        }, error => {\n          targetCopy._handleSaveError();\n          return _promise.default.reject(error);\n        });\n      };\n      stateController.pushPendingState(target._getStateIdentifier());\n      return stateController.enqueueTask(target._getStateIdentifier(), task).then(async () => {\n        await localDatastore._updateLocalIdForObject(localId, target);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      }, error => {\n        return _promise.default.reject(error);\n      });\n    }\n    return _promise.default.resolve(undefined);\n  }\n};\n_CoreManager.default.setParseObject(ParseObject);\n_CoreManager.default.setObjectController(DefaultController);\nvar _default = exports.default = ParseObject;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}