{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\nconst PUBLIC_KEY = '*';\nconst VALID_PERMISSIONS = new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nconst VALID_PERMISSIONS_EXTENDED = new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\nclass ParseCLP {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  constructor(userId) {\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {};\n    // Initialize permissions Map with default permissions\n    for (const [operation, group] of (0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)) {\n      this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      const action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n      this[`get${action}RequiresAuthentication`] = function () {\n        return this._getAccess(operation, 'requiresAuthentication');\n      };\n      this[`set${action}RequiresAuthentication`] = function (allowed) {\n        this._setAccess(operation, 'requiresAuthentication', allowed);\n      };\n      this[`get${action}PointerFields`] = function () {\n        return this._getAccess(operation, 'pointerFields', false);\n      };\n      this[`set${action}PointerFields`] = function (pointerFields) {\n        this._setArrayAccess(operation, 'pointerFields', pointerFields);\n      };\n      this[`get${action}Access`] = function (entity) {\n        return this._getAccess(operation, entity);\n      };\n      this[`set${action}Access`] = function (entity, allowed) {\n        this._setAccess(operation, entity, allowed);\n      };\n      this[`getPublic${action}Access`] = function () {\n        return this[`get${action}Access`](PUBLIC_KEY);\n      };\n      this[`setPublic${action}Access`] = function (allowed) {\n        this[`set${action}Access`](PUBLIC_KEY, allowed);\n      };\n      this[`getRole${action}Access`] = function (role) {\n        return this[`get${action}Access`](this._getRoleName(role));\n      };\n      this[`setRole${action}Access`] = function (role, allowed) {\n        this[`set${action}Access`](this._getRoleName(role), allowed);\n      };\n    }\n    // Initialize permissions Map with default extended permissions\n    for (const [operation, group] of (0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)) {\n      this.permissionsMap[operation] = (0, _assign.default)({}, group);\n    }\n    if (userId && typeof userId === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (const permission in userId) {\n          var _context;\n          const users = userId[permission];\n          const isValidPermission = !!VALID_PERMISSIONS.get(permission);\n          const isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(permission);\n          const isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, permission);\n          if (typeof permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, pointer => typeof pointer === 'string')) {\n              this.permissionsMap[permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n          for (const user in users) {\n            const allowed = users[user];\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n            this.permissionsMap[permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    return {\n      ...this.permissionsMap\n    };\n  }\n\n  /**\n   * Returns whether this CLP is equal to another object\n   *\n   * @param other The other object to compare to\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (!(other instanceof ParseCLP)) {\n      return false;\n    }\n    const permissions = (0, _keys.default)(this.permissionsMap);\n    const otherPermissions = (0, _keys.default)(other.permissionsMap);\n    if (permissions.length !== otherPermissions.length) {\n      return false;\n    }\n    for (const permission in this.permissionsMap) {\n      if (!other.permissionsMap[permission]) {\n        return false;\n      }\n      const users = (0, _keys.default)(this.permissionsMap[permission]);\n      const otherUsers = (0, _keys.default)(other.permissionsMap[permission]);\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n      for (const user in this.permissionsMap[permission]) {\n        if (!other.permissionsMap[permission][user]) {\n          return false;\n        }\n        if (this.permissionsMap[permission][user] !== other.permissionsMap[permission][user]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  _getRoleName(role) {\n    let name = role;\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      name = role.getName();\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('role must be a Parse.Role or a String');\n    }\n    return `role:${name}`;\n  }\n  _parseEntity(entity) {\n    let userId = entity;\n    if (userId instanceof _ParseUser.default) {\n      userId = userId.id;\n      if (!userId) {\n        throw new Error('Cannot get access for a Parse.User without an id.');\n      }\n    } else if (userId instanceof _ParseRole.default) {\n      userId = this._getRoleName(userId);\n    }\n    if (typeof userId !== 'string') {\n      throw new TypeError('userId must be a string.');\n    }\n    return userId;\n  }\n  _setAccess(permission, userId, allowed) {\n    userId = this._parseEntity(userId);\n    if (typeof allowed !== 'boolean') {\n      throw new TypeError('allowed must be either true or false.');\n    }\n    const permissions = this.permissionsMap[permission][userId];\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action is needed\n        return;\n      } else {\n        this.permissionsMap[permission][userId] = {};\n      }\n    }\n    if (allowed) {\n      this.permissionsMap[permission][userId] = true;\n    } else {\n      delete this.permissionsMap[permission][userId];\n    }\n  }\n  _getAccess(permission, userId) {\n    let returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    userId = this._parseEntity(userId);\n    const permissions = this.permissionsMap[permission][userId];\n    if (returnBoolean) {\n      if (!permissions) {\n        return false;\n      }\n      return !!this.permissionsMap[permission][userId];\n    }\n    return permissions;\n  }\n  _setArrayAccess(permission, userId, fields) {\n    userId = this._parseEntity(userId);\n    const permissions = this.permissionsMap[permission][userId];\n    if (!permissions) {\n      this.permissionsMap[permission][userId] = [];\n    }\n    if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n      delete this.permissionsMap[permission][userId];\n    } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, field => typeof field === 'string')) {\n      this.permissionsMap[permission][userId] = fields;\n    } else {\n      throw new TypeError('fields must be an array of strings or undefined.');\n    }\n  }\n  _setGroupPointerPermission(operation, pointerFields) {\n    const fields = this.permissionsMap[operation];\n    if (!fields) {\n      this.permissionsMap[operation] = [];\n    }\n    if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n      delete this.permissionsMap[operation];\n    } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, field => typeof field === 'string')) {\n      this.permissionsMap[operation] = pointerFields;\n    } else {\n      throw new TypeError(`${operation}.pointerFields must be an array of strings or undefined.`);\n    }\n  }\n  _getGroupPointerPermissions(operation) {\n    return this.permissionsMap[operation] || [];\n  }\n\n  /**\n   * Sets user pointer fields to allow permission for get/count/find operations.\n   *\n   * @param {string[]} pointerFields User pointer fields\n   */\n  setReadUserFields(pointerFields) {\n    this._setGroupPointerPermission('readUserFields', pointerFields);\n  }\n\n  /**\n   * @returns {string[]} User pointer fields\n   */\n  getReadUserFields() {\n    return this._getGroupPointerPermissions('readUserFields') || [];\n  }\n\n  /**\n   * Sets user pointer fields to allow permission for create/delete/update/addField operations\n   *\n   * @param {string[]} pointerFields User pointer fields\n   */\n  setWriteUserFields(pointerFields) {\n    this._setGroupPointerPermission('writeUserFields', pointerFields);\n  }\n\n  /**\n   * @returns {string[]} User pointer fields\n   */\n  getWriteUserFields() {\n    return this._getGroupPointerPermissions('writeUserFields') || [];\n  }\n\n  /**\n   * Sets whether the given user is allowed to retrieve fields from this class.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {string[]} fields fields to be protected\n   */\n  setProtectedFields(userId, fields) {\n    this._setArrayAccess('protectedFields', userId, fields);\n  }\n\n  /**\n   * Returns array of fields are accessable to this user.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {string[]}\n   */\n  getProtectedFields(userId) {\n    return this._getAccess('protectedFields', userId, false);\n  }\n\n  /**\n   * Sets whether the given user is allowed to read from this class.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {boolean} allowed whether that user should have read access.\n   */\n  setReadAccess(userId, allowed) {\n    this._setAccess('find', userId, allowed);\n    this._setAccess('get', userId, allowed);\n    this._setAccess('count', userId, allowed);\n  }\n\n  /**\n   * Get whether the given user id is *explicitly* allowed to read from this class.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n  getReadAccess(userId) {\n    return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n  }\n\n  /**\n   * Sets whether the given user id is allowed to write to this class.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {boolean} allowed Whether that user should have write access.\n   */\n  setWriteAccess(userId, allowed) {\n    this._setAccess('create', userId, allowed);\n    this._setAccess('update', userId, allowed);\n    this._setAccess('delete', userId, allowed);\n    this._setAccess('addField', userId, allowed);\n  }\n\n  /**\n   * Gets whether the given user id is *explicitly* allowed to write to this class.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n  getWriteAccess(userId) {\n    return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n  }\n\n  /**\n   * Sets whether the public is allowed to read from this class.\n   *\n   * @param {boolean} allowed\n   */\n  setPublicReadAccess(allowed) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  }\n\n  /**\n   * Gets whether the public is allowed to read from this class.\n   *\n   * @returns {boolean}\n   */\n  getPublicReadAccess() {\n    return this.getReadAccess(PUBLIC_KEY);\n  }\n\n  /**\n   * Sets whether the public is allowed to write to this class.\n   *\n   * @param {boolean} allowed\n   */\n  setPublicWriteAccess(allowed) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  }\n\n  /**\n   * Gets whether the public is allowed to write to this class.\n   *\n   * @returns {boolean}\n   */\n  getPublicWriteAccess() {\n    return this.getWriteAccess(PUBLIC_KEY);\n  }\n\n  /**\n   * Sets whether the public is allowed to protect fields in this class.\n   *\n   * @param {string[]} fields\n   */\n  setPublicProtectedFields(fields) {\n    this.setProtectedFields(PUBLIC_KEY, fields);\n  }\n\n  /**\n   * Gets whether the public is allowed to read fields from this class.\n   *\n   * @returns {string[]}\n   */\n  getPublicProtectedFields() {\n    return this.getProtectedFields(PUBLIC_KEY);\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to read from this class. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has read access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleReadAccess(role) {\n    return this.getReadAccess(this._getRoleName(role));\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to write to this user. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has write access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleWriteAccess(role) {\n    return this.getWriteAccess(this._getRoleName(role));\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to read from this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can read this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleReadAccess(role, allowed) {\n    this.setReadAccess(this._getRoleName(role), allowed);\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to write to this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can write this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleWriteAccess(role, allowed) {\n    this.setWriteAccess(this._getRoleName(role), allowed);\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to count to this user. Even if this returns false, the role may\n   * still be able to count it if a parent role has count access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {string[]}\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleProtectedFields(role) {\n    return this.getProtectedFields(this._getRoleName(role));\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to set access field in this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {string[]} fields Fields to be protected by Role.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleProtectedFields(role, fields) {\n    this.setProtectedFields(this._getRoleName(role), fields);\n  }\n}\nvar _default = exports.default = ParseCLP;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_defineProperty2","_map","_entries","_assign","_slice","_includes","_every","_keys","_isArray","_ParseRole","_ParseUser","PUBLIC_KEY","VALID_PERMISSIONS","set","VALID_PERMISSIONS_EXTENDED","ParseCLP","constructor","userId","permissionsMap","operation","group","call","action","charAt","toUpperCase","_getAccess","allowed","_setAccess","pointerFields","_setArrayAccess","entity","role","_getRoleName","setReadAccess","setWriteAccess","setRoleReadAccess","setRoleWriteAccess","permission","_context","users","isValidPermission","get","isValidPermissionExtended","isValidGroupPermission","TypeError","pointer","user","toJSON","equals","other","permissions","otherPermissions","length","otherUsers","name","getName","_parseEntity","id","Error","returnBoolean","arguments","undefined","fields","field","_setGroupPointerPermission","_getGroupPointerPermissions","setReadUserFields","getReadUserFields","setWriteUserFields","getWriteUserFields","setProtectedFields","getProtectedFields","getReadAccess","getWriteAccess","setPublicReadAccess","getPublicReadAccess","setPublicWriteAccess","getPublicWriteAccess","setPublicProtectedFields","getPublicProtectedFields","getRoleReadAccess","getRoleWriteAccess","getRoleProtectedFields","setRoleProtectedFields","_default"],"sources":["/home/mavrik/Documents/classes/web-dev/feature05/node_modules/parse/lib/browser/ParseCLP.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/entries\"));\nvar _assign = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/assign\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _every = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/every\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _ParseRole = _interopRequireDefault(require(\"./ParseRole\"));\nvar _ParseUser = _interopRequireDefault(require(\"./ParseUser\"));\nconst PUBLIC_KEY = '*';\nconst VALID_PERMISSIONS = new _map.default();\nVALID_PERMISSIONS.set('get', {});\nVALID_PERMISSIONS.set('find', {});\nVALID_PERMISSIONS.set('count', {});\nVALID_PERMISSIONS.set('create', {});\nVALID_PERMISSIONS.set('update', {});\nVALID_PERMISSIONS.set('delete', {});\nVALID_PERMISSIONS.set('addField', {});\nconst VALID_PERMISSIONS_EXTENDED = new _map.default();\nVALID_PERMISSIONS_EXTENDED.set('protectedFields', {});\n\n/**\n * Creates a new CLP.\n * If no argument is given, the CLP has no permissions for anyone.\n * If the argument is a Parse.User or Parse.Role, the CLP will have read and write\n *   permission for only that user or role.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized CLP created with toJSON().\n *\n * <p>A CLP, or Class Level Permissions can be added to any\n * <code>Parse.Schema</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * <p>\n * For get/count/find/create/update/delete/addField using the following functions:\n *\n * Entity is type Parse.User or Parse.Role or string\n * Role is type Parse.Role or Name of Parse.Role\n *\n * getGetRequiresAuthentication()\n * setGetRequiresAuthentication(allowed: boolean)\n * getGetPointerFields()\n * setGetPointerFields(pointerFields: string[])\n * getGetAccess(entity: Entity)\n * setGetAccess(entity: Entity, allowed: boolean)\n * getPublicGetAccess()\n * setPublicGetAccess(allowed: boolean)\n * getRoleGetAccess(role: Role)\n * setRoleGetAccess(role: Role, allowed: boolean)\n * getFindRequiresAuthentication()\n * setFindRequiresAuthentication(allowed: boolean)\n * getFindPointerFields()\n * setFindPointerFields(pointerFields: string[])\n * getFindAccess(entity: Entity)\n * setFindAccess(entity: Entity, allowed: boolean)\n * getPublicFindAccess()\n * setPublicFindAccess(allowed: boolean)\n * getRoleFindAccess(role: Role)\n * setRoleFindAccess(role: Role, allowed: boolean)\n * getCountRequiresAuthentication()\n * setCountRequiresAuthentication(allowed: boolean)\n * getCountPointerFields()\n * setCountPointerFields(pointerFields: string[])\n * getCountAccess(entity: Entity)\n * setCountAccess(entity: Entity, allowed: boolean)\n * getPublicCountAccess()\n * setPublicCountAccess(allowed: boolean)\n * getRoleCountAccess(role: Role)\n * setRoleCountAccess(role: Role, allowed: boolean)\n * getCreateRequiresAuthentication()\n * setCreateRequiresAuthentication(allowed: boolean)\n * getCreatePointerFields()\n * setCreatePointerFields(pointerFields: string[])\n * getCreateAccess(entity: Entity)\n * setCreateAccess(entity: Entity, allowed: boolean)\n * getPublicCreateAccess()\n * setPublicCreateAccess(allowed: Boolean)\n * getRoleCreateAccess(role: Role)\n * setRoleCreateAccess(role: Role, allowed: boolean)\n * getUpdateRequiresAuthentication()\n * setUpdateRequiresAuthentication(allowed: boolean)\n * getUpdatePointerFields()\n * setUpdatePointerFields(pointerFields: string[])\n * getUpdateAccess(entity: Entity)\n * setUpdateAccess(entity: Entity, allowed: boolean)\n * getPublicUpdateAccess()\n * setPublicUpdateAccess(allowed: boolean)\n * getRoleUpdateAccess(role: Role)\n * setRoleUpdateAccess(role: Role, allowed: boolean)\n * getDeleteRequiresAuthentication()\n * setDeleteRequiresAuthentication(allowed: boolean)\n * getDeletePointerFields()\n * setDeletePointerFields(pointerFields: string[])\n * getDeleteAccess(entity: Entity)\n * setDeleteAccess(entity: Entity, allowed: boolean)\n * getPublicDeleteAccess()\n * setPublicDeleteAccess(allowed: boolean)\n * getRoleDeleteAccess(role: Role)\n * setRoleDeleteAccess(role: Role, allowed: boolean)\n * getAddFieldRequiresAuthentication()\n * setAddFieldRequiresAuthentication(allowed: boolean)\n * getAddFieldPointerFields()\n * setAddFieldPointerFields(pointerFields: string[])\n * getAddFieldAccess(entity: Entity)\n * setAddFieldAccess(entity: Entity, allowed: boolean)\n * getPublicAddFieldAccess()\n * setPublicAddFieldAccess(allowed: boolean)\n * getRoleAddFieldAccess(role: Role)\n * setRoleAddFieldAccess(role: Role, allowed: boolean)\n * </p>\n *\n * @alias Parse.CLP\n */\nclass ParseCLP {\n  /**\n   * @param {(Parse.User | Parse.Role | object)} userId The user to initialize the CLP for\n   */\n  constructor(userId) {\n    (0, _defineProperty2.default)(this, \"permissionsMap\", void 0);\n    this.permissionsMap = {};\n    // Initialize permissions Map with default permissions\n    for (const [operation, group] of (0, _entries.default)(VALID_PERMISSIONS).call(VALID_PERMISSIONS)) {\n      this.permissionsMap[operation] = (0, _assign.default)({}, group);\n      const action = operation.charAt(0).toUpperCase() + (0, _slice.default)(operation).call(operation, 1);\n      this[`get${action}RequiresAuthentication`] = function () {\n        return this._getAccess(operation, 'requiresAuthentication');\n      };\n      this[`set${action}RequiresAuthentication`] = function (allowed) {\n        this._setAccess(operation, 'requiresAuthentication', allowed);\n      };\n      this[`get${action}PointerFields`] = function () {\n        return this._getAccess(operation, 'pointerFields', false);\n      };\n      this[`set${action}PointerFields`] = function (pointerFields) {\n        this._setArrayAccess(operation, 'pointerFields', pointerFields);\n      };\n      this[`get${action}Access`] = function (entity) {\n        return this._getAccess(operation, entity);\n      };\n      this[`set${action}Access`] = function (entity, allowed) {\n        this._setAccess(operation, entity, allowed);\n      };\n      this[`getPublic${action}Access`] = function () {\n        return this[`get${action}Access`](PUBLIC_KEY);\n      };\n      this[`setPublic${action}Access`] = function (allowed) {\n        this[`set${action}Access`](PUBLIC_KEY, allowed);\n      };\n      this[`getRole${action}Access`] = function (role) {\n        return this[`get${action}Access`](this._getRoleName(role));\n      };\n      this[`setRole${action}Access`] = function (role, allowed) {\n        this[`set${action}Access`](this._getRoleName(role), allowed);\n      };\n    }\n    // Initialize permissions Map with default extended permissions\n    for (const [operation, group] of (0, _entries.default)(VALID_PERMISSIONS_EXTENDED).call(VALID_PERMISSIONS_EXTENDED)) {\n      this.permissionsMap[operation] = (0, _assign.default)({}, group);\n    }\n    if (userId && typeof userId === 'object') {\n      if (userId instanceof _ParseUser.default) {\n        this.setReadAccess(userId, true);\n        this.setWriteAccess(userId, true);\n      } else if (userId instanceof _ParseRole.default) {\n        this.setRoleReadAccess(userId, true);\n        this.setRoleWriteAccess(userId, true);\n      } else {\n        for (const permission in userId) {\n          var _context;\n          const users = userId[permission];\n          const isValidPermission = !!VALID_PERMISSIONS.get(permission);\n          const isValidPermissionExtended = !!VALID_PERMISSIONS_EXTENDED.get(permission);\n          const isValidGroupPermission = (0, _includes.default)(_context = ['readUserFields', 'writeUserFields']).call(_context, permission);\n          if (typeof permission !== 'string' || !(isValidPermission || isValidPermissionExtended || isValidGroupPermission)) {\n            throw new TypeError('Tried to create an CLP with an invalid permission type.');\n          }\n          if (isValidGroupPermission) {\n            if ((0, _every.default)(users).call(users, pointer => typeof pointer === 'string')) {\n              this.permissionsMap[permission] = users;\n              continue;\n            } else {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n          }\n          for (const user in users) {\n            const allowed = users[user];\n            if (typeof allowed !== 'boolean' && !isValidPermissionExtended && user !== 'pointerFields') {\n              throw new TypeError('Tried to create an CLP with an invalid permission value.');\n            }\n            this.permissionsMap[permission][user] = allowed;\n          }\n        }\n      }\n    } else if (typeof userId === 'function') {\n      throw new TypeError('ParseCLP constructed with a function. Did you forget ()?');\n    }\n  }\n\n  /**\n   * Returns a JSON-encoded version of the CLP.\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    return {\n      ...this.permissionsMap\n    };\n  }\n\n  /**\n   * Returns whether this CLP is equal to another object\n   *\n   * @param other The other object to compare to\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (!(other instanceof ParseCLP)) {\n      return false;\n    }\n    const permissions = (0, _keys.default)(this.permissionsMap);\n    const otherPermissions = (0, _keys.default)(other.permissionsMap);\n    if (permissions.length !== otherPermissions.length) {\n      return false;\n    }\n    for (const permission in this.permissionsMap) {\n      if (!other.permissionsMap[permission]) {\n        return false;\n      }\n      const users = (0, _keys.default)(this.permissionsMap[permission]);\n      const otherUsers = (0, _keys.default)(other.permissionsMap[permission]);\n      if (users.length !== otherUsers.length) {\n        return false;\n      }\n      for (const user in this.permissionsMap[permission]) {\n        if (!other.permissionsMap[permission][user]) {\n          return false;\n        }\n        if (this.permissionsMap[permission][user] !== other.permissionsMap[permission][user]) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  _getRoleName(role) {\n    let name = role;\n    if (role instanceof _ParseRole.default) {\n      // Normalize to the String name\n      name = role.getName();\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('role must be a Parse.Role or a String');\n    }\n    return `role:${name}`;\n  }\n  _parseEntity(entity) {\n    let userId = entity;\n    if (userId instanceof _ParseUser.default) {\n      userId = userId.id;\n      if (!userId) {\n        throw new Error('Cannot get access for a Parse.User without an id.');\n      }\n    } else if (userId instanceof _ParseRole.default) {\n      userId = this._getRoleName(userId);\n    }\n    if (typeof userId !== 'string') {\n      throw new TypeError('userId must be a string.');\n    }\n    return userId;\n  }\n  _setAccess(permission, userId, allowed) {\n    userId = this._parseEntity(userId);\n    if (typeof allowed !== 'boolean') {\n      throw new TypeError('allowed must be either true or false.');\n    }\n    const permissions = this.permissionsMap[permission][userId];\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action is needed\n        return;\n      } else {\n        this.permissionsMap[permission][userId] = {};\n      }\n    }\n    if (allowed) {\n      this.permissionsMap[permission][userId] = true;\n    } else {\n      delete this.permissionsMap[permission][userId];\n    }\n  }\n  _getAccess(permission, userId) {\n    let returnBoolean = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    userId = this._parseEntity(userId);\n    const permissions = this.permissionsMap[permission][userId];\n    if (returnBoolean) {\n      if (!permissions) {\n        return false;\n      }\n      return !!this.permissionsMap[permission][userId];\n    }\n    return permissions;\n  }\n  _setArrayAccess(permission, userId, fields) {\n    userId = this._parseEntity(userId);\n    const permissions = this.permissionsMap[permission][userId];\n    if (!permissions) {\n      this.permissionsMap[permission][userId] = [];\n    }\n    if (!fields || (0, _isArray.default)(fields) && fields.length === 0) {\n      delete this.permissionsMap[permission][userId];\n    } else if ((0, _isArray.default)(fields) && (0, _every.default)(fields).call(fields, field => typeof field === 'string')) {\n      this.permissionsMap[permission][userId] = fields;\n    } else {\n      throw new TypeError('fields must be an array of strings or undefined.');\n    }\n  }\n  _setGroupPointerPermission(operation, pointerFields) {\n    const fields = this.permissionsMap[operation];\n    if (!fields) {\n      this.permissionsMap[operation] = [];\n    }\n    if (!pointerFields || (0, _isArray.default)(pointerFields) && pointerFields.length === 0) {\n      delete this.permissionsMap[operation];\n    } else if ((0, _isArray.default)(pointerFields) && (0, _every.default)(pointerFields).call(pointerFields, field => typeof field === 'string')) {\n      this.permissionsMap[operation] = pointerFields;\n    } else {\n      throw new TypeError(`${operation}.pointerFields must be an array of strings or undefined.`);\n    }\n  }\n  _getGroupPointerPermissions(operation) {\n    return this.permissionsMap[operation] || [];\n  }\n\n  /**\n   * Sets user pointer fields to allow permission for get/count/find operations.\n   *\n   * @param {string[]} pointerFields User pointer fields\n   */\n  setReadUserFields(pointerFields) {\n    this._setGroupPointerPermission('readUserFields', pointerFields);\n  }\n\n  /**\n   * @returns {string[]} User pointer fields\n   */\n  getReadUserFields() {\n    return this._getGroupPointerPermissions('readUserFields') || [];\n  }\n\n  /**\n   * Sets user pointer fields to allow permission for create/delete/update/addField operations\n   *\n   * @param {string[]} pointerFields User pointer fields\n   */\n  setWriteUserFields(pointerFields) {\n    this._setGroupPointerPermission('writeUserFields', pointerFields);\n  }\n\n  /**\n   * @returns {string[]} User pointer fields\n   */\n  getWriteUserFields() {\n    return this._getGroupPointerPermissions('writeUserFields') || [];\n  }\n\n  /**\n   * Sets whether the given user is allowed to retrieve fields from this class.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {string[]} fields fields to be protected\n   */\n  setProtectedFields(userId, fields) {\n    this._setArrayAccess('protectedFields', userId, fields);\n  }\n\n  /**\n   * Returns array of fields are accessable to this user.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {string[]}\n   */\n  getProtectedFields(userId) {\n    return this._getAccess('protectedFields', userId, false);\n  }\n\n  /**\n   * Sets whether the given user is allowed to read from this class.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {boolean} allowed whether that user should have read access.\n   */\n  setReadAccess(userId, allowed) {\n    this._setAccess('find', userId, allowed);\n    this._setAccess('get', userId, allowed);\n    this._setAccess('count', userId, allowed);\n  }\n\n  /**\n   * Get whether the given user id is *explicitly* allowed to read from this class.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n  getReadAccess(userId) {\n    return this._getAccess('find', userId) && this._getAccess('get', userId) && this._getAccess('count', userId);\n  }\n\n  /**\n   * Sets whether the given user id is allowed to write to this class.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {boolean} allowed Whether that user should have write access.\n   */\n  setWriteAccess(userId, allowed) {\n    this._setAccess('create', userId, allowed);\n    this._setAccess('update', userId, allowed);\n    this._setAccess('delete', userId, allowed);\n    this._setAccess('addField', userId, allowed);\n  }\n\n  /**\n   * Gets whether the given user id is *explicitly* allowed to write to this class.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n  getWriteAccess(userId) {\n    return this._getAccess('create', userId) && this._getAccess('update', userId) && this._getAccess('delete', userId) && this._getAccess('addField', userId);\n  }\n\n  /**\n   * Sets whether the public is allowed to read from this class.\n   *\n   * @param {boolean} allowed\n   */\n  setPublicReadAccess(allowed) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  }\n\n  /**\n   * Gets whether the public is allowed to read from this class.\n   *\n   * @returns {boolean}\n   */\n  getPublicReadAccess() {\n    return this.getReadAccess(PUBLIC_KEY);\n  }\n\n  /**\n   * Sets whether the public is allowed to write to this class.\n   *\n   * @param {boolean} allowed\n   */\n  setPublicWriteAccess(allowed) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  }\n\n  /**\n   * Gets whether the public is allowed to write to this class.\n   *\n   * @returns {boolean}\n   */\n  getPublicWriteAccess() {\n    return this.getWriteAccess(PUBLIC_KEY);\n  }\n\n  /**\n   * Sets whether the public is allowed to protect fields in this class.\n   *\n   * @param {string[]} fields\n   */\n  setPublicProtectedFields(fields) {\n    this.setProtectedFields(PUBLIC_KEY, fields);\n  }\n\n  /**\n   * Gets whether the public is allowed to read fields from this class.\n   *\n   * @returns {string[]}\n   */\n  getPublicProtectedFields() {\n    return this.getProtectedFields(PUBLIC_KEY);\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to read from this class. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has read access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleReadAccess(role) {\n    return this.getReadAccess(this._getRoleName(role));\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to write to this user. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has write access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleWriteAccess(role) {\n    return this.getWriteAccess(this._getRoleName(role));\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to read from this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can read this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleReadAccess(role, allowed) {\n    this.setReadAccess(this._getRoleName(role), allowed);\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to write to this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can write this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleWriteAccess(role, allowed) {\n    this.setWriteAccess(this._getRoleName(role), allowed);\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to count to this user. Even if this returns false, the role may\n   * still be able to count it if a parent role has count access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {string[]}\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleProtectedFields(role) {\n    return this.getProtectedFields(this._getRoleName(role));\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to set access field in this class.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {string[]} fields Fields to be protected by Role.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleProtectedFields(role, fields) {\n    this.setProtectedFields(this._getRoleName(role), fields);\n  }\n}\nvar _default = exports.default = ParseCLP;"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8DAA8D,CAAC;AACpG,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,sDAAsD,CAAC;AAC5FD,sBAAsB,CAACG,OAAO,EAAE,YAAY,EAAE;EAC5CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AACxB,IAAIC,gBAAgB,GAAGJ,sBAAsB,CAACD,OAAO,CAAC,+CAA+C,CAAC,CAAC;AACvG,IAAIM,IAAI,GAAGL,sBAAsB,CAACD,OAAO,CAAC,2CAA2C,CAAC,CAAC;AACvF,IAAIO,QAAQ,GAAGN,sBAAsB,CAACD,OAAO,CAAC,wDAAwD,CAAC,CAAC;AACxG,IAAIQ,OAAO,GAAGP,sBAAsB,CAACD,OAAO,CAAC,qDAAqD,CAAC,CAAC;AACpG,IAAIS,MAAM,GAAGR,sBAAsB,CAACD,OAAO,CAAC,sDAAsD,CAAC,CAAC;AACpG,IAAIU,SAAS,GAAGT,sBAAsB,CAACD,OAAO,CAAC,yDAAyD,CAAC,CAAC;AAC1G,IAAIW,MAAM,GAAGV,sBAAsB,CAACD,OAAO,CAAC,sDAAsD,CAAC,CAAC;AACpG,IAAIY,KAAK,GAAGX,sBAAsB,CAACD,OAAO,CAAC,mDAAmD,CAAC,CAAC;AAChG,IAAIa,QAAQ,GAAGZ,sBAAsB,CAACD,OAAO,CAAC,sDAAsD,CAAC,CAAC;AACtG,IAAIc,UAAU,GAAGb,sBAAsB,CAACD,OAAO,CAAC,aAAa,CAAC,CAAC;AAC/D,IAAIe,UAAU,GAAGd,sBAAsB,CAACD,OAAO,CAAC,aAAa,CAAC,CAAC;AAC/D,MAAMgB,UAAU,GAAG,GAAG;AACtB,MAAMC,iBAAiB,GAAG,IAAIX,IAAI,CAACF,OAAO,CAAC,CAAC;AAC5Ca,iBAAiB,CAACC,GAAG,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;AAChCD,iBAAiB,CAACC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;AACjCD,iBAAiB,CAACC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;AAClCD,iBAAiB,CAACC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AACnCD,iBAAiB,CAACC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AACnCD,iBAAiB,CAACC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;AACnCD,iBAAiB,CAACC,GAAG,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC;AACrC,MAAMC,0BAA0B,GAAG,IAAIb,IAAI,CAACF,OAAO,CAAC,CAAC;AACrDe,0BAA0B,CAACD,GAAG,CAAC,iBAAiB,EAAE,CAAC,CAAC,CAAC;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,QAAQ,CAAC;EACb;AACF;AACA;EACEC,WAAWA,CAACC,MAAM,EAAE;IAClB,CAAC,CAAC,EAAEjB,gBAAgB,CAACD,OAAO,EAAE,IAAI,EAAE,gBAAgB,EAAE,KAAK,CAAC,CAAC;IAC7D,IAAI,CAACmB,cAAc,GAAG,CAAC,CAAC;IACxB;IACA,KAAK,MAAM,CAACC,SAAS,EAAEC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAElB,QAAQ,CAACH,OAAO,EAAEa,iBAAiB,CAAC,CAACS,IAAI,CAACT,iBAAiB,CAAC,EAAE;MACjG,IAAI,CAACM,cAAc,CAACC,SAAS,CAAC,GAAG,CAAC,CAAC,EAAEhB,OAAO,CAACJ,OAAO,EAAE,CAAC,CAAC,EAAEqB,KAAK,CAAC;MAChE,MAAME,MAAM,GAAG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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}