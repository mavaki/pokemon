{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n/**\n * Creates a new GeoPoint with any of the following forms:<br>\n *   <pre>\n *   new GeoPoint(otherGeoPoint)\n *   new GeoPoint(30, 30)\n *   new GeoPoint([30, 30])\n *   new GeoPoint({latitude: 30, longitude: 30})\n *   new GeoPoint()  // defaults to (0, 0)\n *   </pre>\n * <p>Represents a latitude / longitude point that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Only one key in a class may contain a GeoPoint.</p>\n *\n * <p>Example:<pre>\n *   var point = new Parse.GeoPoint(30.0, -20.0);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"location\", point);\n *   object.save();</pre></p>\n *\n * @alias Parse.GeoPoint\n */\n/* global navigator */\nclass ParseGeoPoint {\n  /**\n   * @param {(number[] | object | number)} arg1 Either a list of coordinate pairs, an object with `latitude`, `longitude`, or the latitude or the point.\n   * @param {number} arg2 The longitude of the GeoPoint\n   */\n  constructor(arg1, arg2) {\n    (0, _defineProperty2.default)(this, \"_latitude\", void 0);\n    (0, _defineProperty2.default)(this, \"_longitude\", void 0);\n    if ((0, _isArray.default)(arg1)) {\n      ParseGeoPoint._validate(arg1[0], arg1[1]);\n      this._latitude = arg1[0];\n      this._longitude = arg1[1];\n    } else if (typeof arg1 === 'object') {\n      ParseGeoPoint._validate(arg1.latitude, arg1.longitude);\n      this._latitude = arg1.latitude;\n      this._longitude = arg1.longitude;\n    } else if (arg1 !== undefined && arg2 !== undefined) {\n      ParseGeoPoint._validate(arg1, arg2);\n      this._latitude = arg1;\n      this._longitude = arg2;\n    } else {\n      this._latitude = 0;\n      this._longitude = 0;\n    }\n  }\n\n  /**\n   * North-south portion of the coordinate, in range [-90, 90].\n   * Throws an exception if set out of range in a modern browser.\n   *\n   * @property {number} latitude\n   * @returns {number}\n   */\n  get latitude() {\n    return this._latitude;\n  }\n  set latitude(val) {\n    ParseGeoPoint._validate(val, this.longitude);\n    this._latitude = val;\n  }\n\n  /**\n   * East-west portion of the coordinate, in range [-180, 180].\n   * Throws if set out of range in a modern browser.\n   *\n   * @property {number} longitude\n   * @returns {number}\n   */\n  get longitude() {\n    return this._longitude;\n  }\n  set longitude(val) {\n    ParseGeoPoint._validate(this.latitude, val);\n    this._longitude = val;\n  }\n\n  /**\n   * Returns a JSON representation of the GeoPoint, suitable for Parse.\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    ParseGeoPoint._validate(this._latitude, this._longitude);\n    return {\n      __type: 'GeoPoint',\n      latitude: this._latitude,\n      longitude: this._longitude\n    };\n  }\n  equals(other) {\n    return other instanceof ParseGeoPoint && this.latitude === other.latitude && this.longitude === other.longitude;\n  }\n\n  /**\n   * Returns the distance from this GeoPoint to another in radians.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n  radiansTo(point) {\n    const d2r = Math.PI / 180.0;\n    const lat1rad = this.latitude * d2r;\n    const long1rad = this.longitude * d2r;\n    const lat2rad = point.latitude * d2r;\n    const long2rad = point.longitude * d2r;\n    const sinDeltaLatDiv2 = Math.sin((lat1rad - lat2rad) / 2);\n    const sinDeltaLongDiv2 = Math.sin((long1rad - long2rad) / 2);\n    // Square of half the straight line chord distance between both points.\n    let a = sinDeltaLatDiv2 * sinDeltaLatDiv2 + Math.cos(lat1rad) * Math.cos(lat2rad) * sinDeltaLongDiv2 * sinDeltaLongDiv2;\n    a = Math.min(1.0, a);\n    return 2 * Math.asin(Math.sqrt(a));\n  }\n\n  /**\n   * Returns the distance from this GeoPoint to another in kilometers.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n  kilometersTo(point) {\n    return this.radiansTo(point) * 6371.0;\n  }\n\n  /**\n   * Returns the distance from this GeoPoint to another in miles.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n  milesTo(point) {\n    return this.radiansTo(point) * 3958.8;\n  }\n\n  /*\n   * Throws an exception if the given lat-long is out of bounds.\n   */\n  static _validate(latitude, longitude) {\n    if (isNaN(latitude) || isNaN(longitude) || typeof latitude !== 'number' || typeof longitude !== 'number') {\n      throw new TypeError('GeoPoint latitude and longitude must be valid numbers');\n    }\n    if (latitude < -90.0) {\n      throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' < -90.0.');\n    }\n    if (latitude > 90.0) {\n      throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' > 90.0.');\n    }\n    if (longitude < -180.0) {\n      throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' < -180.0.');\n    }\n    if (longitude > 180.0) {\n      throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' > 180.0.');\n    }\n  }\n\n  /**\n   * Creates a GeoPoint with the user's current location, if available.\n   *\n   * @param {object} options The options.\n   * @param {boolean} [options.enableHighAccuracy] A boolean value that indicates the application would like to receive the best possible results.\n   *  If true and if the device is able to provide a more accurate position, it will do so.\n   *  Note that this can result in slower response times or increased power consumption (with a GPS chip on a mobile device for example).\n   *  On the other hand, if false, the device can take the liberty to save resources by responding more quickly and/or using less power. Default: false.\n   * @param {number} [options.timeout] A positive long value representing the maximum length of time (in milliseconds) the device is allowed to take in order to return a position.\n   *  The default value is Infinity, meaning that getCurrentPosition() won't return until the position is available.\n   * @param {number} [options.maximumAge] A positive long value indicating the maximum age in milliseconds of a possible cached position that is acceptable to return.\n   *  If set to 0, it means that the device cannot use a cached position and must attempt to retrieve the real current position.\n   *  If set to Infinity the device must return a cached position regardless of its age. Default: 0.\n   * @static\n   * @returns {Promise<Parse.GeoPoint>} User's current location\n   */\n  static current(options) {\n    return new _promise.default((resolve, reject) => {\n      navigator.geolocation.getCurrentPosition(location => {\n        resolve(new ParseGeoPoint(location.coords.latitude, location.coords.longitude));\n      }, reject, options);\n    });\n  }\n}\nvar _default = exports.default = ParseGeoPoint;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_isArray","_promise","_defineProperty2","ParseGeoPoint","constructor","arg1","arg2","_validate","_latitude","_longitude","latitude","longitude","undefined","val","toJSON","__type","equals","other","radiansTo","point","d2r","Math","PI","lat1rad","long1rad","lat2rad","long2rad","sinDeltaLatDiv2","sin","sinDeltaLongDiv2","a","cos","min","asin","sqrt","kilometersTo","milesTo","isNaN","TypeError","current","options","resolve","reject","navigator","geolocation","getCurrentPosition","location","coords","_default"],"sources":["/home/mavrik/Documents/classes/web-dev/feature05/node_modules/parse/lib/browser/ParseGeoPoint.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\n/**\n * Creates a new GeoPoint with any of the following forms:<br>\n *   <pre>\n *   new GeoPoint(otherGeoPoint)\n *   new GeoPoint(30, 30)\n *   new GeoPoint([30, 30])\n *   new GeoPoint({latitude: 30, longitude: 30})\n *   new GeoPoint()  // defaults to (0, 0)\n *   </pre>\n * <p>Represents a latitude / longitude point that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Only one key in a class may contain a GeoPoint.</p>\n *\n * <p>Example:<pre>\n *   var point = new Parse.GeoPoint(30.0, -20.0);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"location\", point);\n *   object.save();</pre></p>\n *\n * @alias Parse.GeoPoint\n */\n/* global navigator */\nclass ParseGeoPoint {\n  /**\n   * @param {(number[] | object | number)} arg1 Either a list of coordinate pairs, an object with `latitude`, `longitude`, or the latitude or the point.\n   * @param {number} arg2 The longitude of the GeoPoint\n   */\n  constructor(arg1, arg2) {\n    (0, _defineProperty2.default)(this, \"_latitude\", void 0);\n    (0, _defineProperty2.default)(this, \"_longitude\", void 0);\n    if ((0, _isArray.default)(arg1)) {\n      ParseGeoPoint._validate(arg1[0], arg1[1]);\n      this._latitude = arg1[0];\n      this._longitude = arg1[1];\n    } else if (typeof arg1 === 'object') {\n      ParseGeoPoint._validate(arg1.latitude, arg1.longitude);\n      this._latitude = arg1.latitude;\n      this._longitude = arg1.longitude;\n    } else if (arg1 !== undefined && arg2 !== undefined) {\n      ParseGeoPoint._validate(arg1, arg2);\n      this._latitude = arg1;\n      this._longitude = arg2;\n    } else {\n      this._latitude = 0;\n      this._longitude = 0;\n    }\n  }\n\n  /**\n   * North-south portion of the coordinate, in range [-90, 90].\n   * Throws an exception if set out of range in a modern browser.\n   *\n   * @property {number} latitude\n   * @returns {number}\n   */\n  get latitude() {\n    return this._latitude;\n  }\n  set latitude(val) {\n    ParseGeoPoint._validate(val, this.longitude);\n    this._latitude = val;\n  }\n\n  /**\n   * East-west portion of the coordinate, in range [-180, 180].\n   * Throws if set out of range in a modern browser.\n   *\n   * @property {number} longitude\n   * @returns {number}\n   */\n  get longitude() {\n    return this._longitude;\n  }\n  set longitude(val) {\n    ParseGeoPoint._validate(this.latitude, val);\n    this._longitude = val;\n  }\n\n  /**\n   * Returns a JSON representation of the GeoPoint, suitable for Parse.\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    ParseGeoPoint._validate(this._latitude, this._longitude);\n    return {\n      __type: 'GeoPoint',\n      latitude: this._latitude,\n      longitude: this._longitude\n    };\n  }\n  equals(other) {\n    return other instanceof ParseGeoPoint && this.latitude === other.latitude && this.longitude === other.longitude;\n  }\n\n  /**\n   * Returns the distance from this GeoPoint to another in radians.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n  radiansTo(point) {\n    const d2r = Math.PI / 180.0;\n    const lat1rad = this.latitude * d2r;\n    const long1rad = this.longitude * d2r;\n    const lat2rad = point.latitude * d2r;\n    const long2rad = point.longitude * d2r;\n    const sinDeltaLatDiv2 = Math.sin((lat1rad - lat2rad) / 2);\n    const sinDeltaLongDiv2 = Math.sin((long1rad - long2rad) / 2);\n    // Square of half the straight line chord distance between both points.\n    let a = sinDeltaLatDiv2 * sinDeltaLatDiv2 + Math.cos(lat1rad) * Math.cos(lat2rad) * sinDeltaLongDiv2 * sinDeltaLongDiv2;\n    a = Math.min(1.0, a);\n    return 2 * Math.asin(Math.sqrt(a));\n  }\n\n  /**\n   * Returns the distance from this GeoPoint to another in kilometers.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n  kilometersTo(point) {\n    return this.radiansTo(point) * 6371.0;\n  }\n\n  /**\n   * Returns the distance from this GeoPoint to another in miles.\n   *\n   * @param {Parse.GeoPoint} point the other Parse.GeoPoint.\n   * @returns {number}\n   */\n  milesTo(point) {\n    return this.radiansTo(point) * 3958.8;\n  }\n\n  /*\n   * Throws an exception if the given lat-long is out of bounds.\n   */\n  static _validate(latitude, longitude) {\n    if (isNaN(latitude) || isNaN(longitude) || typeof latitude !== 'number' || typeof longitude !== 'number') {\n      throw new TypeError('GeoPoint latitude and longitude must be valid numbers');\n    }\n    if (latitude < -90.0) {\n      throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' < -90.0.');\n    }\n    if (latitude > 90.0) {\n      throw new TypeError('GeoPoint latitude out of bounds: ' + latitude + ' > 90.0.');\n    }\n    if (longitude < -180.0) {\n      throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' < -180.0.');\n    }\n    if (longitude > 180.0) {\n      throw new TypeError('GeoPoint longitude out of bounds: ' + longitude + ' > 180.0.');\n    }\n  }\n\n  /**\n   * Creates a GeoPoint with the user's current location, if available.\n   *\n   * @param {object} options The options.\n   * @param {boolean} [options.enableHighAccuracy] A boolean value that indicates the application would like to receive the best possible results.\n   *  If true and if the device is able to provide a more accurate position, it will do so.\n   *  Note that this can result in slower response times or increased power consumption (with a GPS chip on a mobile device for example).\n   *  On the other hand, if false, the device can take the liberty to save resources by responding more quickly and/or using less power. Default: false.\n   * @param {number} [options.timeout] A positive long value representing the maximum length of time (in milliseconds) the device is allowed to take in order to return a position.\n   *  The default value is Infinity, meaning that getCurrentPosition() won't return until the position is available.\n   * @param {number} [options.maximumAge] A positive long value indicating the maximum age in milliseconds of a possible cached position that is acceptable to return.\n   *  If set to 0, it means that the device cannot use a cached position and must attempt to retrieve the real current position.\n   *  If set to Infinity the device must return a cached position regardless of its age. Default: 0.\n   * @static\n   * @returns {Promise<Parse.GeoPoint>} User's current location\n   */\n  static current(options) {\n    return new _promise.default((resolve, reject) => {\n      navigator.geolocation.getCurrentPosition(location => {\n        resolve(new ParseGeoPoint(location.coords.latitude, location.coords.longitude));\n      }, reject, options);\n    });\n  }\n}\nvar _default = exports.default = ParseGeoPoint;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}